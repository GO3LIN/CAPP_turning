# This file was generated by exp2python.  You probably don't want to edit
# it since your modifications will be lost if exp2python is used to
# regenerate it.
import sys

from SCL.SCLBase import *
from SCL.SimpleDataTypes import *
from SCL.ConstructedDataTypes import *
from SCL.AggregationDataTypes import *
from SCL.TypeChecker import check_type
from SCL.Builtin import *
from SCL.Rules import *

schema_name = 'ap238_arm_schema'

schema_scope = sys.modules[__name__]

# Defined datatype faceted_brep_shape_representation
class faceted_brep_shape_representation(STRING):
	def __init__(self,*kargs):
		pass

# Defined datatype date_and_time
class date_and_time(STRING):
	def __init__(self,*kargs):
		pass

# Defined datatype text
class text(STRING):
	def __init__(self,*kargs):
		pass

# Defined datatype advanced_brep_shape_representation
class advanced_brep_shape_representation(STRING):
	def __init__(self,*kargs):
		pass

# Defined datatype person
class person(STRING):
	def __init__(self,*kargs):
		pass

# Defined datatype path
class path(STRING):
	def __init__(self,*kargs):
		pass

# Defined datatype edge_based_wireframe_shape_representation
class edge_based_wireframe_shape_representation(STRING):
	def __init__(self,*kargs):
		pass

# Defined datatype bounded_surface
class bounded_surface(STRING):
	def __init__(self,*kargs):
		pass

# Defined datatype representation_context
class representation_context(STRING):
	def __init__(self,*kargs):
		pass

# Defined datatype shape_representation
class shape_representation(STRING):
	def __init__(self,*kargs):
		pass

# Defined datatype identifier
class identifier(STRING):
	def __init__(self,*kargs):
		pass

# Defined datatype parameter_value
class parameter_value(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype organization
class organization(STRING):
	def __init__(self,*kargs):
		pass

# Defined datatype cartesian_point
class cartesian_point(STRING):
	def __init__(self,*kargs):
		pass

# Defined datatype geometrically_bounded_wireframe_shape_representation
class geometrically_bounded_wireframe_shape_representation(STRING):
	def __init__(self,*kargs):
		pass

# Defined datatype elementary_surface
class elementary_surface(STRING):
	def __init__(self,*kargs):
		pass

# Defined datatype open_shell
class open_shell(STRING):
	def __init__(self,*kargs):
		pass

# Defined datatype axis2_placement_3d
class axis2_placement_3d(STRING):
	def __init__(self,*kargs):
		pass

# Defined datatype face
class face(STRING):
	def __init__(self,*kargs):
		pass

# Defined datatype bounded_pcurve
class bounded_pcurve(STRING):
	def __init__(self,*kargs):
		pass

# Defined datatype plane
class plane(STRING):
	def __init__(self,*kargs):
		pass

# Defined datatype feed_per_rev_type
class feed_per_rev_type(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype b_spline_curve
class b_spline_curve(STRING):
	def __init__(self,*kargs):
		pass

# Defined datatype non_manifold_surface_shape_representation
class non_manifold_surface_shape_representation(STRING):
	def __init__(self,*kargs):
		pass

# Defined datatype measure_value
class measure_value(STRING):
	def __init__(self,*kargs):
		pass

# Defined datatype curve
class curve(STRING):
	def __init__(self,*kargs):
		pass

# Defined datatype date
class date(STRING):
	def __init__(self,*kargs):
		pass

# Defined datatype positive_ratio_measure
class positive_ratio_measure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype dwell_revolution
class dwell_revolution(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype shape_element
class shape_element(STRING):
	def __init__(self,*kargs):
		pass

# Defined datatype bounded_curve
class bounded_curve(STRING):
	def __init__(self,*kargs):
		pass

# Defined datatype right_circular_cylinder
class right_circular_cylinder(STRING):
	def __init__(self,*kargs):
		pass

# Defined datatype manifold_surface_shape_representation
class manifold_surface_shape_representation(STRING):
	def __init__(self,*kargs):
		pass

# Defined datatype label
class label(STRING):
	def __init__(self,*kargs):
		pass

# Defined datatype geometrically_bounded_surface_shape_representation
class geometrically_bounded_surface_shape_representation(STRING):
	def __init__(self,*kargs):
		pass

# Defined datatype direction
class direction(STRING):
	def __init__(self,*kargs):
		pass

# Defined datatype person_and_organization
class person_and_organization(STRING):
	def __init__(self,*kargs):
		pass

# Defined datatype axis_placement
class axis_placement(STRING):
	def __init__(self,*kargs):
		pass

# Defined datatype shell_based_wireframe_shape_representation
class shell_based_wireframe_shape_representation(STRING):
	def __init__(self,*kargs):
		pass

# Defined datatype advanced_face
class advanced_face(STRING):
	def __init__(self,*kargs):
		pass

# Defined datatype address
class address(STRING):
	def __init__(self,*kargs):
		pass

# Defined datatype edge_curve
class edge_curve(STRING):
	def __init__(self,*kargs):
		pass

# Defined datatype block
class block(STRING):
	def __init__(self,*kargs):
		pass

# Defined datatype material_removal_curve
class material_removal_curve(bounded_curve):
	def __init__(self,*kargs):
		pass

# SELECT TYPE restricted_area_select
restricted_area_select = SELECT(
	'bounded_surface',
	'bounding_geometry_select',
	scope = schema_scope)
# SELECT TYPE limitation_select
limitation_select = SELECT(
	'limit_qualifier',
	'plus_minus_value',
	'limits_and_fits',
	scope = schema_scope)
# SELECT TYPE general_property_item
general_property_item = SELECT(
	'shape_element',
	'workpiece',
	scope = schema_scope)
# SELECT TYPE compound_feature_select
compound_feature_select = SELECT(
	'machining_feature',
	'transition_feature',
	scope = schema_scope)
# SELECT TYPE speed_select
speed_select = SELECT(
	'const_spindle_speed',
	'const_cutting_speed',
	scope = schema_scope)
# SELECT TYPE security_classification_item
security_classification_item = SELECT(
	'executable',
	'operation',
	'project',
	'toolpath',
	'workpiece',
	scope = schema_scope)
# Defined datatype coolant_select
class coolant_select(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype speed_name
class speed_name(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype toolpath_type
class toolpath_type(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype pathmode_type
class pathmode_type(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype thread_profile_type
class thread_profile_type(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype tool_reference_point
class tool_reference_point(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE path_shape_item
path_shape_item = SELECT(
	'bounded_curve',
	'edge_curve',
	'path',
	scope = schema_scope)
# Defined datatype rot_direction
class rot_direction(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype thread_type
class thread_type(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype knurl_pattern_type
class knurl_pattern_type(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype hand_of_cut_type
class hand_of_cut_type(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE last_modified_timestamp_item
last_modified_timestamp_item = SELECT(
	'executable',
	'operation',
	'project',
	'toolpath',
	'workpiece',
	scope = schema_scope)
# SELECT TYPE taper_select
taper_select = SELECT(
	'diameter_taper',
	'angle_taper',
	scope = schema_scope)
# SELECT TYPE bounding_geometry_select
bounding_geometry_select = SELECT(
	'block',
	'right_circular_cylinder',
	'advanced_brep_shape_representation',
	'edge_based_wireframe_shape_representation',
	'faceted_brep_shape_representation',
	'geometrically_bounded_surface_shape_representation',
	'geometrically_bounded_wireframe_shape_representation',
	'manifold_surface_shape_representation',
	'non_manifold_surface_shape_representation',
	'shell_based_wireframe_shape_representation',
	scope = schema_scope)
# Defined datatype bottom_or_side
class bottom_or_side(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype thread_cut_depth_type
class thread_cut_depth_type(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype thread_hand_type
class thread_hand_type(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype contact_type
class contact_type(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype hand_of_tool_type
class hand_of_tool_type(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE dimension_value_select
dimension_value_select = SELECT(
	'value_with_tolerance',
	'value_range',
	scope = schema_scope)
# SELECT TYPE dwell_select
dwell_select = SELECT(
	'time_measure',
	'dwell_revolution',
	scope = schema_scope)
# SELECT TYPE feed_select
feed_select = SELECT(
	'speed_measure',
	'feed_per_rev_type',
	scope = schema_scope)
# SELECT TYPE corner_transition_select
corner_transition_select = SELECT(
	'chamfered_corner',
	'rounded_corner',
	'profiled_corner',
	scope = schema_scope)
# Defined datatype cutmode_type
class cutmode_type(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype stroke_connection_strategy
class stroke_connection_strategy(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE material_removal_measure
material_removal_measure = SELECT(
	'length_measure',
	'material_removal_curve',
	scope = schema_scope)
# SELECT TYPE curve_with_surface_normal
curve_with_surface_normal = SELECT(
	'bounded_pcurve',
	'curve_with_normal_vector',
	scope = schema_scope)
# SELECT TYPE profile_select
profile_select = SELECT(
	'through_profile_floor',
	'profile_floor',
	scope = schema_scope)
# SELECT TYPE rvalue
rvalue = SELECT(
	'nc_constant',
	'nc_variable',
	scope = schema_scope)
# SELECT TYPE toolpath_speedprofile
toolpath_speedprofile = SELECT(
	'toolpath_speed',
	'positive_ratio_measure',
	'speed_name',
	scope = schema_scope)
# Defined datatype threading_direction_type
class threading_direction_type(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype left_or_right
class left_or_right(ENUMERATION):
	def __init__(self,*kargs):
		pass


####################
 # ENTITY tolerance_zone_definition #
####################
class tolerance_zone_definition(BaseEntityClass):
	'''Entity tolerance_zone_definition definition.

	:param defining
	:type defining:tolerance_zone

	:param first_element
	:type first_element:shape_element

	:param second_element
	:type second_element:shape_element
	'''
	def __init__( self , defining,first_element,second_element, ):
		self._defining = defining
		self._first_element = first_element
		self._second_element = second_element

	@property
	def defining(self):
		return self._defining
	@defining.setter
	def defining(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,tolerance_zone):
			self._defining = tolerance_zone(value)
		else:
			self._defining = value

	@property
	def first_element(self):
		return self._first_element
	@first_element.setter
	def first_element(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,shape_element):
			self._first_element = shape_element(value)
		else:
			self._first_element = value

	@property
	def second_element(self):
		return self._second_element
	@second_element.setter
	def second_element(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,shape_element):
				self._second_element = shape_element(value)
			else:
				self._second_element = value
		else:
			self._second_element = value

####################
 # ENTITY projection #
####################
class projection(tolerance_zone_definition):
	'''Entity projection definition.

	:param projection_end
	:type projection_end:shape_element

	:param projection_length
	:type projection_length:value_with_unit
	'''
	def __init__( self , inherited0__defining , inherited1__first_element , inherited2__second_element , projection_end,projection_length, ):
		tolerance_zone_definition.__init__(self , inherited0__defining , inherited1__first_element , inherited2__second_element , )
		self._projection_end = projection_end
		self._projection_length = projection_length

	@property
	def projection_end(self):
		return self._projection_end
	@projection_end.setter
	def projection_end(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,shape_element):
			self._projection_end = shape_element(value)
		else:
			self._projection_end = value

	@property
	def projection_length(self):
		return self._projection_length
	@projection_length.setter
	def projection_length(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,value_with_unit):
			self._projection_length = value_with_unit(value)
		else:
			self._projection_length = value

####################
 # ENTITY property_parameter #
####################
class property_parameter(BaseEntityClass):
	'''Entity property_parameter definition.

	:param parameter_name
	:type parameter_name:label
	'''
	def __init__( self , parameter_name, ):
		self._parameter_name = parameter_name

	@property
	def parameter_name(self):
		return self._parameter_name
	@parameter_name.setter
	def parameter_name(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,label):
			self._parameter_name = label(value)
		else:
			self._parameter_name = value

####################
 # ENTITY cutting_edge_properties #
####################
class cutting_edge_properties(BaseEntityClass):
	'''Entity cutting_edge_properties definition.

	:param its_material
	:type its_material:material

	:param expected_tool_life
	:type expected_tool_life:time_measure

	:param its_technology
	:type its_technology:technology

	:param cutting_edge_length
	:type cutting_edge_length:length_measure

	:param tool_cutting_edge_angle
	:type tool_cutting_edge_angle:plane_angle_measure

	:param tool_cutting_edge_angle_type
	:type tool_cutting_edge_angle_type:STRING

	:param tool_included_angle
	:type tool_included_angle:plane_angle_measure

	:param corner_transitions
	:type corner_transitions:LIST(0,None,'corner_transition', scope = schema_scope)

	:param maximum_side_cutting_depth
	:type maximum_side_cutting_depth:length_measure

	:param maximum_end_cutting_depth
	:type maximum_end_cutting_depth:length_measure
	'''
	def __init__( self , its_material,expected_tool_life,its_technology,cutting_edge_length,tool_cutting_edge_angle,tool_cutting_edge_angle_type,tool_included_angle,corner_transitions,maximum_side_cutting_depth,maximum_end_cutting_depth, ):
		self._its_material = its_material
		self._expected_tool_life = expected_tool_life
		self._its_technology = its_technology
		self._cutting_edge_length = cutting_edge_length
		self._tool_cutting_edge_angle = tool_cutting_edge_angle
		self._tool_cutting_edge_angle_type = tool_cutting_edge_angle_type
		self._tool_included_angle = tool_included_angle
		self._corner_transitions = corner_transitions
		self._maximum_side_cutting_depth = maximum_side_cutting_depth
		self._maximum_end_cutting_depth = maximum_end_cutting_depth

	@property
	def its_material(self):
		return self._its_material
	@its_material.setter
	def its_material(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,material):
				self._its_material = material(value)
			else:
				self._its_material = value
		else:
			self._its_material = value

	@property
	def expected_tool_life(self):
		return self._expected_tool_life
	@expected_tool_life.setter
	def expected_tool_life(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,time_measure):
				self._expected_tool_life = time_measure(value)
			else:
				self._expected_tool_life = value
		else:
			self._expected_tool_life = value

	@property
	def its_technology(self):
		return self._its_technology
	@its_technology.setter
	def its_technology(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,technology):
				self._its_technology = technology(value)
			else:
				self._its_technology = value
		else:
			self._its_technology = value

	@property
	def cutting_edge_length(self):
		return self._cutting_edge_length
	@cutting_edge_length.setter
	def cutting_edge_length(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,length_measure):
				self._cutting_edge_length = length_measure(value)
			else:
				self._cutting_edge_length = value
		else:
			self._cutting_edge_length = value

	@property
	def tool_cutting_edge_angle(self):
		return self._tool_cutting_edge_angle
	@tool_cutting_edge_angle.setter
	def tool_cutting_edge_angle(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,plane_angle_measure):
				self._tool_cutting_edge_angle = plane_angle_measure(value)
			else:
				self._tool_cutting_edge_angle = value
		else:
			self._tool_cutting_edge_angle = value

	@property
	def tool_cutting_edge_angle_type(self):
		return self._tool_cutting_edge_angle_type
	@tool_cutting_edge_angle_type.setter
	def tool_cutting_edge_angle_type(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,STRING):
				self._tool_cutting_edge_angle_type = STRING(value)
			else:
				self._tool_cutting_edge_angle_type = value
		else:
			self._tool_cutting_edge_angle_type = value

	@property
	def tool_included_angle(self):
		return self._tool_included_angle
	@tool_included_angle.setter
	def tool_included_angle(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,plane_angle_measure):
				self._tool_included_angle = plane_angle_measure(value)
			else:
				self._tool_included_angle = value
		else:
			self._tool_included_angle = value

	@property
	def corner_transitions(self):
		return self._corner_transitions
	@corner_transitions.setter
	def corner_transitions(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,LIST(0,None,'corner_transition', scope = schema_scope)):
			self._corner_transitions = LIST(value)
		else:
			self._corner_transitions = value

	@property
	def maximum_side_cutting_depth(self):
		return self._maximum_side_cutting_depth
	@maximum_side_cutting_depth.setter
	def maximum_side_cutting_depth(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,length_measure):
				self._maximum_side_cutting_depth = length_measure(value)
			else:
				self._maximum_side_cutting_depth = value
		else:
			self._maximum_side_cutting_depth = value

	@property
	def maximum_end_cutting_depth(self):
		return self._maximum_end_cutting_depth
	@maximum_end_cutting_depth.setter
	def maximum_end_cutting_depth(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,length_measure):
				self._maximum_end_cutting_depth = length_measure(value)
			else:
				self._maximum_end_cutting_depth = value
		else:
			self._maximum_end_cutting_depth = value

####################
 # ENTITY channel #
####################
class channel(BaseEntityClass):
	'''Entity channel definition.

	:param its_id
	:type its_id:identifier
	'''
	def __init__( self , its_id, ):
		self._its_id = its_id

	@property
	def its_id(self):
		return self._its_id
	@its_id.setter
	def its_id(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,identifier):
			self._its_id = identifier(value)
		else:
			self._its_id = value

####################
 # ENTITY two5d_milling_strategy #
####################
class two5d_milling_strategy(BaseEntityClass):
	'''Entity two5d_milling_strategy definition.

	:param overlap
	:type overlap:positive_ratio_measure

	:param allow_multiple_passes
	:type allow_multiple_passes:BOOLEAN
	'''
	def __init__( self , overlap,allow_multiple_passes, ):
		self._overlap = overlap
		self._allow_multiple_passes = allow_multiple_passes

	@property
	def overlap(self):
		return self._overlap
	@overlap.setter
	def overlap(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,positive_ratio_measure):
				self._overlap = positive_ratio_measure(value)
			else:
				self._overlap = value
		else:
			self._overlap = value

	@property
	def allow_multiple_passes(self):
		return self._allow_multiple_passes
	@allow_multiple_passes.setter
	def allow_multiple_passes(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,BOOLEAN):
				self._allow_multiple_passes = BOOLEAN(value)
			else:
				self._allow_multiple_passes = value
		else:
			self._allow_multiple_passes = value

####################
 # ENTITY contour_bidirectional #
####################
class contour_bidirectional(two5d_milling_strategy):
	'''Entity contour_bidirectional definition.

	:param feed_direction
	:type feed_direction:direction

	:param stepover_direction
	:type stepover_direction:left_or_right

	:param rotation_direction
	:type rotation_direction:rot_direction

	:param spiral_cutmode
	:type spiral_cutmode:cutmode_type
	'''
	def __init__( self , inherited0__overlap , inherited1__allow_multiple_passes , feed_direction,stepover_direction,rotation_direction,spiral_cutmode, ):
		two5d_milling_strategy.__init__(self , inherited0__overlap , inherited1__allow_multiple_passes , )
		self._feed_direction = feed_direction
		self._stepover_direction = stepover_direction
		self._rotation_direction = rotation_direction
		self._spiral_cutmode = spiral_cutmode

	@property
	def feed_direction(self):
		return self._feed_direction
	@feed_direction.setter
	def feed_direction(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,direction):
				self._feed_direction = direction(value)
			else:
				self._feed_direction = value
		else:
			self._feed_direction = value

	@property
	def stepover_direction(self):
		return self._stepover_direction
	@stepover_direction.setter
	def stepover_direction(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,left_or_right):
				self._stepover_direction = left_or_right(value)
			else:
				self._stepover_direction = value
		else:
			self._stepover_direction = value

	@property
	def rotation_direction(self):
		return self._rotation_direction
	@rotation_direction.setter
	def rotation_direction(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,rot_direction):
				self._rotation_direction = rot_direction(value)
			else:
				self._rotation_direction = value
		else:
			self._rotation_direction = value

	@property
	def spiral_cutmode(self):
		return self._spiral_cutmode
	@spiral_cutmode.setter
	def spiral_cutmode(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,cutmode_type):
				self._spiral_cutmode = cutmode_type(value)
			else:
				self._spiral_cutmode = value
		else:
			self._spiral_cutmode = value

####################
 # ENTITY operation #
####################
class operation(BaseEntityClass):
	'''Entity operation definition.

	:param its_toolpath
	:type its_toolpath:toolpath_list

	:param its_tool_direction
	:type its_tool_direction:tool_direction
	'''
	def __init__( self , its_toolpath,its_tool_direction, ):
		self._its_toolpath = its_toolpath
		self._its_tool_direction = its_tool_direction

	@property
	def its_toolpath(self):
		return self._its_toolpath
	@its_toolpath.setter
	def its_toolpath(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,toolpath_list):
				self._its_toolpath = toolpath_list(value)
			else:
				self._its_toolpath = value
		else:
			self._its_toolpath = value

	@property
	def its_tool_direction(self):
		return self._its_tool_direction
	@its_tool_direction.setter
	def its_tool_direction(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,tool_direction):
				self._its_tool_direction = tool_direction(value)
			else:
				self._its_tool_direction = value
		else:
			self._its_tool_direction = value

####################
 # ENTITY machining_operation #
####################
class machining_operation(operation):
	'''Entity machining_operation definition.

	:param its_id
	:type its_id:identifier

	:param retract_plane
	:type retract_plane:length_measure

	:param start_point
	:type start_point:cartesian_point

	:param its_tool
	:type its_tool:machining_tool

	:param its_technology
	:type its_technology:technology

	:param its_machine_functions
	:type its_machine_functions:machine_functions
	'''
	def __init__( self , inherited0__its_toolpath , inherited1__its_tool_direction , its_id,retract_plane,start_point,its_tool,its_technology,its_machine_functions, ):
		operation.__init__(self , inherited0__its_toolpath , inherited1__its_tool_direction , )
		self._its_id = its_id
		self._retract_plane = retract_plane
		self._start_point = start_point
		self._its_tool = its_tool
		self._its_technology = its_technology
		self._its_machine_functions = its_machine_functions

	@property
	def its_id(self):
		return self._its_id
	@its_id.setter
	def its_id(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,identifier):
			self._its_id = identifier(value)
		else:
			self._its_id = value

	@property
	def retract_plane(self):
		return self._retract_plane
	@retract_plane.setter
	def retract_plane(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,length_measure):
				self._retract_plane = length_measure(value)
			else:
				self._retract_plane = value
		else:
			self._retract_plane = value

	@property
	def start_point(self):
		return self._start_point
	@start_point.setter
	def start_point(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,cartesian_point):
				self._start_point = cartesian_point(value)
			else:
				self._start_point = value
		else:
			self._start_point = value

	@property
	def its_tool(self):
		return self._its_tool
	@its_tool.setter
	def its_tool(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,machining_tool):
			self._its_tool = machining_tool(value)
		else:
			self._its_tool = value

	@property
	def its_technology(self):
		return self._its_technology
	@its_technology.setter
	def its_technology(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,technology):
			self._its_technology = technology(value)
		else:
			self._its_technology = value

	@property
	def its_machine_functions(self):
		return self._its_machine_functions
	@its_machine_functions.setter
	def its_machine_functions(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,machine_functions):
			self._its_machine_functions = machine_functions(value)
		else:
			self._its_machine_functions = value

####################
 # ENTITY milling_machining_operation #
####################
class milling_machining_operation(machining_operation):
	'''Entity milling_machining_operation definition.

	:param overcut_length
	:type overcut_length:length_measure
	'''
	def __init__( self , inherited0__its_toolpath , inherited1__its_tool_direction , inherited2__its_id , inherited3__retract_plane , inherited4__start_point , inherited5__its_tool , inherited6__its_technology , inherited7__its_machine_functions , overcut_length, ):
		machining_operation.__init__(self , inherited0__its_toolpath , inherited1__its_tool_direction , inherited2__its_id , inherited3__retract_plane , inherited4__start_point , inherited5__its_tool , inherited6__its_technology , inherited7__its_machine_functions , )
		self._overcut_length = overcut_length

	@property
	def overcut_length(self):
		return self._overcut_length
	@overcut_length.setter
	def overcut_length(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,length_measure):
				self._overcut_length = length_measure(value)
			else:
				self._overcut_length = value
		else:
			self._overcut_length = value
	def wr1(self):
		eval_wr1_wr = ((EXISTS(self.self.its_technology.self.feedrate_per_tooth)  and  EXISTS(self.self.its_tool.self.number_of_effective_teeth))  or  ( not EXISTS(self.self.its_technology.self.feedrate_per_tooth)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY drilling_type_operation #
####################
class drilling_type_operation(milling_machining_operation):
	'''Entity drilling_type_operation definition.

	:param cutting_depth
	:type cutting_depth:length_measure

	:param previous_diameter
	:type previous_diameter:length_measure

	:param dwell_time_bottom
	:type dwell_time_bottom:time_measure

	:param feed_on_retract
	:type feed_on_retract:positive_ratio_measure

	:param its_machining_strategy
	:type its_machining_strategy:drilling_type_strategy
	'''
	def __init__( self , inherited0__its_toolpath , inherited1__its_tool_direction , inherited2__its_id , inherited3__retract_plane , inherited4__start_point , inherited5__its_tool , inherited6__its_technology , inherited7__its_machine_functions , inherited8__overcut_length , cutting_depth,previous_diameter,dwell_time_bottom,feed_on_retract,its_machining_strategy, ):
		milling_machining_operation.__init__(self , inherited0__its_toolpath , inherited1__its_tool_direction , inherited2__its_id , inherited3__retract_plane , inherited4__start_point , inherited5__its_tool , inherited6__its_technology , inherited7__its_machine_functions , inherited8__overcut_length , )
		self._cutting_depth = cutting_depth
		self._previous_diameter = previous_diameter
		self._dwell_time_bottom = dwell_time_bottom
		self._feed_on_retract = feed_on_retract
		self._its_machining_strategy = its_machining_strategy

	@property
	def cutting_depth(self):
		return self._cutting_depth
	@cutting_depth.setter
	def cutting_depth(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,length_measure):
				self._cutting_depth = length_measure(value)
			else:
				self._cutting_depth = value
		else:
			self._cutting_depth = value

	@property
	def previous_diameter(self):
		return self._previous_diameter
	@previous_diameter.setter
	def previous_diameter(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,length_measure):
				self._previous_diameter = length_measure(value)
			else:
				self._previous_diameter = value
		else:
			self._previous_diameter = value

	@property
	def dwell_time_bottom(self):
		return self._dwell_time_bottom
	@dwell_time_bottom.setter
	def dwell_time_bottom(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,time_measure):
				self._dwell_time_bottom = time_measure(value)
			else:
				self._dwell_time_bottom = value
		else:
			self._dwell_time_bottom = value

	@property
	def feed_on_retract(self):
		return self._feed_on_retract
	@feed_on_retract.setter
	def feed_on_retract(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,positive_ratio_measure):
				self._feed_on_retract = positive_ratio_measure(value)
			else:
				self._feed_on_retract = value
		else:
			self._feed_on_retract = value

	@property
	def its_machining_strategy(self):
		return self._its_machining_strategy
	@its_machining_strategy.setter
	def its_machining_strategy(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,drilling_type_strategy):
				self._its_machining_strategy = drilling_type_strategy(value)
			else:
				self._its_machining_strategy = value
		else:
			self._its_machining_strategy = value

####################
 # ENTITY boring_operation #
####################
class boring_operation(drilling_type_operation):
	'''Entity boring_operation definition.

	:param spindle_stop_at_bottom
	:type spindle_stop_at_bottom:BOOLEAN

	:param depth_of_testcut
	:type depth_of_testcut:length_measure

	:param waiting_position
	:type waiting_position:cartesian_point
	'''
	def __init__( self , inherited0__its_toolpath , inherited1__its_tool_direction , inherited2__its_id , inherited3__retract_plane , inherited4__start_point , inherited5__its_tool , inherited6__its_technology , inherited7__its_machine_functions , inherited8__overcut_length , inherited9__cutting_depth , inherited10__previous_diameter , inherited11__dwell_time_bottom , inherited12__feed_on_retract , inherited13__its_machining_strategy , spindle_stop_at_bottom,depth_of_testcut,waiting_position, ):
		drilling_type_operation.__init__(self , inherited0__its_toolpath , inherited1__its_tool_direction , inherited2__its_id , inherited3__retract_plane , inherited4__start_point , inherited5__its_tool , inherited6__its_technology , inherited7__its_machine_functions , inherited8__overcut_length , inherited9__cutting_depth , inherited10__previous_diameter , inherited11__dwell_time_bottom , inherited12__feed_on_retract , inherited13__its_machining_strategy , )
		self._spindle_stop_at_bottom = spindle_stop_at_bottom
		self._depth_of_testcut = depth_of_testcut
		self._waiting_position = waiting_position

	@property
	def spindle_stop_at_bottom(self):
		return self._spindle_stop_at_bottom
	@spindle_stop_at_bottom.setter
	def spindle_stop_at_bottom(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,BOOLEAN):
			self._spindle_stop_at_bottom = BOOLEAN(value)
		else:
			self._spindle_stop_at_bottom = value

	@property
	def depth_of_testcut(self):
		return self._depth_of_testcut
	@depth_of_testcut.setter
	def depth_of_testcut(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,length_measure):
				self._depth_of_testcut = length_measure(value)
			else:
				self._depth_of_testcut = value
		else:
			self._depth_of_testcut = value

	@property
	def waiting_position(self):
		return self._waiting_position
	@waiting_position.setter
	def waiting_position(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,cartesian_point):
				self._waiting_position = cartesian_point(value)
			else:
				self._waiting_position = value
		else:
			self._waiting_position = value

####################
 # ENTITY boring #
####################
class boring(boring_operation):
	'''Entity boring definition.
	'''
	def __init__( self , inherited0__its_toolpath , inherited1__its_tool_direction , inherited2__its_id , inherited3__retract_plane , inherited4__start_point , inherited5__its_tool , inherited6__its_technology , inherited7__its_machine_functions , inherited8__overcut_length , inherited9__cutting_depth , inherited10__previous_diameter , inherited11__dwell_time_bottom , inherited12__feed_on_retract , inherited13__its_machining_strategy , inherited14__spindle_stop_at_bottom , inherited15__depth_of_testcut , inherited16__waiting_position ,  ):
		boring_operation.__init__(self , inherited0__its_toolpath , inherited1__its_tool_direction , inherited2__its_id , inherited3__retract_plane , inherited4__start_point , inherited5__its_tool , inherited6__its_technology , inherited7__its_machine_functions , inherited8__overcut_length , inherited9__cutting_depth , inherited10__previous_diameter , inherited11__dwell_time_bottom , inherited12__feed_on_retract , inherited13__its_machining_strategy , inherited14__spindle_stop_at_bottom , inherited15__depth_of_testcut , inherited16__waiting_position , )

####################
 # ENTITY turning_machining_operation #
####################
class turning_machining_operation(machining_operation):
	'''Entity turning_machining_operation definition.

	:param approach
	:type approach:approach_retract_strategy

	:param retract
	:type retract:approach_retract_strategy

	:param its_machining_strategy
	:type its_machining_strategy:turning_machining_strategy
	'''
	def __init__( self , inherited0__its_toolpath , inherited1__its_tool_direction , inherited2__its_id , inherited3__retract_plane , inherited4__start_point , inherited5__its_tool , inherited6__its_technology , inherited7__its_machine_functions , approach,retract,its_machining_strategy, ):
		machining_operation.__init__(self , inherited0__its_toolpath , inherited1__its_tool_direction , inherited2__its_id , inherited3__retract_plane , inherited4__start_point , inherited5__its_tool , inherited6__its_technology , inherited7__its_machine_functions , )
		self._approach = approach
		self._retract = retract
		self._its_machining_strategy = its_machining_strategy

	@property
	def approach(self):
		return self._approach
	@approach.setter
	def approach(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,approach_retract_strategy):
				self._approach = approach_retract_strategy(value)
			else:
				self._approach = value
		else:
			self._approach = value

	@property
	def retract(self):
		return self._retract
	@retract.setter
	def retract(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,approach_retract_strategy):
				self._retract = approach_retract_strategy(value)
			else:
				self._retract = value
		else:
			self._retract = value

	@property
	def its_machining_strategy(self):
		return self._its_machining_strategy
	@its_machining_strategy.setter
	def its_machining_strategy(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,turning_machining_strategy):
				self._its_machining_strategy = turning_machining_strategy(value)
			else:
				self._its_machining_strategy = value
		else:
			self._its_machining_strategy = value

####################
 # ENTITY grooving #
####################
class grooving(turning_machining_operation):
	'''Entity grooving definition.

	:param dwell
	:type dwell:dwell_select

	:param allowance
	:type allowance:length_measure
	'''
	def __init__( self , inherited0__its_toolpath , inherited1__its_tool_direction , inherited2__its_id , inherited3__retract_plane , inherited4__start_point , inherited5__its_tool , inherited6__its_technology , inherited7__its_machine_functions , inherited8__approach , inherited9__retract , inherited10__its_machining_strategy , dwell,allowance, ):
		turning_machining_operation.__init__(self , inherited0__its_toolpath , inherited1__its_tool_direction , inherited2__its_id , inherited3__retract_plane , inherited4__start_point , inherited5__its_tool , inherited6__its_technology , inherited7__its_machine_functions , inherited8__approach , inherited9__retract , inherited10__its_machining_strategy , )
		self._dwell = dwell
		self._allowance = allowance

	@property
	def dwell(self):
		return self._dwell
	@dwell.setter
	def dwell(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,dwell_select):
				self._dwell = dwell_select(value)
			else:
				self._dwell = value
		else:
			self._dwell = value

	@property
	def allowance(self):
		return self._allowance
	@allowance.setter
	def allowance(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,length_measure):
				self._allowance = length_measure(value)
			else:
				self._allowance = value
		else:
			self._allowance = value

####################
 # ENTITY grooving_rough #
####################
class grooving_rough(grooving):
	'''Entity grooving_rough definition.
	'''
	def __init__( self , inherited0__its_toolpath , inherited1__its_tool_direction , inherited2__its_id , inherited3__retract_plane , inherited4__start_point , inherited5__its_tool , inherited6__its_technology , inherited7__its_machine_functions , inherited8__approach , inherited9__retract , inherited10__its_machining_strategy , inherited11__dwell , inherited12__allowance ,  ):
		grooving.__init__(self , inherited0__its_toolpath , inherited1__its_tool_direction , inherited2__its_id , inherited3__retract_plane , inherited4__start_point , inherited5__its_tool , inherited6__its_technology , inherited7__its_machine_functions , inherited8__approach , inherited9__retract , inherited10__its_machining_strategy , inherited11__dwell , inherited12__allowance , )
	def wr1(self):
		eval_wr1_wr = (EXISTS(self.self.allowance)  and  (self.self.allowance  >=  0))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY library_part_assignment #
####################
class library_part_assignment(BaseEntityClass):
	'''Entity library_part_assignment definition.

	:param definitional_class_bsu
	:type definitional_class_bsu:class_bsu

	:param definitional_property_value_pairs
	:type definitional_property_value_pairs:SET(0,None,'library_property_value', scope = schema_scope)
	'''
	def __init__( self , definitional_class_bsu,definitional_property_value_pairs, ):
		self._definitional_class_bsu = definitional_class_bsu
		self._definitional_property_value_pairs = definitional_property_value_pairs

	@property
	def definitional_class_bsu(self):
		return self._definitional_class_bsu
	@definitional_class_bsu.setter
	def definitional_class_bsu(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,class_bsu):
			self._definitional_class_bsu = class_bsu(value)
		else:
			self._definitional_class_bsu = value

	@property
	def definitional_property_value_pairs(self):
		return self._definitional_property_value_pairs
	@definitional_property_value_pairs.setter
	def definitional_property_value_pairs(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(0,None,'library_property_value', scope = schema_scope)):
			self._definitional_property_value_pairs = SET(value)
		else:
			self._definitional_property_value_pairs = value

####################
 # ENTITY numeric_parameter #
####################
class numeric_parameter(property_parameter):
	'''Entity numeric_parameter definition.

	:param its_parameter_value
	:type its_parameter_value:parameter_value

	:param its_parameter_unit
	:type its_parameter_unit:label
	'''
	def __init__( self , inherited0__parameter_name , its_parameter_value,its_parameter_unit, ):
		property_parameter.__init__(self , inherited0__parameter_name , )
		self._its_parameter_value = its_parameter_value
		self._its_parameter_unit = its_parameter_unit

	@property
	def its_parameter_value(self):
		return self._its_parameter_value
	@its_parameter_value.setter
	def its_parameter_value(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,parameter_value):
			self._its_parameter_value = parameter_value(value)
		else:
			self._its_parameter_value = value

	@property
	def its_parameter_unit(self):
		return self._its_parameter_unit
	@its_parameter_unit.setter
	def its_parameter_unit(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,label):
			self._its_parameter_unit = label(value)
		else:
			self._its_parameter_unit = value

####################
 # ENTITY executable #
####################
class executable(BaseEntityClass):
	'''Entity executable definition.

	:param its_id
	:type its_id:identifier
	'''
	def __init__( self , its_id, ):
		self._its_id = its_id

	@property
	def its_id(self):
		return self._its_id
	@its_id.setter
	def its_id(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,identifier):
			self._its_id = identifier(value)
		else:
			self._its_id = value

####################
 # ENTITY nc_function #
####################
class nc_function(executable):
	'''Entity nc_function definition.
	'''
	def __init__( self , inherited0__its_id ,  ):
		executable.__init__(self , inherited0__its_id , )

####################
 # ENTITY display_message #
####################
class display_message(nc_function):
	'''Entity display_message definition.

	:param its_text
	:type its_text:text
	'''
	def __init__( self , inherited0__its_id , its_text, ):
		nc_function.__init__(self , inherited0__its_id , )
		self._its_text = its_text

	@property
	def its_text(self):
		return self._its_text
	@its_text.setter
	def its_text(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,text):
			self._its_text = text(value)
		else:
			self._its_text = value

####################
 # ENTITY toolpath_speed #
####################
class toolpath_speed(BaseEntityClass):
	'''Entity toolpath_speed definition.

	:param speed
	:type speed:bounded_curve
	'''
	def __init__( self , speed, ):
		self._speed = speed

	@property
	def speed(self):
		return self._speed
	@speed.setter
	def speed(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,bounded_curve):
			self._speed = bounded_curve(value)
		else:
			self._speed = value

####################
 # ENTITY geometric_dimension #
####################
class geometric_dimension(BaseEntityClass):
	'''Entity geometric_dimension definition.

	:param id
	:type id:STRING

	:param dimension_value
	:type dimension_value:dimension_value_select

	:param notes
	:type notes:SET(0,None,'STRING', scope = schema_scope)
	'''
	def __init__( self , id,dimension_value,notes, ):
		self._id = id
		self._dimension_value = dimension_value
		self._notes = notes

	@property
	def id(self):
		return self._id
	@id.setter
	def id(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,STRING):
			self._id = STRING(value)
		else:
			self._id = value

	@property
	def dimension_value(self):
		return self._dimension_value
	@dimension_value.setter
	def dimension_value(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,dimension_value_select):
			self._dimension_value = dimension_value_select(value)
		else:
			self._dimension_value = value

	@property
	def notes(self):
		return self._notes
	@notes.setter
	def notes(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(0,None,'STRING', scope = schema_scope)):
			self._notes = SET(value)
		else:
			self._notes = value

####################
 # ENTITY location_dimension #
####################
class location_dimension(geometric_dimension):
	'''Entity location_dimension definition.

	:param description
	:type description:STRING

	:param directed
	:type directed:BOOLEAN

	:param origin
	:type origin:shape_element

	:param target
	:type target:shape_element
	'''
	def __init__( self , inherited0__id , inherited1__dimension_value , inherited2__notes , description,directed,origin,target, ):
		geometric_dimension.__init__(self , inherited0__id , inherited1__dimension_value , inherited2__notes , )
		self._description = description
		self._directed = directed
		self._origin = origin
		self._target = target

	@property
	def description(self):
		return self._description
	@description.setter
	def description(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,STRING):
				self._description = STRING(value)
			else:
				self._description = value
		else:
			self._description = value

	@property
	def directed(self):
		return self._directed
	@directed.setter
	def directed(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,BOOLEAN):
				self._directed = BOOLEAN(value)
			else:
				self._directed = value
		else:
			self._directed = value

	@property
	def origin(self):
		return self._origin
	@origin.setter
	def origin(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,shape_element):
			self._origin = shape_element(value)
		else:
			self._origin = value

	@property
	def target(self):
		return self._target
	@target.setter
	def target(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,shape_element):
			self._target = shape_element(value)
		else:
			self._target = value

####################
 # ENTITY workingstep #
####################
class workingstep(executable):
	'''Entity workingstep definition.

	:param its_secplane
	:type its_secplane:elementary_surface
	'''
	def __init__( self , inherited0__its_id , its_secplane, ):
		executable.__init__(self , inherited0__its_id , )
		self._its_secplane = its_secplane

	@property
	def its_secplane(self):
		return self._its_secplane
	@its_secplane.setter
	def its_secplane(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,elementary_surface):
			self._its_secplane = elementary_surface(value)
		else:
			self._its_secplane = value

####################
 # ENTITY touch_probing #
####################
class touch_probing(workingstep,operation):
	'''Entity touch_probing definition.

	:param measured_offset
	:type measured_offset:nc_variable
	'''
	def __init__( self , inherited0__its_id , inherited1__its_secplane , inherited2__its_toolpath , inherited3__its_tool_direction , measured_offset, ):
		workingstep.__init__(self , inherited0__its_id , inherited1__its_secplane , )
		operation.__init__(self , inherited2__its_toolpath , inherited3__its_tool_direction , )
		self._measured_offset = measured_offset

	@property
	def measured_offset(self):
		return self._measured_offset
	@measured_offset.setter
	def measured_offset(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,nc_variable):
			self._measured_offset = nc_variable(value)
		else:
			self._measured_offset = value

####################
 # ENTITY tool_probing #
####################
class tool_probing(touch_probing):
	'''Entity tool_probing definition.

	:param offset
	:type offset:cartesian_point

	:param max_wear
	:type max_wear:length_measure

	:param its_tool
	:type its_tool:machining_tool
	'''
	def __init__( self , inherited0__its_id , inherited1__its_secplane , inherited2__its_toolpath , inherited3__its_tool_direction , inherited4__measured_offset , offset,max_wear,its_tool, ):
		touch_probing.__init__(self , inherited0__its_id , inherited1__its_secplane , inherited2__its_toolpath , inherited3__its_tool_direction , inherited4__measured_offset , )
		self._offset = offset
		self._max_wear = max_wear
		self._its_tool = its_tool

	@property
	def offset(self):
		return self._offset
	@offset.setter
	def offset(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,cartesian_point):
			self._offset = cartesian_point(value)
		else:
			self._offset = value

	@property
	def max_wear(self):
		return self._max_wear
	@max_wear.setter
	def max_wear(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,length_measure):
			self._max_wear = length_measure(value)
		else:
			self._max_wear = value

	@property
	def its_tool(self):
		return self._its_tool
	@its_tool.setter
	def its_tool(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,machining_tool):
			self._its_tool = machining_tool(value)
		else:
			self._its_tool = value

####################
 # ENTITY bsu #
####################
class bsu(BaseEntityClass):
	'''Entity bsu definition.

	:param code
	:type code:label
	'''
	def __init__( self , code, ):
		self._code = code

	@property
	def code(self):
		return self._code
	@code.setter
	def code(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,label):
			self._code = label(value)
		else:
			self._code = value

####################
 # ENTITY machining_tool #
####################
class machining_tool(BaseEntityClass):
	'''Entity machining_tool definition.

	:param its_id
	:type its_id:label

	:param its_usage
	:type its_usage:tool_usage
	'''
	def __init__( self , its_id,its_usage, ):
		self._its_id = its_id
		self._its_usage = its_usage

	@property
	def its_id(self):
		return self._its_id
	@its_id.setter
	def its_id(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,label):
			self._its_id = label(value)
		else:
			self._its_id = value

	@property
	def its_usage(self):
		return self._its_usage
	@its_usage.setter
	def its_usage(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,tool_usage):
				self._its_usage = tool_usage(value)
			else:
				self._its_usage = value
		else:
			self._its_usage = value

####################
 # ENTITY milling_type_operation #
####################
class milling_type_operation(milling_machining_operation):
	'''Entity milling_type_operation definition.

	:param approach
	:type approach:approach_retract_strategy

	:param retract
	:type retract:approach_retract_strategy
	'''
	def __init__( self , inherited0__its_toolpath , inherited1__its_tool_direction , inherited2__its_id , inherited3__retract_plane , inherited4__start_point , inherited5__its_tool , inherited6__its_technology , inherited7__its_machine_functions , inherited8__overcut_length , approach,retract, ):
		milling_machining_operation.__init__(self , inherited0__its_toolpath , inherited1__its_tool_direction , inherited2__its_id , inherited3__retract_plane , inherited4__start_point , inherited5__its_tool , inherited6__its_technology , inherited7__its_machine_functions , inherited8__overcut_length , )
		self._approach = approach
		self._retract = retract

	@property
	def approach(self):
		return self._approach
	@approach.setter
	def approach(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,approach_retract_strategy):
				self._approach = approach_retract_strategy(value)
			else:
				self._approach = value
		else:
			self._approach = value

	@property
	def retract(self):
		return self._retract
	@retract.setter
	def retract(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,approach_retract_strategy):
				self._retract = approach_retract_strategy(value)
			else:
				self._retract = value
		else:
			self._retract = value

####################
 # ENTITY two5d_milling_operation #
####################
class two5d_milling_operation(milling_type_operation):
	'''Entity two5d_milling_operation definition.

	:param its_machining_strategy
	:type its_machining_strategy:two5d_milling_strategy
	'''
	def __init__( self , inherited0__its_toolpath , inherited1__its_tool_direction , inherited2__its_id , inherited3__retract_plane , inherited4__start_point , inherited5__its_tool , inherited6__its_technology , inherited7__its_machine_functions , inherited8__overcut_length , inherited9__approach , inherited10__retract , its_machining_strategy, ):
		milling_type_operation.__init__(self , inherited0__its_toolpath , inherited1__its_tool_direction , inherited2__its_id , inherited3__retract_plane , inherited4__start_point , inherited5__its_tool , inherited6__its_technology , inherited7__its_machine_functions , inherited8__overcut_length , inherited9__approach , inherited10__retract , )
		self._its_machining_strategy = its_machining_strategy

	@property
	def its_machining_strategy(self):
		return self._its_machining_strategy
	@its_machining_strategy.setter
	def its_machining_strategy(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,two5d_milling_strategy):
				self._its_machining_strategy = two5d_milling_strategy(value)
			else:
				self._its_machining_strategy = value
		else:
			self._its_machining_strategy = value

####################
 # ENTITY bottom_and_side_milling #
####################
class bottom_and_side_milling(two5d_milling_operation):
	'''Entity bottom_and_side_milling definition.

	:param axial_cutting_depth
	:type axial_cutting_depth:length_measure

	:param radial_cutting_depth
	:type radial_cutting_depth:length_measure

	:param allowance_side
	:type allowance_side:length_measure

	:param allowance_bottom
	:type allowance_bottom:length_measure
	'''
	def __init__( self , inherited0__its_toolpath , inherited1__its_tool_direction , inherited2__its_id , inherited3__retract_plane , inherited4__start_point , inherited5__its_tool , inherited6__its_technology , inherited7__its_machine_functions , inherited8__overcut_length , inherited9__approach , inherited10__retract , inherited11__its_machining_strategy , axial_cutting_depth,radial_cutting_depth,allowance_side,allowance_bottom, ):
		two5d_milling_operation.__init__(self , inherited0__its_toolpath , inherited1__its_tool_direction , inherited2__its_id , inherited3__retract_plane , inherited4__start_point , inherited5__its_tool , inherited6__its_technology , inherited7__its_machine_functions , inherited8__overcut_length , inherited9__approach , inherited10__retract , inherited11__its_machining_strategy , )
		self._axial_cutting_depth = axial_cutting_depth
		self._radial_cutting_depth = radial_cutting_depth
		self._allowance_side = allowance_side
		self._allowance_bottom = allowance_bottom

	@property
	def axial_cutting_depth(self):
		return self._axial_cutting_depth
	@axial_cutting_depth.setter
	def axial_cutting_depth(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,length_measure):
				self._axial_cutting_depth = length_measure(value)
			else:
				self._axial_cutting_depth = value
		else:
			self._axial_cutting_depth = value

	@property
	def radial_cutting_depth(self):
		return self._radial_cutting_depth
	@radial_cutting_depth.setter
	def radial_cutting_depth(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,length_measure):
				self._radial_cutting_depth = length_measure(value)
			else:
				self._radial_cutting_depth = value
		else:
			self._radial_cutting_depth = value

	@property
	def allowance_side(self):
		return self._allowance_side
	@allowance_side.setter
	def allowance_side(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,length_measure):
				self._allowance_side = length_measure(value)
			else:
				self._allowance_side = value
		else:
			self._allowance_side = value

	@property
	def allowance_bottom(self):
		return self._allowance_bottom
	@allowance_bottom.setter
	def allowance_bottom(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,length_measure):
				self._allowance_bottom = length_measure(value)
			else:
				self._allowance_bottom = value
		else:
			self._allowance_bottom = value

####################
 # ENTITY nc_constant #
####################
class nc_constant(BaseEntityClass):
	'''Entity nc_constant definition.

	:param its_name
	:type its_name:label

	:param its_value
	:type its_value:(null)
	'''
	def __init__( self , its_name,its_value, ):
		self._its_name = its_name
		self._its_value = its_value

	@property
	def its_name(self):
		return self._its_name
	@its_name.setter
	def its_name(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,label):
			self._its_name = label(value)
		else:
			self._its_name = value

	@property
	def its_value(self):
		return self._its_value
	@its_value.setter
	def its_value(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,(null)):
				self._its_value = (null)(value)
			else:
				self._its_value = value
		else:
			self._its_value = value

####################
 # ENTITY general_property #
####################
class general_property(BaseEntityClass):
	'''Entity general_property definition.

	:param description
	:type description:label

	:param owner
	:type owner:general_property_item

	:param related_properties
	:type related_properties:SET(0,None,'general_property', scope = schema_scope)

	:param specifications
	:type specifications:SET(0,None,'specification', scope = schema_scope)
	'''
	def __init__( self , description,owner,related_properties,specifications, ):
		self._description = description
		self._owner = owner
		self._related_properties = related_properties
		self._specifications = specifications

	@property
	def description(self):
		return self._description
	@description.setter
	def description(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,label):
			self._description = label(value)
		else:
			self._description = value

	@property
	def owner(self):
		return self._owner
	@owner.setter
	def owner(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,general_property_item):
			self._owner = general_property_item(value)
		else:
			self._owner = value

	@property
	def related_properties(self):
		return self._related_properties
	@related_properties.setter
	def related_properties(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(0,None,'general_property', scope = schema_scope)):
			self._related_properties = SET(value)
		else:
			self._related_properties = value

	@property
	def specifications(self):
		return self._specifications
	@specifications.setter
	def specifications(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(0,None,'specification', scope = schema_scope)):
			self._specifications = SET(value)
		else:
			self._specifications = value

####################
 # ENTITY material_property #
####################
class material_property(general_property):
	'''Entity material_property definition.

	:param material_characteristics
	:type material_characteristics:SET(0,None,'property_parameter', scope = schema_scope)

	:param material_hardness
	:type material_hardness:SET(0,None,'hardness', scope = schema_scope)
	'''
	def __init__( self , inherited0__description , inherited1__owner , inherited2__related_properties , inherited3__specifications , material_characteristics,material_hardness, ):
		general_property.__init__(self , inherited0__description , inherited1__owner , inherited2__related_properties , inherited3__specifications , )
		self._material_characteristics = material_characteristics
		self._material_hardness = material_hardness

	@property
	def material_characteristics(self):
		return self._material_characteristics
	@material_characteristics.setter
	def material_characteristics(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(0,None,'property_parameter', scope = schema_scope)):
			self._material_characteristics = SET(value)
		else:
			self._material_characteristics = value

	@property
	def material_hardness(self):
		return self._material_hardness
	@material_hardness.setter
	def material_hardness(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(0,None,'hardness', scope = schema_scope)):
			self._material_hardness = SET(value)
		else:
			self._material_hardness = value

####################
 # ENTITY in_process_geometry #
####################
class in_process_geometry(BaseEntityClass):
	'''Entity in_process_geometry definition.

	:param as_is
	:type as_is:shape_representation

	:param to_be
	:type to_be:shape_representation

	:param removal
	:type removal:shape_representation
	'''
	def __init__( self , as_is,to_be,removal, ):
		self._as_is = as_is
		self._to_be = to_be
		self._removal = removal

	@property
	def as_is(self):
		return self._as_is
	@as_is.setter
	def as_is(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,shape_representation):
				self._as_is = shape_representation(value)
			else:
				self._as_is = value
		else:
			self._as_is = value

	@property
	def to_be(self):
		return self._to_be
	@to_be.setter
	def to_be(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,shape_representation):
				self._to_be = shape_representation(value)
			else:
				self._to_be = value
		else:
			self._to_be = value

	@property
	def removal(self):
		return self._removal
	@removal.setter
	def removal(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,shape_representation):
				self._removal = shape_representation(value)
			else:
				self._removal = value
		else:
			self._removal = value
	def wr1(self):
		eval_wr1_wr = ((EXISTS(self.as_is)  or  EXISTS(self.to_be))  or  EXISTS(self.removal))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY milling_machine_cutting_tool #
####################
class milling_machine_cutting_tool(machining_tool):
	'''Entity milling_machine_cutting_tool definition.

	:param its_cutting_edges
	:type its_cutting_edges:SET(1,None,'cutting_component', scope = schema_scope)

	:param overall_assembly_length
	:type overall_assembly_length:length_measure

	:param effective_cutting_diameter
	:type effective_cutting_diameter:length_measure

	:param maximum_depth_of_cut
	:type maximum_depth_of_cut:length_measure

	:param hand_of_cut
	:type hand_of_cut:hand_of_cut_type

	:param coolant_through_tool
	:type coolant_through_tool:BOOLEAN
	'''
	def __init__( self , inherited0__its_id , inherited1__its_usage , its_cutting_edges,overall_assembly_length,effective_cutting_diameter,maximum_depth_of_cut,hand_of_cut,coolant_through_tool, ):
		machining_tool.__init__(self , inherited0__its_id , inherited1__its_usage , )
		self._its_cutting_edges = its_cutting_edges
		self._overall_assembly_length = overall_assembly_length
		self._effective_cutting_diameter = effective_cutting_diameter
		self._maximum_depth_of_cut = maximum_depth_of_cut
		self._hand_of_cut = hand_of_cut
		self._coolant_through_tool = coolant_through_tool

	@property
	def its_cutting_edges(self):
		return self._its_cutting_edges
	@its_cutting_edges.setter
	def its_cutting_edges(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(1,None,'cutting_component', scope = schema_scope)):
			self._its_cutting_edges = SET(value)
		else:
			self._its_cutting_edges = value

	@property
	def overall_assembly_length(self):
		return self._overall_assembly_length
	@overall_assembly_length.setter
	def overall_assembly_length(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,length_measure):
			self._overall_assembly_length = length_measure(value)
		else:
			self._overall_assembly_length = value

	@property
	def effective_cutting_diameter(self):
		return self._effective_cutting_diameter
	@effective_cutting_diameter.setter
	def effective_cutting_diameter(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,length_measure):
			self._effective_cutting_diameter = length_measure(value)
		else:
			self._effective_cutting_diameter = value

	@property
	def maximum_depth_of_cut(self):
		return self._maximum_depth_of_cut
	@maximum_depth_of_cut.setter
	def maximum_depth_of_cut(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,length_measure):
			self._maximum_depth_of_cut = length_measure(value)
		else:
			self._maximum_depth_of_cut = value

	@property
	def hand_of_cut(self):
		return self._hand_of_cut
	@hand_of_cut.setter
	def hand_of_cut(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,hand_of_cut_type):
				self._hand_of_cut = hand_of_cut_type(value)
			else:
				self._hand_of_cut = value
		else:
			self._hand_of_cut = value

	@property
	def coolant_through_tool(self):
		return self._coolant_through_tool
	@coolant_through_tool.setter
	def coolant_through_tool(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,BOOLEAN):
				self._coolant_through_tool = BOOLEAN(value)
			else:
				self._coolant_through_tool = value
		else:
			self._coolant_through_tool = value

####################
 # ENTITY user_defined_milling_tool #
####################
class user_defined_milling_tool(milling_machine_cutting_tool):
	'''Entity user_defined_milling_tool definition.

	:param corner_radius
	:type corner_radius:length_measure

	:param corner_radius_center_horizontal
	:type corner_radius_center_horizontal:length_measure

	:param corner_radius_center_vertical
	:type corner_radius_center_vertical:length_measure

	:param description
	:type description:text

	:param taper_angle
	:type taper_angle:plane_angle_measure

	:param tip_outer_angle
	:type tip_outer_angle:plane_angle_measure
	'''
	def __init__( self , inherited0__its_id , inherited1__its_usage , inherited2__its_cutting_edges , inherited3__overall_assembly_length , inherited4__effective_cutting_diameter , inherited5__maximum_depth_of_cut , inherited6__hand_of_cut , inherited7__coolant_through_tool , corner_radius,corner_radius_center_horizontal,corner_radius_center_vertical,description,taper_angle,tip_outer_angle, ):
		milling_machine_cutting_tool.__init__(self , inherited0__its_id , inherited1__its_usage , inherited2__its_cutting_edges , inherited3__overall_assembly_length , inherited4__effective_cutting_diameter , inherited5__maximum_depth_of_cut , inherited6__hand_of_cut , inherited7__coolant_through_tool , )
		self._corner_radius = corner_radius
		self._corner_radius_center_horizontal = corner_radius_center_horizontal
		self._corner_radius_center_vertical = corner_radius_center_vertical
		self._description = description
		self._taper_angle = taper_angle
		self._tip_outer_angle = tip_outer_angle

	@property
	def corner_radius(self):
		return self._corner_radius
	@corner_radius.setter
	def corner_radius(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,length_measure):
				self._corner_radius = length_measure(value)
			else:
				self._corner_radius = value
		else:
			self._corner_radius = value

	@property
	def corner_radius_center_horizontal(self):
		return self._corner_radius_center_horizontal
	@corner_radius_center_horizontal.setter
	def corner_radius_center_horizontal(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,length_measure):
				self._corner_radius_center_horizontal = length_measure(value)
			else:
				self._corner_radius_center_horizontal = value
		else:
			self._corner_radius_center_horizontal = value

	@property
	def corner_radius_center_vertical(self):
		return self._corner_radius_center_vertical
	@corner_radius_center_vertical.setter
	def corner_radius_center_vertical(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,length_measure):
				self._corner_radius_center_vertical = length_measure(value)
			else:
				self._corner_radius_center_vertical = value
		else:
			self._corner_radius_center_vertical = value

	@property
	def description(self):
		return self._description
	@description.setter
	def description(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,text):
				self._description = text(value)
			else:
				self._description = value
		else:
			self._description = value

	@property
	def taper_angle(self):
		return self._taper_angle
	@taper_angle.setter
	def taper_angle(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,plane_angle_measure):
				self._taper_angle = plane_angle_measure(value)
			else:
				self._taper_angle = value
		else:
			self._taper_angle = value

	@property
	def tip_outer_angle(self):
		return self._tip_outer_angle
	@tip_outer_angle.setter
	def tip_outer_angle(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,plane_angle_measure):
				self._tip_outer_angle = plane_angle_measure(value)
			else:
				self._tip_outer_angle = value
		else:
			self._tip_outer_angle = value

####################
 # ENTITY geometric_tolerance #
####################
class geometric_tolerance(BaseEntityClass):
	'''Entity geometric_tolerance definition.

	:param name
	:type name:STRING

	:param applied_to
	:type applied_to:shape_element

	:param modification
	:type modification:tolerance_condition

	:param qualifying_note
	:type qualifying_note:STRING

	:param segment_size
	:type segment_size:value_with_unit

	:param significant_digits
	:type significant_digits:INTEGER

	:param tolerance_value
	:type tolerance_value:value_with_unit
	'''
	def __init__( self , name,applied_to,modification,qualifying_note,segment_size,significant_digits,tolerance_value, ):
		self._name = name
		self._applied_to = applied_to
		self._modification = modification
		self._qualifying_note = qualifying_note
		self._segment_size = segment_size
		self._significant_digits = significant_digits
		self._tolerance_value = tolerance_value

	@property
	def name(self):
		return self._name
	@name.setter
	def name(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,STRING):
				self._name = STRING(value)
			else:
				self._name = value
		else:
			self._name = value

	@property
	def applied_to(self):
		return self._applied_to
	@applied_to.setter
	def applied_to(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,shape_element):
			self._applied_to = shape_element(value)
		else:
			self._applied_to = value

	@property
	def modification(self):
		return self._modification
	@modification.setter
	def modification(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,tolerance_condition):
				self._modification = tolerance_condition(value)
			else:
				self._modification = value
		else:
			self._modification = value

	@property
	def qualifying_note(self):
		return self._qualifying_note
	@qualifying_note.setter
	def qualifying_note(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,STRING):
				self._qualifying_note = STRING(value)
			else:
				self._qualifying_note = value
		else:
			self._qualifying_note = value

	@property
	def segment_size(self):
		return self._segment_size
	@segment_size.setter
	def segment_size(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,value_with_unit):
				self._segment_size = value_with_unit(value)
			else:
				self._segment_size = value
		else:
			self._segment_size = value

	@property
	def significant_digits(self):
		return self._significant_digits
	@significant_digits.setter
	def significant_digits(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,INTEGER):
				self._significant_digits = INTEGER(value)
			else:
				self._significant_digits = value
		else:
			self._significant_digits = value

	@property
	def tolerance_value(self):
		return self._tolerance_value
	@tolerance_value.setter
	def tolerance_value(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,value_with_unit):
			self._tolerance_value = value_with_unit(value)
		else:
			self._tolerance_value = value
	def wr1(self):
		eval_wr1_wr = (( not EXISTS(self.segment_size))  or  ('AP238_ARM_SCHEMA.LENGTH_MEASURE'  ==  TYPEOF(self.segment_size.self.value_component)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (( not EXISTS(self.tolerance_value))  or  ('AP238_ARM_SCHEMA.LENGTH_MEASURE'  ==  TYPEOF(self.tolerance_value.self.value_component)))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (( not EXISTS(self.significant_digits))  or  (self.significant_digits  >  0))
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr


####################
 # ENTITY cylindricity_tolerance #
####################
class cylindricity_tolerance(geometric_tolerance):
	'''Entity cylindricity_tolerance definition.
	'''
	def __init__( self , inherited0__name , inherited1__applied_to , inherited2__modification , inherited3__qualifying_note , inherited4__segment_size , inherited5__significant_digits , inherited6__tolerance_value ,  ):
		geometric_tolerance.__init__(self , inherited0__name , inherited1__applied_to , inherited2__modification , inherited3__qualifying_note , inherited4__segment_size , inherited5__significant_digits , inherited6__tolerance_value , )

####################
 # ENTITY flatness_tolerance #
####################
class flatness_tolerance(geometric_tolerance):
	'''Entity flatness_tolerance definition.
	'''
	def __init__( self , inherited0__name , inherited1__applied_to , inherited2__modification , inherited3__qualifying_note , inherited4__segment_size , inherited5__significant_digits , inherited6__tolerance_value ,  ):
		geometric_tolerance.__init__(self , inherited0__name , inherited1__applied_to , inherited2__modification , inherited3__qualifying_note , inherited4__segment_size , inherited5__significant_digits , inherited6__tolerance_value , )

####################
 # ENTITY hardness #
####################
class hardness(BaseEntityClass):
	'''Entity hardness definition.

	:param scale
	:type scale:label

	:param nominal
	:type nominal:value_with_unit

	:param high_value
	:type high_value:value_with_unit

	:param low_value
	:type low_value:value_with_unit
	'''
	def __init__( self , scale,nominal,high_value,low_value, ):
		self._scale = scale
		self._nominal = nominal
		self._high_value = high_value
		self._low_value = low_value

	@property
	def scale(self):
		return self._scale
	@scale.setter
	def scale(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,label):
			self._scale = label(value)
		else:
			self._scale = value

	@property
	def nominal(self):
		return self._nominal
	@nominal.setter
	def nominal(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,value_with_unit):
			self._nominal = value_with_unit(value)
		else:
			self._nominal = value

	@property
	def high_value(self):
		return self._high_value
	@high_value.setter
	def high_value(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,value_with_unit):
				self._high_value = value_with_unit(value)
			else:
				self._high_value = value
		else:
			self._high_value = value

	@property
	def low_value(self):
		return self._low_value
	@low_value.setter
	def low_value(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,value_with_unit):
				self._low_value = value_with_unit(value)
			else:
				self._low_value = value
		else:
			self._low_value = value

####################
 # ENTITY specification_usage_constraint #
####################
class specification_usage_constraint(BaseEntityClass):
	'''Entity specification_usage_constraint definition.

	:param element
	:type element:text

	:param class_id
	:type class_id:text
	'''
	def __init__( self , element,class_id, ):
		self._element = element
		self._class_id = class_id

	@property
	def element(self):
		return self._element
	@element.setter
	def element(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,text):
			self._element = text(value)
		else:
			self._element = value

	@property
	def class_id(self):
		return self._class_id
	@class_id.setter
	def class_id(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,text):
			self._class_id = text(value)
		else:
			self._class_id = value

####################
 # ENTITY hole_bottom_condition #
####################
class hole_bottom_condition(BaseEntityClass):
	'''Entity hole_bottom_condition definition.
	'''
	# This class does not define any attribute.
	pass

####################
 # ENTITY program_structure #
####################
class program_structure(executable):
	'''Entity program_structure definition.
	'''
	def __init__( self , inherited0__its_id ,  ):
		executable.__init__(self , inherited0__its_id , )

####################
 # ENTITY parallel #
####################
class parallel(program_structure):
	'''Entity parallel definition.

	:param branches
	:type branches:SET(2,None,'executable', scope = schema_scope)
	'''
	def __init__( self , inherited0__its_id , branches, ):
		program_structure.__init__(self , inherited0__its_id , )
		self._branches = branches

	@property
	def branches(self):
		return self._branches
	@branches.setter
	def branches(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(2,None,'executable', scope = schema_scope)):
			self._branches = SET(value)
		else:
			self._branches = value

####################
 # ENTITY manufacturing_feature #
####################
class manufacturing_feature(BaseEntityClass):
	'''Entity manufacturing_feature definition.

	:param its_id
	:type its_id:identifier

	:param its_workpiece
	:type its_workpiece:workpiece

	:param its_operations
	:type its_operations:SET(0,None,'machining_operation', scope = schema_scope)

	:param explicit_representation
	:type explicit_representation:SET(1,None,'STRING', scope = schema_scope)
	'''
	def __init__( self , its_id,its_workpiece,its_operations,explicit_representation, ):
		self._its_id = its_id
		self._its_workpiece = its_workpiece
		self._its_operations = its_operations
		self._explicit_representation = explicit_representation

	@property
	def its_id(self):
		return self._its_id
	@its_id.setter
	def its_id(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,identifier):
			self._its_id = identifier(value)
		else:
			self._its_id = value

	@property
	def its_workpiece(self):
		return self._its_workpiece
	@its_workpiece.setter
	def its_workpiece(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,workpiece):
			self._its_workpiece = workpiece(value)
		else:
			self._its_workpiece = value

	@property
	def its_operations(self):
		return self._its_operations
	@its_operations.setter
	def its_operations(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(0,None,'machining_operation', scope = schema_scope)):
			self._its_operations = SET(value)
		else:
			self._its_operations = value

	@property
	def explicit_representation(self):
		return self._explicit_representation
	@explicit_representation.setter
	def explicit_representation(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,SET(1,None,'STRING', scope = schema_scope)):
				self._explicit_representation = SET(value)
			else:
				self._explicit_representation = value
		else:
			self._explicit_representation = value

####################
 # ENTITY two5d_manufacturing_feature #
####################
class two5d_manufacturing_feature(manufacturing_feature):
	'''Entity two5d_manufacturing_feature definition.

	:param feature_placement
	:type feature_placement:axis2_placement_3d
	'''
	def __init__( self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , feature_placement, ):
		manufacturing_feature.__init__(self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , )
		self._feature_placement = feature_placement

	@property
	def feature_placement(self):
		return self._feature_placement
	@feature_placement.setter
	def feature_placement(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,axis2_placement_3d):
			self._feature_placement = axis2_placement_3d(value)
		else:
			self._feature_placement = value

####################
 # ENTITY turning_feature #
####################
class turning_feature(two5d_manufacturing_feature):
	'''Entity turning_feature definition.
	'''
	def __init__( self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement ,  ):
		two5d_manufacturing_feature.__init__(self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , )

####################
 # ENTITY knurl #
####################
class knurl(turning_feature):
	'''Entity knurl definition.

	:param base_feature
	:type base_feature:turning_feature

	:param partial_profile
	:type partial_profile:partial_area_definition

	:param tooth_depth
	:type tooth_depth:toleranced_length_measure

	:param diametral_pitch
	:type diametral_pitch:toleranced_length_measure

	:param root_fillet
	:type root_fillet:toleranced_length_measure

	:param number_of_teeth
	:type number_of_teeth:INTEGER

	:param major_diameter
	:type major_diameter:toleranced_length_measure

	:param nominal_diameter
	:type nominal_diameter:toleranced_length_measure
	'''
	def __init__( self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , base_feature,partial_profile,tooth_depth,diametral_pitch,root_fillet,number_of_teeth,major_diameter,nominal_diameter, ):
		turning_feature.__init__(self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , )
		self._base_feature = base_feature
		self._partial_profile = partial_profile
		self._tooth_depth = tooth_depth
		self._diametral_pitch = diametral_pitch
		self._root_fillet = root_fillet
		self._number_of_teeth = number_of_teeth
		self._major_diameter = major_diameter
		self._nominal_diameter = nominal_diameter

	@property
	def base_feature(self):
		return self._base_feature
	@base_feature.setter
	def base_feature(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,turning_feature):
			self._base_feature = turning_feature(value)
		else:
			self._base_feature = value

	@property
	def partial_profile(self):
		return self._partial_profile
	@partial_profile.setter
	def partial_profile(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,partial_area_definition):
				self._partial_profile = partial_area_definition(value)
			else:
				self._partial_profile = value
		else:
			self._partial_profile = value

	@property
	def tooth_depth(self):
		return self._tooth_depth
	@tooth_depth.setter
	def tooth_depth(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,toleranced_length_measure):
				self._tooth_depth = toleranced_length_measure(value)
			else:
				self._tooth_depth = value
		else:
			self._tooth_depth = value

	@property
	def diametral_pitch(self):
		return self._diametral_pitch
	@diametral_pitch.setter
	def diametral_pitch(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,toleranced_length_measure):
				self._diametral_pitch = toleranced_length_measure(value)
			else:
				self._diametral_pitch = value
		else:
			self._diametral_pitch = value

	@property
	def root_fillet(self):
		return self._root_fillet
	@root_fillet.setter
	def root_fillet(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,toleranced_length_measure):
				self._root_fillet = toleranced_length_measure(value)
			else:
				self._root_fillet = value
		else:
			self._root_fillet = value

	@property
	def number_of_teeth(self):
		return self._number_of_teeth
	@number_of_teeth.setter
	def number_of_teeth(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,INTEGER):
				self._number_of_teeth = INTEGER(value)
			else:
				self._number_of_teeth = value
		else:
			self._number_of_teeth = value

	@property
	def major_diameter(self):
		return self._major_diameter
	@major_diameter.setter
	def major_diameter(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,toleranced_length_measure):
				self._major_diameter = toleranced_length_measure(value)
			else:
				self._major_diameter = value
		else:
			self._major_diameter = value

	@property
	def nominal_diameter(self):
		return self._nominal_diameter
	@nominal_diameter.setter
	def nominal_diameter(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,toleranced_length_measure):
				self._nominal_diameter = toleranced_length_measure(value)
			else:
				self._nominal_diameter = value
		else:
			self._nominal_diameter = value

####################
 # ENTITY diamond_knurl #
####################
class diamond_knurl(knurl):
	'''Entity diamond_knurl definition.

	:param helix1_angle
	:type helix1_angle:plane_angle_measure

	:param helix2_angle
	:type helix2_angle:plane_angle_measure
	'''
	def __init__( self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , inherited5__base_feature , inherited6__partial_profile , inherited7__tooth_depth , inherited8__diametral_pitch , inherited9__root_fillet , inherited10__number_of_teeth , inherited11__major_diameter , inherited12__nominal_diameter , helix1_angle,helix2_angle, ):
		knurl.__init__(self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , inherited5__base_feature , inherited6__partial_profile , inherited7__tooth_depth , inherited8__diametral_pitch , inherited9__root_fillet , inherited10__number_of_teeth , inherited11__major_diameter , inherited12__nominal_diameter , )
		self._helix1_angle = helix1_angle
		self._helix2_angle = helix2_angle

	@property
	def helix1_angle(self):
		return self._helix1_angle
	@helix1_angle.setter
	def helix1_angle(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,plane_angle_measure):
			self._helix1_angle = plane_angle_measure(value)
		else:
			self._helix1_angle = value

	@property
	def helix2_angle(self):
		return self._helix2_angle
	@helix2_angle.setter
	def helix2_angle(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,plane_angle_measure):
				self._helix2_angle = plane_angle_measure(value)
			else:
				self._helix2_angle = value
		else:
			self._helix2_angle = value

####################
 # ENTITY profile #
####################
class profile(BaseEntityClass):
	'''Entity profile definition.

	:param placement
	:type placement:axis2_placement_3d
	'''
	def __init__( self , placement, ):
		self._placement = placement

	@property
	def placement(self):
		return self._placement
	@placement.setter
	def placement(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,axis2_placement_3d):
				self._placement = axis2_placement_3d(value)
			else:
				self._placement = value
		else:
			self._placement = value

####################
 # ENTITY closed_profile #
####################
class closed_profile(profile):
	'''Entity closed_profile definition.
	'''
	def __init__( self , inherited0__placement ,  ):
		profile.__init__(self , inherited0__placement , )

####################
 # ENTITY circular_closed_profile #
####################
class circular_closed_profile(closed_profile):
	'''Entity circular_closed_profile definition.

	:param diameter
	:type diameter:toleranced_length_measure
	'''
	def __init__( self , inherited0__placement , diameter, ):
		closed_profile.__init__(self , inherited0__placement , )
		self._diameter = diameter

	@property
	def diameter(self):
		return self._diameter
	@diameter.setter
	def diameter(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,toleranced_length_measure):
			self._diameter = toleranced_length_measure(value)
		else:
			self._diameter = value

####################
 # ENTITY ngon_profile #
####################
class ngon_profile(closed_profile):
	'''Entity ngon_profile definition.

	:param diameter
	:type diameter:toleranced_length_measure

	:param number_of_sides
	:type number_of_sides:INTEGER

	:param circumscribed_or_across_flats
	:type circumscribed_or_across_flats:BOOLEAN
	'''
	def __init__( self , inherited0__placement , diameter,number_of_sides,circumscribed_or_across_flats, ):
		closed_profile.__init__(self , inherited0__placement , )
		self._diameter = diameter
		self._number_of_sides = number_of_sides
		self._circumscribed_or_across_flats = circumscribed_or_across_flats

	@property
	def diameter(self):
		return self._diameter
	@diameter.setter
	def diameter(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,toleranced_length_measure):
			self._diameter = toleranced_length_measure(value)
		else:
			self._diameter = value

	@property
	def number_of_sides(self):
		return self._number_of_sides
	@number_of_sides.setter
	def number_of_sides(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,INTEGER):
			self._number_of_sides = INTEGER(value)
		else:
			self._number_of_sides = value

	@property
	def circumscribed_or_across_flats(self):
		return self._circumscribed_or_across_flats
	@circumscribed_or_across_flats.setter
	def circumscribed_or_across_flats(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,BOOLEAN):
			self._circumscribed_or_across_flats = BOOLEAN(value)
		else:
			self._circumscribed_or_across_flats = value

####################
 # ENTITY size_dimension #
####################
class size_dimension(geometric_dimension):
	'''Entity size_dimension definition.

	:param applied_to
	:type applied_to:shape_element

	:param envelope_principle
	:type envelope_principle:BOOLEAN
	'''
	def __init__( self , inherited0__id , inherited1__dimension_value , inherited2__notes , applied_to,envelope_principle, ):
		geometric_dimension.__init__(self , inherited0__id , inherited1__dimension_value , inherited2__notes , )
		self._applied_to = applied_to
		self._envelope_principle = envelope_principle

	@property
	def applied_to(self):
		return self._applied_to
	@applied_to.setter
	def applied_to(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,shape_element):
			self._applied_to = shape_element(value)
		else:
			self._applied_to = value

	@property
	def envelope_principle(self):
		return self._envelope_principle
	@envelope_principle.setter
	def envelope_principle(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,BOOLEAN):
				self._envelope_principle = BOOLEAN(value)
			else:
				self._envelope_principle = value
		else:
			self._envelope_principle = value

####################
 # ENTITY width_size_dimension #
####################
class width_size_dimension(size_dimension):
	'''Entity width_size_dimension definition.

	:param used_path
	:type used_path:measurement_path
	'''
	def __init__( self , inherited0__id , inherited1__dimension_value , inherited2__notes , inherited3__applied_to , inherited4__envelope_principle , used_path, ):
		size_dimension.__init__(self , inherited0__id , inherited1__dimension_value , inherited2__notes , inherited3__applied_to , inherited4__envelope_principle , )
		self._used_path = used_path

	@property
	def used_path(self):
		return self._used_path
	@used_path.setter
	def used_path(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,measurement_path):
				self._used_path = measurement_path(value)
			else:
				self._used_path = value
		else:
			self._used_path = value

####################
 # ENTITY open_profile #
####################
class open_profile(profile):
	'''Entity open_profile definition.
	'''
	def __init__( self , inherited0__placement ,  ):
		profile.__init__(self , inherited0__placement , )

####################
 # ENTITY drilling_operation #
####################
class drilling_operation(drilling_type_operation):
	'''Entity drilling_operation definition.
	'''
	def __init__( self , inherited0__its_toolpath , inherited1__its_tool_direction , inherited2__its_id , inherited3__retract_plane , inherited4__start_point , inherited5__its_tool , inherited6__its_technology , inherited7__its_machine_functions , inherited8__overcut_length , inherited9__cutting_depth , inherited10__previous_diameter , inherited11__dwell_time_bottom , inherited12__feed_on_retract , inherited13__its_machining_strategy ,  ):
		drilling_type_operation.__init__(self , inherited0__its_toolpath , inherited1__its_tool_direction , inherited2__its_id , inherited3__retract_plane , inherited4__start_point , inherited5__its_tool , inherited6__its_technology , inherited7__its_machine_functions , inherited8__overcut_length , inherited9__cutting_depth , inherited10__previous_diameter , inherited11__dwell_time_bottom , inherited12__feed_on_retract , inherited13__its_machining_strategy , )

####################
 # ENTITY center_drilling #
####################
class center_drilling(drilling_operation):
	'''Entity center_drilling definition.
	'''
	def __init__( self , inherited0__its_toolpath , inherited1__its_tool_direction , inherited2__its_id , inherited3__retract_plane , inherited4__start_point , inherited5__its_tool , inherited6__its_technology , inherited7__its_machine_functions , inherited8__overcut_length , inherited9__cutting_depth , inherited10__previous_diameter , inherited11__dwell_time_bottom , inherited12__feed_on_retract , inherited13__its_machining_strategy ,  ):
		drilling_operation.__init__(self , inherited0__its_toolpath , inherited1__its_tool_direction , inherited2__its_id , inherited3__retract_plane , inherited4__start_point , inherited5__its_tool , inherited6__its_technology , inherited7__its_machine_functions , inherited8__overcut_length , inherited9__cutting_depth , inherited10__previous_diameter , inherited11__dwell_time_bottom , inherited12__feed_on_retract , inherited13__its_machining_strategy , )

####################
 # ENTITY travel_path #
####################
class travel_path(BaseEntityClass):
	'''Entity travel_path definition.

	:param placement
	:type placement:axis2_placement_3d
	'''
	def __init__( self , placement, ):
		self._placement = placement

	@property
	def placement(self):
		return self._placement
	@placement.setter
	def placement(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,axis2_placement_3d):
				self._placement = axis2_placement_3d(value)
			else:
				self._placement = value
		else:
			self._placement = value

####################
 # ENTITY tool_direction #
####################
class tool_direction(BaseEntityClass):
	'''Entity tool_direction definition.
	'''
	# This class does not define any attribute.
	pass

####################
 # ENTITY tapping #
####################
class tapping(drilling_type_operation):
	'''Entity tapping definition.

	:param compensation_chuck
	:type compensation_chuck:BOOLEAN
	'''
	def __init__( self , inherited0__its_toolpath , inherited1__its_tool_direction , inherited2__its_id , inherited3__retract_plane , inherited4__start_point , inherited5__its_tool , inherited6__its_technology , inherited7__its_machine_functions , inherited8__overcut_length , inherited9__cutting_depth , inherited10__previous_diameter , inherited11__dwell_time_bottom , inherited12__feed_on_retract , inherited13__its_machining_strategy , compensation_chuck, ):
		drilling_type_operation.__init__(self , inherited0__its_toolpath , inherited1__its_tool_direction , inherited2__its_id , inherited3__retract_plane , inherited4__start_point , inherited5__its_tool , inherited6__its_technology , inherited7__its_machine_functions , inherited8__overcut_length , inherited9__cutting_depth , inherited10__previous_diameter , inherited11__dwell_time_bottom , inherited12__feed_on_retract , inherited13__its_machining_strategy , )
		self._compensation_chuck = compensation_chuck

	@property
	def compensation_chuck(self):
		return self._compensation_chuck
	@compensation_chuck.setter
	def compensation_chuck(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,BOOLEAN):
			self._compensation_chuck = BOOLEAN(value)
		else:
			self._compensation_chuck = value

####################
 # ENTITY machining_feature #
####################
class machining_feature(two5d_manufacturing_feature):
	'''Entity machining_feature definition.

	:param depth
	:type depth:elementary_surface
	'''
	def __init__( self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , depth, ):
		two5d_manufacturing_feature.__init__(self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , )
		self._depth = depth

	@property
	def depth(self):
		return self._depth
	@depth.setter
	def depth(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,elementary_surface):
				self._depth = elementary_surface(value)
			else:
				self._depth = value
		else:
			self._depth = value

####################
 # ENTITY profile_feature #
####################
class profile_feature(machining_feature):
	'''Entity profile_feature definition.

	:param profile_swept_shape
	:type profile_swept_shape:linear_path
	'''
	def __init__( self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , inherited5__depth , profile_swept_shape, ):
		machining_feature.__init__(self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , inherited5__depth , )
		self._profile_swept_shape = profile_swept_shape

	@property
	def profile_swept_shape(self):
		return self._profile_swept_shape
	@profile_swept_shape.setter
	def profile_swept_shape(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,linear_path):
			self._profile_swept_shape = linear_path(value)
		else:
			self._profile_swept_shape = value

####################
 # ENTITY value_with_unit #
####################
class value_with_unit(BaseEntityClass):
	'''Entity value_with_unit definition.

	:param unit
	:type unit:STRING

	:param value_component
	:type value_component:(null)
	'''
	def __init__( self , unit,value_component, ):
		self._unit = unit
		self._value_component = value_component

	@property
	def unit(self):
		return self._unit
	@unit.setter
	def unit(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,STRING):
			self._unit = STRING(value)
		else:
			self._unit = value

	@property
	def value_component(self):
		return self._value_component
	@value_component.setter
	def value_component(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,(null)):
			self._value_component = (null)(value)
		else:
			self._value_component = value

####################
 # ENTITY value_with_tolerance #
####################
class value_with_tolerance(value_with_unit):
	'''Entity value_with_tolerance definition.

	:param limitation
	:type limitation:limitation_select

	:param significant_digits
	:type significant_digits:INTEGER
	'''
	def __init__( self , inherited0__unit , inherited1__value_component , limitation,significant_digits, ):
		value_with_unit.__init__(self , inherited0__unit , inherited1__value_component , )
		self._limitation = limitation
		self._significant_digits = significant_digits

	@property
	def limitation(self):
		return self._limitation
	@limitation.setter
	def limitation(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,limitation_select):
				self._limitation = limitation_select(value)
			else:
				self._limitation = value
		else:
			self._limitation = value

	@property
	def significant_digits(self):
		return self._significant_digits
	@significant_digits.setter
	def significant_digits(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,INTEGER):
				self._significant_digits = INTEGER(value)
			else:
				self._significant_digits = value
		else:
			self._significant_digits = value

####################
 # ENTITY volume_measure #
####################
class volume_measure(value_with_tolerance):
	'''Entity volume_measure definition.
	'''
	def __init__( self , inherited0__unit , inherited1__value_component , inherited2__limitation , inherited3__significant_digits ,  ):
		value_with_tolerance.__init__(self , inherited0__unit , inherited1__value_component , inherited2__limitation , inherited3__significant_digits , )

####################
 # ENTITY machined_surface #
####################
class machined_surface(BaseEntityClass):
	'''Entity machined_surface definition.

	:param its_machining_feature
	:type its_machining_feature:machining_feature

	:param surface_element
	:type surface_element:bottom_or_side
	'''
	def __init__( self , its_machining_feature,surface_element, ):
		self._its_machining_feature = its_machining_feature
		self._surface_element = surface_element

	@property
	def its_machining_feature(self):
		return self._its_machining_feature
	@its_machining_feature.setter
	def its_machining_feature(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,machining_feature):
			self._its_machining_feature = machining_feature(value)
		else:
			self._its_machining_feature = value

	@property
	def surface_element(self):
		return self._surface_element
	@surface_element.setter
	def surface_element(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,bottom_or_side):
			self._surface_element = bottom_or_side(value)
		else:
			self._surface_element = value

####################
 # ENTITY value_range #
####################
class value_range(BaseEntityClass):
	'''Entity value_range definition.

	:param lower_range
	:type lower_range:value_with_unit

	:param upper_range
	:type upper_range:value_with_unit

	:param significant_digits
	:type significant_digits:INTEGER
	'''
	def __init__( self , lower_range,upper_range,significant_digits, ):
		self._lower_range = lower_range
		self._upper_range = upper_range
		self._significant_digits = significant_digits

	@property
	def lower_range(self):
		return self._lower_range
	@lower_range.setter
	def lower_range(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,value_with_unit):
			self._lower_range = value_with_unit(value)
		else:
			self._lower_range = value

	@property
	def upper_range(self):
		return self._upper_range
	@upper_range.setter
	def upper_range(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,value_with_unit):
			self._upper_range = value_with_unit(value)
		else:
			self._upper_range = value

	@property
	def significant_digits(self):
		return self._significant_digits
	@significant_digits.setter
	def significant_digits(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,INTEGER):
				self._significant_digits = INTEGER(value)
			else:
				self._significant_digits = value
		else:
			self._significant_digits = value

####################
 # ENTITY shape_profile #
####################
class shape_profile(profile_feature):
	'''Entity shape_profile definition.

	:param floor_condition
	:type floor_condition:profile_select

	:param removal_direction
	:type removal_direction:direction
	'''
	def __init__( self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , inherited5__depth , inherited6__profile_swept_shape , floor_condition,removal_direction, ):
		profile_feature.__init__(self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , inherited5__depth , inherited6__profile_swept_shape , )
		self._floor_condition = floor_condition
		self._removal_direction = removal_direction

	@property
	def floor_condition(self):
		return self._floor_condition
	@floor_condition.setter
	def floor_condition(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,profile_select):
			self._floor_condition = profile_select(value)
		else:
			self._floor_condition = value

	@property
	def removal_direction(self):
		return self._removal_direction
	@removal_direction.setter
	def removal_direction(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,direction):
			self._removal_direction = direction(value)
		else:
			self._removal_direction = value

####################
 # ENTITY partial_circular_shape_profile #
####################
class partial_circular_shape_profile(shape_profile):
	'''Entity partial_circular_shape_profile definition.

	:param open_boundary
	:type open_boundary:partial_circular_profile
	'''
	def __init__( self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , inherited5__depth , inherited6__profile_swept_shape , inherited7__floor_condition , inherited8__removal_direction , open_boundary, ):
		shape_profile.__init__(self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , inherited5__depth , inherited6__profile_swept_shape , inherited7__floor_condition , inherited8__removal_direction , )
		self._open_boundary = open_boundary

	@property
	def open_boundary(self):
		return self._open_boundary
	@open_boundary.setter
	def open_boundary(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,partial_circular_profile):
			self._open_boundary = partial_circular_profile(value)
		else:
			self._open_boundary = value

####################
 # ENTITY technology #
####################
class technology(BaseEntityClass):
	'''Entity technology definition.

	:param feedrate
	:type feedrate:speed_measure

	:param feedrate_reference
	:type feedrate_reference:tool_reference_point
	'''
	def __init__( self , feedrate,feedrate_reference, ):
		self._feedrate = feedrate
		self._feedrate_reference = feedrate_reference

	@property
	def feedrate(self):
		return self._feedrate
	@feedrate.setter
	def feedrate(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,speed_measure):
				self._feedrate = speed_measure(value)
			else:
				self._feedrate = value
		else:
			self._feedrate = value

	@property
	def feedrate_reference(self):
		return self._feedrate_reference
	@feedrate_reference.setter
	def feedrate_reference(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,tool_reference_point):
			self._feedrate_reference = tool_reference_point(value)
		else:
			self._feedrate_reference = value

####################
 # ENTITY milling_technology #
####################
class milling_technology(technology):
	'''Entity milling_technology definition.

	:param cutspeed
	:type cutspeed:speed_measure

	:param spindle
	:type spindle:rot_speed_measure

	:param feedrate_per_tooth
	:type feedrate_per_tooth:length_measure

	:param synchronize_spindle_with_feed
	:type synchronize_spindle_with_feed:BOOLEAN

	:param inhibit_feedrate_override
	:type inhibit_feedrate_override:BOOLEAN

	:param inhibit_spindle_override
	:type inhibit_spindle_override:BOOLEAN

	:param its_adaptive_control
	:type its_adaptive_control:adaptive_control
	'''
	def __init__( self , inherited0__feedrate , inherited1__feedrate_reference , cutspeed,spindle,feedrate_per_tooth,synchronize_spindle_with_feed,inhibit_feedrate_override,inhibit_spindle_override,its_adaptive_control, ):
		technology.__init__(self , inherited0__feedrate , inherited1__feedrate_reference , )
		self._cutspeed = cutspeed
		self._spindle = spindle
		self._feedrate_per_tooth = feedrate_per_tooth
		self._synchronize_spindle_with_feed = synchronize_spindle_with_feed
		self._inhibit_feedrate_override = inhibit_feedrate_override
		self._inhibit_spindle_override = inhibit_spindle_override
		self._its_adaptive_control = its_adaptive_control

	@property
	def cutspeed(self):
		return self._cutspeed
	@cutspeed.setter
	def cutspeed(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,speed_measure):
				self._cutspeed = speed_measure(value)
			else:
				self._cutspeed = value
		else:
			self._cutspeed = value

	@property
	def spindle(self):
		return self._spindle
	@spindle.setter
	def spindle(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,rot_speed_measure):
				self._spindle = rot_speed_measure(value)
			else:
				self._spindle = value
		else:
			self._spindle = value

	@property
	def feedrate_per_tooth(self):
		return self._feedrate_per_tooth
	@feedrate_per_tooth.setter
	def feedrate_per_tooth(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,length_measure):
				self._feedrate_per_tooth = length_measure(value)
			else:
				self._feedrate_per_tooth = value
		else:
			self._feedrate_per_tooth = value

	@property
	def synchronize_spindle_with_feed(self):
		return self._synchronize_spindle_with_feed
	@synchronize_spindle_with_feed.setter
	def synchronize_spindle_with_feed(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,BOOLEAN):
			self._synchronize_spindle_with_feed = BOOLEAN(value)
		else:
			self._synchronize_spindle_with_feed = value

	@property
	def inhibit_feedrate_override(self):
		return self._inhibit_feedrate_override
	@inhibit_feedrate_override.setter
	def inhibit_feedrate_override(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,BOOLEAN):
			self._inhibit_feedrate_override = BOOLEAN(value)
		else:
			self._inhibit_feedrate_override = value

	@property
	def inhibit_spindle_override(self):
		return self._inhibit_spindle_override
	@inhibit_spindle_override.setter
	def inhibit_spindle_override(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,BOOLEAN):
			self._inhibit_spindle_override = BOOLEAN(value)
		else:
			self._inhibit_spindle_override = value

	@property
	def its_adaptive_control(self):
		return self._its_adaptive_control
	@its_adaptive_control.setter
	def its_adaptive_control(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,adaptive_control):
				self._its_adaptive_control = adaptive_control(value)
			else:
				self._its_adaptive_control = value
		else:
			self._its_adaptive_control = value
	def wr1(self):
		eval_wr1_wr = (((EXISTS(self.cutspeed)  and  ( not EXISTS(self.spindle)))  or  (EXISTS(self.spindle)  and  ( not EXISTS(self.cutspeed))))  or  EXISTS(self.its_adaptive_control))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (((EXISTS(self.self.feedrate)  and  ( not EXISTS(self.feedrate_per_tooth)))  or  (EXISTS(self.feedrate_per_tooth)  and  ( not EXISTS(self.self.feedrate))))  or  EXISTS(self.its_adaptive_control))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY replicate_feature #
####################
class replicate_feature(two5d_manufacturing_feature):
	'''Entity replicate_feature definition.

	:param replicate_base_feature
	:type replicate_base_feature:two5d_manufacturing_feature
	'''
	def __init__( self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , replicate_base_feature, ):
		two5d_manufacturing_feature.__init__(self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , )
		self._replicate_base_feature = replicate_base_feature

	@property
	def replicate_base_feature(self):
		return self._replicate_base_feature
	@replicate_base_feature.setter
	def replicate_base_feature(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,two5d_manufacturing_feature):
			self._replicate_base_feature = two5d_manufacturing_feature(value)
		else:
			self._replicate_base_feature = value

####################
 # ENTITY general_pattern #
####################
class general_pattern(replicate_feature):
	'''Entity general_pattern definition.

	:param replicate_locations
	:type replicate_locations:LIST(2,None,'STRING', scope = schema_scope)
	'''
	def __init__( self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , inherited5__replicate_base_feature , replicate_locations, ):
		replicate_feature.__init__(self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , inherited5__replicate_base_feature , )
		self._replicate_locations = replicate_locations

	@property
	def replicate_locations(self):
		return self._replicate_locations
	@replicate_locations.setter
	def replicate_locations(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,LIST(2,None,'STRING', scope = schema_scope)):
			self._replicate_locations = LIST(value)
		else:
			self._replicate_locations = value

####################
 # ENTITY datum #
####################
class datum(BaseEntityClass):
	'''Entity datum definition.
	'''
	# This class does not define any attribute.
	pass

####################
 # ENTITY single_datum #
####################
class single_datum(datum):
	'''Entity single_datum definition.

	:param datum_name
	:type datum_name:STRING

	:param modification
	:type modification:tolerance_condition
	'''
	def __init__( self , datum_name,modification, ):
		datum.__init__(self , )
		self._datum_name = datum_name
		self._modification = modification

	@property
	def datum_name(self):
		return self._datum_name
	@datum_name.setter
	def datum_name(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,STRING):
			self._datum_name = STRING(value)
		else:
			self._datum_name = value

	@property
	def modification(self):
		return self._modification
	@modification.setter
	def modification(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,tolerance_condition):
				self._modification = tolerance_condition(value)
			else:
				self._modification = value
		else:
			self._modification = value

####################
 # ENTITY datum_defined_by_feature #
####################
class datum_defined_by_feature(single_datum):
	'''Entity datum_defined_by_feature definition.

	:param defined_by
	:type defined_by:shape_element
	'''
	def __init__( self , inherited0__datum_name , inherited1__modification , defined_by, ):
		single_datum.__init__(self , inherited0__datum_name , inherited1__modification , )
		self._defined_by = defined_by

	@property
	def defined_by(self):
		return self._defined_by
	@defined_by.setter
	def defined_by(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,shape_element):
			self._defined_by = shape_element(value)
		else:
			self._defined_by = value

####################
 # ENTITY milling_cutting_tool #
####################
class milling_cutting_tool(milling_machine_cutting_tool):
	'''Entity milling_cutting_tool definition.

	:param number_of_effective_teeth
	:type number_of_effective_teeth:INTEGER

	:param edge_radius
	:type edge_radius:length_measure
	'''
	def __init__( self , inherited0__its_id , inherited1__its_usage , inherited2__its_cutting_edges , inherited3__overall_assembly_length , inherited4__effective_cutting_diameter , inherited5__maximum_depth_of_cut , inherited6__hand_of_cut , inherited7__coolant_through_tool , number_of_effective_teeth,edge_radius, ):
		milling_machine_cutting_tool.__init__(self , inherited0__its_id , inherited1__its_usage , inherited2__its_cutting_edges , inherited3__overall_assembly_length , inherited4__effective_cutting_diameter , inherited5__maximum_depth_of_cut , inherited6__hand_of_cut , inherited7__coolant_through_tool , )
		self._number_of_effective_teeth = number_of_effective_teeth
		self._edge_radius = edge_radius

	@property
	def number_of_effective_teeth(self):
		return self._number_of_effective_teeth
	@number_of_effective_teeth.setter
	def number_of_effective_teeth(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,INTEGER):
				self._number_of_effective_teeth = INTEGER(value)
			else:
				self._number_of_effective_teeth = value
		else:
			self._number_of_effective_teeth = value

	@property
	def edge_radius(self):
		return self._edge_radius
	@edge_radius.setter
	def edge_radius(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,length_measure):
				self._edge_radius = length_measure(value)
			else:
				self._edge_radius = value
		else:
			self._edge_radius = value

####################
 # ENTITY facemill #
####################
class facemill(milling_cutting_tool):
	'''Entity facemill definition.

	:param tool_cutting_edge_angle
	:type tool_cutting_edge_angle:plane_angle_measure
	'''
	def __init__( self , inherited0__its_id , inherited1__its_usage , inherited2__its_cutting_edges , inherited3__overall_assembly_length , inherited4__effective_cutting_diameter , inherited5__maximum_depth_of_cut , inherited6__hand_of_cut , inherited7__coolant_through_tool , inherited8__number_of_effective_teeth , inherited9__edge_radius , tool_cutting_edge_angle, ):
		milling_cutting_tool.__init__(self , inherited0__its_id , inherited1__its_usage , inherited2__its_cutting_edges , inherited3__overall_assembly_length , inherited4__effective_cutting_diameter , inherited5__maximum_depth_of_cut , inherited6__hand_of_cut , inherited7__coolant_through_tool , inherited8__number_of_effective_teeth , inherited9__edge_radius , )
		self._tool_cutting_edge_angle = tool_cutting_edge_angle

	@property
	def tool_cutting_edge_angle(self):
		return self._tool_cutting_edge_angle
	@tool_cutting_edge_angle.setter
	def tool_cutting_edge_angle(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,plane_angle_measure):
			self._tool_cutting_edge_angle = plane_angle_measure(value)
		else:
			self._tool_cutting_edge_angle = value

####################
 # ENTITY grooving_finish #
####################
class grooving_finish(grooving):
	'''Entity grooving_finish definition.
	'''
	def __init__( self , inherited0__its_toolpath , inherited1__its_tool_direction , inherited2__its_id , inherited3__retract_plane , inherited4__start_point , inherited5__its_tool , inherited6__its_technology , inherited7__its_machine_functions , inherited8__approach , inherited9__retract , inherited10__its_machining_strategy , inherited11__dwell , inherited12__allowance ,  ):
		grooving.__init__(self , inherited0__its_toolpath , inherited1__its_tool_direction , inherited2__its_id , inherited3__retract_plane , inherited4__start_point , inherited5__its_tool , inherited6__its_technology , inherited7__its_machine_functions , inherited8__approach , inherited9__retract , inherited10__its_machining_strategy , inherited11__dwell , inherited12__allowance , )

####################
 # ENTITY assigned_date #
####################
class assigned_date(BaseEntityClass):
	'''Entity assigned_date definition.

	:param date_value
	:type date_value:date

	:param role
	:type role:STRING
	'''
	def __init__( self , date_value,role, ):
		self._date_value = date_value
		self._role = role

	@property
	def date_value(self):
		return self._date_value
	@date_value.setter
	def date_value(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,date):
			self._date_value = date(value)
		else:
			self._date_value = value

	@property
	def role(self):
		return self._role
	@role.setter
	def role(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,STRING):
			self._role = STRING(value)
		else:
			self._role = value

####################
 # ENTITY assignment #
####################
class assignment(program_structure):
	'''Entity assignment definition.

	:param its_lvalue
	:type its_lvalue:nc_variable

	:param its_rvalue
	:type its_rvalue:rvalue
	'''
	def __init__( self , inherited0__its_id , its_lvalue,its_rvalue, ):
		program_structure.__init__(self , inherited0__its_id , )
		self._its_lvalue = its_lvalue
		self._its_rvalue = its_rvalue

	@property
	def its_lvalue(self):
		return self._its_lvalue
	@its_lvalue.setter
	def its_lvalue(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,nc_variable):
			self._its_lvalue = nc_variable(value)
		else:
			self._its_lvalue = value

	@property
	def its_rvalue(self):
		return self._its_rvalue
	@its_rvalue.setter
	def its_rvalue(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,rvalue):
			self._its_rvalue = rvalue(value)
		else:
			self._its_rvalue = value

####################
 # ENTITY side_milling #
####################
class side_milling(two5d_milling_operation):
	'''Entity side_milling definition.

	:param axial_cutting_depth
	:type axial_cutting_depth:length_measure

	:param radial_cutting_depth
	:type radial_cutting_depth:length_measure

	:param allowance_side
	:type allowance_side:length_measure
	'''
	def __init__( self , inherited0__its_toolpath , inherited1__its_tool_direction , inherited2__its_id , inherited3__retract_plane , inherited4__start_point , inherited5__its_tool , inherited6__its_technology , inherited7__its_machine_functions , inherited8__overcut_length , inherited9__approach , inherited10__retract , inherited11__its_machining_strategy , axial_cutting_depth,radial_cutting_depth,allowance_side, ):
		two5d_milling_operation.__init__(self , inherited0__its_toolpath , inherited1__its_tool_direction , inherited2__its_id , inherited3__retract_plane , inherited4__start_point , inherited5__its_tool , inherited6__its_technology , inherited7__its_machine_functions , inherited8__overcut_length , inherited9__approach , inherited10__retract , inherited11__its_machining_strategy , )
		self._axial_cutting_depth = axial_cutting_depth
		self._radial_cutting_depth = radial_cutting_depth
		self._allowance_side = allowance_side

	@property
	def axial_cutting_depth(self):
		return self._axial_cutting_depth
	@axial_cutting_depth.setter
	def axial_cutting_depth(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,length_measure):
				self._axial_cutting_depth = length_measure(value)
			else:
				self._axial_cutting_depth = value
		else:
			self._axial_cutting_depth = value

	@property
	def radial_cutting_depth(self):
		return self._radial_cutting_depth
	@radial_cutting_depth.setter
	def radial_cutting_depth(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,length_measure):
				self._radial_cutting_depth = length_measure(value)
			else:
				self._radial_cutting_depth = value
		else:
			self._radial_cutting_depth = value

	@property
	def allowance_side(self):
		return self._allowance_side
	@allowance_side.setter
	def allowance_side(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,length_measure):
				self._allowance_side = length_measure(value)
			else:
				self._allowance_side = value
		else:
			self._allowance_side = value

####################
 # ENTITY side_rough_milling #
####################
class side_rough_milling(side_milling):
	'''Entity side_rough_milling definition.
	'''
	def __init__( self , inherited0__its_toolpath , inherited1__its_tool_direction , inherited2__its_id , inherited3__retract_plane , inherited4__start_point , inherited5__its_tool , inherited6__its_technology , inherited7__its_machine_functions , inherited8__overcut_length , inherited9__approach , inherited10__retract , inherited11__its_machining_strategy , inherited12__axial_cutting_depth , inherited13__radial_cutting_depth , inherited14__allowance_side ,  ):
		side_milling.__init__(self , inherited0__its_toolpath , inherited1__its_tool_direction , inherited2__its_id , inherited3__retract_plane , inherited4__start_point , inherited5__its_tool , inherited6__its_technology , inherited7__its_machine_functions , inherited8__overcut_length , inherited9__approach , inherited10__retract , inherited11__its_machining_strategy , inherited12__axial_cutting_depth , inherited13__radial_cutting_depth , inherited14__allowance_side , )
	def wr1(self):
		eval_wr1_wr = (EXISTS(self.self.allowance_side)  and  (self.self.allowance_side  >=  0))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY curve_with_normal_vector #
####################
class curve_with_normal_vector(BaseEntityClass):
	'''Entity curve_with_normal_vector definition.

	:param basiccurve
	:type basiccurve:bounded_curve

	:param surface_normal
	:type surface_normal:bounded_curve
	'''
	def __init__( self , basiccurve,surface_normal, ):
		self._basiccurve = basiccurve
		self._surface_normal = surface_normal

	@property
	def basiccurve(self):
		return self._basiccurve
	@basiccurve.setter
	def basiccurve(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,bounded_curve):
			self._basiccurve = bounded_curve(value)
		else:
			self._basiccurve = value

	@property
	def surface_normal(self):
		return self._surface_normal
	@surface_normal.setter
	def surface_normal(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,bounded_curve):
			self._surface_normal = bounded_curve(value)
		else:
			self._surface_normal = value

####################
 # ENTITY freeform_operation #
####################
class freeform_operation(milling_type_operation):
	'''Entity freeform_operation definition.

	:param its_machining_strategy
	:type its_machining_strategy:freeform_strategy
	'''
	def __init__( self , inherited0__its_toolpath , inherited1__its_tool_direction , inherited2__its_id , inherited3__retract_plane , inherited4__start_point , inherited5__its_tool , inherited6__its_technology , inherited7__its_machine_functions , inherited8__overcut_length , inherited9__approach , inherited10__retract , its_machining_strategy, ):
		milling_type_operation.__init__(self , inherited0__its_toolpath , inherited1__its_tool_direction , inherited2__its_id , inherited3__retract_plane , inherited4__start_point , inherited5__its_tool , inherited6__its_technology , inherited7__its_machine_functions , inherited8__overcut_length , inherited9__approach , inherited10__retract , )
		self._its_machining_strategy = its_machining_strategy

	@property
	def its_machining_strategy(self):
		return self._its_machining_strategy
	@its_machining_strategy.setter
	def its_machining_strategy(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,freeform_strategy):
				self._its_machining_strategy = freeform_strategy(value)
			else:
				self._its_machining_strategy = value
		else:
			self._its_machining_strategy = value

####################
 # ENTITY freeform_rough_milling #
####################
class freeform_rough_milling(freeform_operation):
	'''Entity freeform_rough_milling definition.
	'''
	def __init__( self , inherited0__its_toolpath , inherited1__its_tool_direction , inherited2__its_id , inherited3__retract_plane , inherited4__start_point , inherited5__its_tool , inherited6__its_technology , inherited7__its_machine_functions , inherited8__overcut_length , inherited9__approach , inherited10__retract , inherited11__its_machining_strategy ,  ):
		freeform_operation.__init__(self , inherited0__its_toolpath , inherited1__its_tool_direction , inherited2__its_id , inherited3__retract_plane , inherited4__start_point , inherited5__its_tool , inherited6__its_technology , inherited7__its_machine_functions , inherited8__overcut_length , inherited9__approach , inherited10__retract , inherited11__its_machining_strategy , )

####################
 # ENTITY area_measure #
####################
class area_measure(value_with_tolerance):
	'''Entity area_measure definition.
	'''
	def __init__( self , inherited0__unit , inherited1__value_component , inherited2__limitation , inherited3__significant_digits ,  ):
		value_with_tolerance.__init__(self , inherited0__unit , inherited1__value_component , inherited2__limitation , inherited3__significant_digits , )

####################
 # ENTITY set_mark #
####################
class set_mark(nc_function):
	'''Entity set_mark definition.
	'''
	def __init__( self , inherited0__its_id ,  ):
		nc_function.__init__(self , inherited0__its_id , )

####################
 # ENTITY boolean_expression #
####################
class boolean_expression(BaseEntityClass):
	'''Entity boolean_expression definition.
	'''
	# This class does not define any attribute.
	pass

####################
 # ENTITY unary_boolean_expression #
####################
class unary_boolean_expression(boolean_expression):
	'''Entity unary_boolean_expression definition.

	:param operand
	:type operand:boolean_expression
	'''
	def __init__( self , operand, ):
		boolean_expression.__init__(self , )
		self._operand = operand

	@property
	def operand(self):
		return self._operand
	@operand.setter
	def operand(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,boolean_expression):
			self._operand = boolean_expression(value)
		else:
			self._operand = value

####################
 # ENTITY not_expression #
####################
class not_expression(unary_boolean_expression):
	'''Entity not_expression definition.
	'''
	def __init__( self , inherited0__operand ,  ):
		unary_boolean_expression.__init__(self , inherited0__operand , )

####################
 # ENTITY bottom_and_side_finish_milling #
####################
class bottom_and_side_finish_milling(bottom_and_side_milling):
	'''Entity bottom_and_side_finish_milling definition.
	'''
	def __init__( self , inherited0__its_toolpath , inherited1__its_tool_direction , inherited2__its_id , inherited3__retract_plane , inherited4__start_point , inherited5__its_tool , inherited6__its_technology , inherited7__its_machine_functions , inherited8__overcut_length , inherited9__approach , inherited10__retract , inherited11__its_machining_strategy , inherited12__axial_cutting_depth , inherited13__radial_cutting_depth , inherited14__allowance_side , inherited15__allowance_bottom ,  ):
		bottom_and_side_milling.__init__(self , inherited0__its_toolpath , inherited1__its_tool_direction , inherited2__its_id , inherited3__retract_plane , inherited4__start_point , inherited5__its_tool , inherited6__its_technology , inherited7__its_machine_functions , inherited8__overcut_length , inherited9__approach , inherited10__retract , inherited11__its_machining_strategy , inherited12__axial_cutting_depth , inherited13__radial_cutting_depth , inherited14__allowance_side , inherited15__allowance_bottom , )

####################
 # ENTITY threading #
####################
class threading(turning_machining_operation):
	'''Entity threading definition.

	:param allowance
	:type allowance:length_measure
	'''
	def __init__( self , inherited0__its_toolpath , inherited1__its_tool_direction , inherited2__its_id , inherited3__retract_plane , inherited4__start_point , inherited5__its_tool , inherited6__its_technology , inherited7__its_machine_functions , inherited8__approach , inherited9__retract , inherited10__its_machining_strategy , allowance, ):
		turning_machining_operation.__init__(self , inherited0__its_toolpath , inherited1__its_tool_direction , inherited2__its_id , inherited3__retract_plane , inherited4__start_point , inherited5__its_tool , inherited6__its_technology , inherited7__its_machine_functions , inherited8__approach , inherited9__retract , inherited10__its_machining_strategy , )
		self._allowance = allowance

	@property
	def allowance(self):
		return self._allowance
	@allowance.setter
	def allowance(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,length_measure):
				self._allowance = length_measure(value)
			else:
				self._allowance = value
		else:
			self._allowance = value

####################
 # ENTITY threading_finish #
####################
class threading_finish(threading):
	'''Entity threading_finish definition.
	'''
	def __init__( self , inherited0__its_toolpath , inherited1__its_tool_direction , inherited2__its_id , inherited3__retract_plane , inherited4__start_point , inherited5__its_tool , inherited6__its_technology , inherited7__its_machine_functions , inherited8__approach , inherited9__retract , inherited10__its_machining_strategy , inherited11__allowance ,  ):
		threading.__init__(self , inherited0__its_toolpath , inherited1__its_tool_direction , inherited2__its_id , inherited3__retract_plane , inherited4__start_point , inherited5__its_tool , inherited6__its_technology , inherited7__its_machine_functions , inherited8__approach , inherited9__retract , inherited10__its_machining_strategy , inherited11__allowance , )

####################
 # ENTITY datum_target #
####################
class datum_target(BaseEntityClass):
	'''Entity datum_target definition.

	:param id
	:type id:STRING
	'''
	def __init__( self , id, ):
		self._id = id

	@property
	def id(self):
		return self._id
	@id.setter
	def id(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,STRING):
			self._id = STRING(value)
		else:
			self._id = value

####################
 # ENTITY placed_target #
####################
class placed_target(datum_target):
	'''Entity placed_target definition.

	:param defined_in
	:type defined_in:STRING

	:param parameter_reference
	:type parameter_reference:axis_placement
	'''
	def __init__( self , inherited0__id , defined_in,parameter_reference, ):
		datum_target.__init__(self , inherited0__id , )
		self._defined_in = defined_in
		self._parameter_reference = parameter_reference

	@property
	def defined_in(self):
		return self._defined_in
	@defined_in.setter
	def defined_in(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,STRING):
			self._defined_in = STRING(value)
		else:
			self._defined_in = value

	@property
	def parameter_reference(self):
		return self._parameter_reference
	@parameter_reference.setter
	def parameter_reference(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,axis_placement):
			self._parameter_reference = axis_placement(value)
		else:
			self._parameter_reference = value

####################
 # ENTITY target_point #
####################
class target_point(placed_target):
	'''Entity target_point definition.
	'''
	def __init__( self , inherited0__id , inherited1__defined_in , inherited2__parameter_reference ,  ):
		placed_target.__init__(self , inherited0__id , inherited1__defined_in , inherited2__parameter_reference , )

####################
 # ENTITY explicit_strategy #
####################
class explicit_strategy(two5d_milling_strategy):
	'''Entity explicit_strategy definition.
	'''
	def __init__( self , inherited0__overlap , inherited1__allow_multiple_passes ,  ):
		two5d_milling_strategy.__init__(self , inherited0__overlap , inherited1__allow_multiple_passes , )

####################
 # ENTITY circular_closed_shape_profile #
####################
class circular_closed_shape_profile(shape_profile):
	'''Entity circular_closed_shape_profile definition.

	:param closed_boundary
	:type closed_boundary:circular_closed_profile
	'''
	def __init__( self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , inherited5__depth , inherited6__profile_swept_shape , inherited7__floor_condition , inherited8__removal_direction , closed_boundary, ):
		shape_profile.__init__(self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , inherited5__depth , inherited6__profile_swept_shape , inherited7__floor_condition , inherited8__removal_direction , )
		self._closed_boundary = closed_boundary

	@property
	def closed_boundary(self):
		return self._closed_boundary
	@closed_boundary.setter
	def closed_boundary(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,circular_closed_profile):
			self._closed_boundary = circular_closed_profile(value)
		else:
			self._closed_boundary = value

####################
 # ENTITY outer_round #
####################
class outer_round(turning_feature):
	'''Entity outer_round definition.
	'''
	def __init__( self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement ,  ):
		turning_feature.__init__(self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , )

####################
 # ENTITY outer_diameter #
####################
class outer_diameter(outer_round):
	'''Entity outer_diameter definition.

	:param diameter_at_placement
	:type diameter_at_placement:toleranced_length_measure

	:param feature_length
	:type feature_length:toleranced_length_measure

	:param reduced_size
	:type reduced_size:taper_select
	'''
	def __init__( self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , diameter_at_placement,feature_length,reduced_size, ):
		outer_round.__init__(self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , )
		self._diameter_at_placement = diameter_at_placement
		self._feature_length = feature_length
		self._reduced_size = reduced_size

	@property
	def diameter_at_placement(self):
		return self._diameter_at_placement
	@diameter_at_placement.setter
	def diameter_at_placement(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,toleranced_length_measure):
			self._diameter_at_placement = toleranced_length_measure(value)
		else:
			self._diameter_at_placement = value

	@property
	def feature_length(self):
		return self._feature_length
	@feature_length.setter
	def feature_length(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,toleranced_length_measure):
			self._feature_length = toleranced_length_measure(value)
		else:
			self._feature_length = value

	@property
	def reduced_size(self):
		return self._reduced_size
	@reduced_size.setter
	def reduced_size(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,taper_select):
				self._reduced_size = taper_select(value)
			else:
				self._reduced_size = value
		else:
			self._reduced_size = value

####################
 # ENTITY turning_machining_strategy #
####################
class turning_machining_strategy(BaseEntityClass):
	'''Entity turning_machining_strategy definition.

	:param overcut_length
	:type overcut_length:length_measure

	:param allow_multiple_passes
	:type allow_multiple_passes:BOOLEAN

	:param cutting_depth
	:type cutting_depth:LIST(0,None,'length_measure', scope = schema_scope)

	:param variable_feedrate
	:type variable_feedrate:positive_ratio_measure
	'''
	def __init__( self , overcut_length,allow_multiple_passes,cutting_depth,variable_feedrate, ):
		self._overcut_length = overcut_length
		self._allow_multiple_passes = allow_multiple_passes
		self._cutting_depth = cutting_depth
		self._variable_feedrate = variable_feedrate

	@property
	def overcut_length(self):
		return self._overcut_length
	@overcut_length.setter
	def overcut_length(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,length_measure):
				self._overcut_length = length_measure(value)
			else:
				self._overcut_length = value
		else:
			self._overcut_length = value

	@property
	def allow_multiple_passes(self):
		return self._allow_multiple_passes
	@allow_multiple_passes.setter
	def allow_multiple_passes(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,BOOLEAN):
				self._allow_multiple_passes = BOOLEAN(value)
			else:
				self._allow_multiple_passes = value
		else:
			self._allow_multiple_passes = value

	@property
	def cutting_depth(self):
		return self._cutting_depth
	@cutting_depth.setter
	def cutting_depth(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,LIST(0,None,'length_measure', scope = schema_scope)):
			self._cutting_depth = LIST(value)
		else:
			self._cutting_depth = value

	@property
	def variable_feedrate(self):
		return self._variable_feedrate
	@variable_feedrate.setter
	def variable_feedrate(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,positive_ratio_measure):
				self._variable_feedrate = positive_ratio_measure(value)
			else:
				self._variable_feedrate = value
		else:
			self._variable_feedrate = value

####################
 # ENTITY explicit_turning_strategy #
####################
class explicit_turning_strategy(turning_machining_strategy):
	'''Entity explicit_turning_strategy definition.
	'''
	def __init__( self , inherited0__overcut_length , inherited1__allow_multiple_passes , inherited2__cutting_depth , inherited3__variable_feedrate ,  ):
		turning_machining_strategy.__init__(self , inherited0__overcut_length , inherited1__allow_multiple_passes , inherited2__cutting_depth , inherited3__variable_feedrate , )

####################
 # ENTITY thread #
####################
class thread(machining_feature):
	'''Entity thread definition.

	:param partial_profile
	:type partial_profile:partial_area_definition

	:param applied_shape
	:type applied_shape:SET(1,None,'machining_feature', scope = schema_scope)

	:param inner_or_outer_thread
	:type inner_or_outer_thread:BOOLEAN

	:param qualifier
	:type qualifier:descriptive_parameter

	:param fit_class
	:type fit_class:descriptive_parameter

	:param form
	:type form:descriptive_parameter

	:param major_diameter
	:type major_diameter:length_measure

	:param number_of_threads
	:type number_of_threads:numeric_parameter

	:param thread_hand
	:type thread_hand:descriptive_parameter
	'''
	def __init__( self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , inherited5__depth , partial_profile,applied_shape,inner_or_outer_thread,qualifier,fit_class,form,major_diameter,number_of_threads,thread_hand, ):
		machining_feature.__init__(self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , inherited5__depth , )
		self._partial_profile = partial_profile
		self._applied_shape = applied_shape
		self._inner_or_outer_thread = inner_or_outer_thread
		self._qualifier = qualifier
		self._fit_class = fit_class
		self._form = form
		self._major_diameter = major_diameter
		self._number_of_threads = number_of_threads
		self._thread_hand = thread_hand

	@property
	def partial_profile(self):
		return self._partial_profile
	@partial_profile.setter
	def partial_profile(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,partial_area_definition):
			self._partial_profile = partial_area_definition(value)
		else:
			self._partial_profile = value

	@property
	def applied_shape(self):
		return self._applied_shape
	@applied_shape.setter
	def applied_shape(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(1,None,'machining_feature', scope = schema_scope)):
			self._applied_shape = SET(value)
		else:
			self._applied_shape = value

	@property
	def inner_or_outer_thread(self):
		return self._inner_or_outer_thread
	@inner_or_outer_thread.setter
	def inner_or_outer_thread(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,BOOLEAN):
			self._inner_or_outer_thread = BOOLEAN(value)
		else:
			self._inner_or_outer_thread = value

	@property
	def qualifier(self):
		return self._qualifier
	@qualifier.setter
	def qualifier(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,descriptive_parameter):
				self._qualifier = descriptive_parameter(value)
			else:
				self._qualifier = value
		else:
			self._qualifier = value

	@property
	def fit_class(self):
		return self._fit_class
	@fit_class.setter
	def fit_class(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,descriptive_parameter):
			self._fit_class = descriptive_parameter(value)
		else:
			self._fit_class = value

	@property
	def form(self):
		return self._form
	@form.setter
	def form(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,descriptive_parameter):
			self._form = descriptive_parameter(value)
		else:
			self._form = value

	@property
	def major_diameter(self):
		return self._major_diameter
	@major_diameter.setter
	def major_diameter(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,length_measure):
			self._major_diameter = length_measure(value)
		else:
			self._major_diameter = value

	@property
	def number_of_threads(self):
		return self._number_of_threads
	@number_of_threads.setter
	def number_of_threads(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,numeric_parameter):
			self._number_of_threads = numeric_parameter(value)
		else:
			self._number_of_threads = value

	@property
	def thread_hand(self):
		return self._thread_hand
	@thread_hand.setter
	def thread_hand(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,descriptive_parameter):
			self._thread_hand = descriptive_parameter(value)
		else:
			self._thread_hand = value
	def wr1(self):
		eval_wr1_wr = ((('AP238_ARM_SCHEMA.ROUND_HOLE'  ==  TYPEOF(self.applied_shape))  or  ('AP238_ARM_SCHEMA.CIRCULAR_CLOSED_SHAPE_PROFILE'  ==  TYPEOF(self.applied_shape)))  or  ('AP238_ARM_SCHEMA.BOSS'  ==  TYPEOF(self.applied_shape)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY catalogue_thread #
####################
class catalogue_thread(thread):
	'''Entity catalogue_thread definition.

	:param documentation
	:type documentation:specification
	'''
	def __init__( self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , inherited5__depth , inherited6__partial_profile , inherited7__applied_shape , inherited8__inner_or_outer_thread , inherited9__qualifier , inherited10__fit_class , inherited11__form , inherited12__major_diameter , inherited13__number_of_threads , inherited14__thread_hand , documentation, ):
		thread.__init__(self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , inherited5__depth , inherited6__partial_profile , inherited7__applied_shape , inherited8__inner_or_outer_thread , inherited9__qualifier , inherited10__fit_class , inherited11__form , inherited12__major_diameter , inherited13__number_of_threads , inherited14__thread_hand , )
		self._documentation = documentation

	@property
	def documentation(self):
		return self._documentation
	@documentation.setter
	def documentation(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,specification):
			self._documentation = specification(value)
		else:
			self._documentation = value

####################
 # ENTITY drilling_cutting_tool #
####################
class drilling_cutting_tool(milling_machine_cutting_tool):
	'''Entity drilling_cutting_tool definition.

	:param point_angle
	:type point_angle:plane_angle_measure
	'''
	def __init__( self , inherited0__its_id , inherited1__its_usage , inherited2__its_cutting_edges , inherited3__overall_assembly_length , inherited4__effective_cutting_diameter , inherited5__maximum_depth_of_cut , inherited6__hand_of_cut , inherited7__coolant_through_tool , point_angle, ):
		milling_machine_cutting_tool.__init__(self , inherited0__its_id , inherited1__its_usage , inherited2__its_cutting_edges , inherited3__overall_assembly_length , inherited4__effective_cutting_diameter , inherited5__maximum_depth_of_cut , inherited6__hand_of_cut , inherited7__coolant_through_tool , )
		self._point_angle = point_angle

	@property
	def point_angle(self):
		return self._point_angle
	@point_angle.setter
	def point_angle(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,plane_angle_measure):
			self._point_angle = plane_angle_measure(value)
		else:
			self._point_angle = value

####################
 # ENTITY reaming_cutting_tool #
####################
class reaming_cutting_tool(milling_machine_cutting_tool):
	'''Entity reaming_cutting_tool definition.

	:param taper_length
	:type taper_length:length_measure
	'''
	def __init__( self , inherited0__its_id , inherited1__its_usage , inherited2__its_cutting_edges , inherited3__overall_assembly_length , inherited4__effective_cutting_diameter , inherited5__maximum_depth_of_cut , inherited6__hand_of_cut , inherited7__coolant_through_tool , taper_length, ):
		milling_machine_cutting_tool.__init__(self , inherited0__its_id , inherited1__its_usage , inherited2__its_cutting_edges , inherited3__overall_assembly_length , inherited4__effective_cutting_diameter , inherited5__maximum_depth_of_cut , inherited6__hand_of_cut , inherited7__coolant_through_tool , )
		self._taper_length = taper_length

	@property
	def taper_length(self):
		return self._taper_length
	@taper_length.setter
	def taper_length(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,length_measure):
			self._taper_length = length_measure(value)
		else:
			self._taper_length = value

####################
 # ENTITY approval_relationship #
####################
class approval_relationship(BaseEntityClass):
	'''Entity approval_relationship definition.

	:param relation_type
	:type relation_type:STRING

	:param relating_approval
	:type relating_approval:approval

	:param related_approval
	:type related_approval:approval

	:param description
	:type description:STRING
	'''
	def __init__( self , relation_type,relating_approval,related_approval,description, ):
		self._relation_type = relation_type
		self._relating_approval = relating_approval
		self._related_approval = related_approval
		self._description = description

	@property
	def relation_type(self):
		return self._relation_type
	@relation_type.setter
	def relation_type(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,STRING):
			self._relation_type = STRING(value)
		else:
			self._relation_type = value

	@property
	def relating_approval(self):
		return self._relating_approval
	@relating_approval.setter
	def relating_approval(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,approval):
			self._relating_approval = approval(value)
		else:
			self._relating_approval = value

	@property
	def related_approval(self):
		return self._related_approval
	@related_approval.setter
	def related_approval(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,approval):
			self._related_approval = approval(value)
		else:
			self._related_approval = value

	@property
	def description(self):
		return self._description
	@description.setter
	def description(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,STRING):
				self._description = STRING(value)
			else:
				self._description = value
		else:
			self._description = value

####################
 # ENTITY grooving_strategy #
####################
class grooving_strategy(turning_machining_strategy):
	'''Entity grooving_strategy definition.

	:param grooving_direction
	:type grooving_direction:direction

	:param travel_distance
	:type travel_distance:length_measure
	'''
	def __init__( self , inherited0__overcut_length , inherited1__allow_multiple_passes , inherited2__cutting_depth , inherited3__variable_feedrate , grooving_direction,travel_distance, ):
		turning_machining_strategy.__init__(self , inherited0__overcut_length , inherited1__allow_multiple_passes , inherited2__cutting_depth , inherited3__variable_feedrate , )
		self._grooving_direction = grooving_direction
		self._travel_distance = travel_distance

	@property
	def grooving_direction(self):
		return self._grooving_direction
	@grooving_direction.setter
	def grooving_direction(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,direction):
				self._grooving_direction = direction(value)
			else:
				self._grooving_direction = value
		else:
			self._grooving_direction = value

	@property
	def travel_distance(self):
		return self._travel_distance
	@travel_distance.setter
	def travel_distance(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,length_measure):
				self._travel_distance = length_measure(value)
			else:
				self._travel_distance = value
		else:
			self._travel_distance = value

####################
 # ENTITY boss #
####################
class boss(machining_feature):
	'''Entity boss definition.

	:param its_boundary
	:type its_boundary:closed_profile

	:param slope
	:type slope:plane_angle_measure

	:param boss_height
	:type boss_height:linear_path
	'''
	def __init__( self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , inherited5__depth , its_boundary,slope,boss_height, ):
		machining_feature.__init__(self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , inherited5__depth , )
		self._its_boundary = its_boundary
		self._slope = slope
		self._boss_height = boss_height

	@property
	def its_boundary(self):
		return self._its_boundary
	@its_boundary.setter
	def its_boundary(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,closed_profile):
			self._its_boundary = closed_profile(value)
		else:
			self._its_boundary = value

	@property
	def slope(self):
		return self._slope
	@slope.setter
	def slope(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,plane_angle_measure):
				self._slope = plane_angle_measure(value)
			else:
				self._slope = value
		else:
			self._slope = value

	@property
	def boss_height(self):
		return self._boss_height
	@boss_height.setter
	def boss_height(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,linear_path):
			self._boss_height = linear_path(value)
		else:
			self._boss_height = value

####################
 # ENTITY derived_geometry #
####################
class derived_geometry(BaseEntityClass):
	'''Entity derived_geometry definition.

	:param derived_from
	:type derived_from:SET(1,None,'STRING', scope = schema_scope)

	:param role
	:type role:STRING
	'''
	def __init__( self , derived_from,role, ):
		self._derived_from = derived_from
		self._role = role

	@property
	def derived_from(self):
		return self._derived_from
	@derived_from.setter
	def derived_from(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(1,None,'STRING', scope = schema_scope)):
			self._derived_from = SET(value)
		else:
			self._derived_from = value

	@property
	def role(self):
		return self._role
	@role.setter
	def role(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,STRING):
			self._role = STRING(value)
		else:
			self._role = value

####################
 # ENTITY datum_defined_by_derived_shape #
####################
class datum_defined_by_derived_shape(single_datum,derived_geometry):
	'''Entity datum_defined_by_derived_shape definition.
	'''
	def __init__( self , inherited0__datum_name , inherited1__modification , inherited2__derived_from , inherited3__role ,  ):
		single_datum.__init__(self , inherited0__datum_name , inherited1__modification , )
		derived_geometry.__init__(self , inherited2__derived_from , inherited3__role , )

####################
 # ENTITY turning_machine_cutting_tool #
####################
class turning_machine_cutting_tool(machining_tool):
	'''Entity turning_machine_cutting_tool definition.

	:param functional_length
	:type functional_length:length_measure

	:param f_dimension
	:type f_dimension:length_measure

	:param minimum_cutting_diameter
	:type minimum_cutting_diameter:length_measure

	:param a_dimension_on_f
	:type a_dimension_on_f:length_measure

	:param a_dimension_on_lf
	:type a_dimension_on_lf:length_measure

	:param cutting_edge
	:type cutting_edge:cutting_edge_properties

	:param hand_of_tool
	:type hand_of_tool:hand_of_tool_type
	'''
	def __init__( self , inherited0__its_id , inherited1__its_usage , functional_length,f_dimension,minimum_cutting_diameter,a_dimension_on_f,a_dimension_on_lf,cutting_edge,hand_of_tool, ):
		machining_tool.__init__(self , inherited0__its_id , inherited1__its_usage , )
		self._functional_length = functional_length
		self._f_dimension = f_dimension
		self._minimum_cutting_diameter = minimum_cutting_diameter
		self._a_dimension_on_f = a_dimension_on_f
		self._a_dimension_on_lf = a_dimension_on_lf
		self._cutting_edge = cutting_edge
		self._hand_of_tool = hand_of_tool

	@property
	def functional_length(self):
		return self._functional_length
	@functional_length.setter
	def functional_length(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,length_measure):
			self._functional_length = length_measure(value)
		else:
			self._functional_length = value

	@property
	def f_dimension(self):
		return self._f_dimension
	@f_dimension.setter
	def f_dimension(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,length_measure):
			self._f_dimension = length_measure(value)
		else:
			self._f_dimension = value

	@property
	def minimum_cutting_diameter(self):
		return self._minimum_cutting_diameter
	@minimum_cutting_diameter.setter
	def minimum_cutting_diameter(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,length_measure):
				self._minimum_cutting_diameter = length_measure(value)
			else:
				self._minimum_cutting_diameter = value
		else:
			self._minimum_cutting_diameter = value

	@property
	def a_dimension_on_f(self):
		return self._a_dimension_on_f
	@a_dimension_on_f.setter
	def a_dimension_on_f(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,length_measure):
				self._a_dimension_on_f = length_measure(value)
			else:
				self._a_dimension_on_f = value
		else:
			self._a_dimension_on_f = value

	@property
	def a_dimension_on_lf(self):
		return self._a_dimension_on_lf
	@a_dimension_on_lf.setter
	def a_dimension_on_lf(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,length_measure):
				self._a_dimension_on_lf = length_measure(value)
			else:
				self._a_dimension_on_lf = value
		else:
			self._a_dimension_on_lf = value

	@property
	def cutting_edge(self):
		return self._cutting_edge
	@cutting_edge.setter
	def cutting_edge(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,cutting_edge_properties):
			self._cutting_edge = cutting_edge_properties(value)
		else:
			self._cutting_edge = value

	@property
	def hand_of_tool(self):
		return self._hand_of_tool
	@hand_of_tool.setter
	def hand_of_tool(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,hand_of_tool_type):
				self._hand_of_tool = hand_of_tool_type(value)
			else:
				self._hand_of_tool = value
		else:
			self._hand_of_tool = value

####################
 # ENTITY turning_threading_tool #
####################
class turning_threading_tool(turning_machine_cutting_tool):
	'''Entity turning_threading_tool definition.

	:param threading_pitch
	:type threading_pitch:length_measure

	:param thread_hand
	:type thread_hand:thread_hand_type

	:param its_thread_type
	:type its_thread_type:thread_type

	:param thread_profile
	:type thread_profile:thread_profile_type

	:param thread_form_type
	:type thread_form_type:STRING
	'''
	def __init__( self , inherited0__its_id , inherited1__its_usage , inherited2__functional_length , inherited3__f_dimension , inherited4__minimum_cutting_diameter , inherited5__a_dimension_on_f , inherited6__a_dimension_on_lf , inherited7__cutting_edge , inherited8__hand_of_tool , threading_pitch,thread_hand,its_thread_type,thread_profile,thread_form_type, ):
		turning_machine_cutting_tool.__init__(self , inherited0__its_id , inherited1__its_usage , inherited2__functional_length , inherited3__f_dimension , inherited4__minimum_cutting_diameter , inherited5__a_dimension_on_f , inherited6__a_dimension_on_lf , inherited7__cutting_edge , inherited8__hand_of_tool , )
		self._threading_pitch = threading_pitch
		self._thread_hand = thread_hand
		self._its_thread_type = its_thread_type
		self._thread_profile = thread_profile
		self._thread_form_type = thread_form_type

	@property
	def threading_pitch(self):
		return self._threading_pitch
	@threading_pitch.setter
	def threading_pitch(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,length_measure):
			self._threading_pitch = length_measure(value)
		else:
			self._threading_pitch = value

	@property
	def thread_hand(self):
		return self._thread_hand
	@thread_hand.setter
	def thread_hand(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,thread_hand_type):
			self._thread_hand = thread_hand_type(value)
		else:
			self._thread_hand = value

	@property
	def its_thread_type(self):
		return self._its_thread_type
	@its_thread_type.setter
	def its_thread_type(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,thread_type):
			self._its_thread_type = thread_type(value)
		else:
			self._its_thread_type = value

	@property
	def thread_profile(self):
		return self._thread_profile
	@thread_profile.setter
	def thread_profile(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,thread_profile_type):
			self._thread_profile = thread_profile_type(value)
		else:
			self._thread_profile = value

	@property
	def thread_form_type(self):
		return self._thread_form_type
	@thread_form_type.setter
	def thread_form_type(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,STRING):
			self._thread_form_type = STRING(value)
		else:
			self._thread_form_type = value

####################
 # ENTITY dovetail_mill #
####################
class dovetail_mill(milling_cutting_tool):
	'''Entity dovetail_mill definition.

	:param included_angle
	:type included_angle:plane_angle_measure
	'''
	def __init__( self , inherited0__its_id , inherited1__its_usage , inherited2__its_cutting_edges , inherited3__overall_assembly_length , inherited4__effective_cutting_diameter , inherited5__maximum_depth_of_cut , inherited6__hand_of_cut , inherited7__coolant_through_tool , inherited8__number_of_effective_teeth , inherited9__edge_radius , included_angle, ):
		milling_cutting_tool.__init__(self , inherited0__its_id , inherited1__its_usage , inherited2__its_cutting_edges , inherited3__overall_assembly_length , inherited4__effective_cutting_diameter , inherited5__maximum_depth_of_cut , inherited6__hand_of_cut , inherited7__coolant_through_tool , inherited8__number_of_effective_teeth , inherited9__edge_radius , )
		self._included_angle = included_angle

	@property
	def included_angle(self):
		return self._included_angle
	@included_angle.setter
	def included_angle(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,plane_angle_measure):
			self._included_angle = plane_angle_measure(value)
		else:
			self._included_angle = value

####################
 # ENTITY freeform_strategy #
####################
class freeform_strategy(BaseEntityClass):
	'''Entity freeform_strategy definition.

	:param pathmode
	:type pathmode:pathmode_type

	:param cutmode
	:type cutmode:cutmode_type

	:param its_milling_tolerances
	:type its_milling_tolerances:tolerances

	:param stepover
	:type stepover:length_measure
	'''
	def __init__( self , pathmode,cutmode,its_milling_tolerances,stepover, ):
		self._pathmode = pathmode
		self._cutmode = cutmode
		self._its_milling_tolerances = its_milling_tolerances
		self._stepover = stepover

	@property
	def pathmode(self):
		return self._pathmode
	@pathmode.setter
	def pathmode(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,pathmode_type):
			self._pathmode = pathmode_type(value)
		else:
			self._pathmode = value

	@property
	def cutmode(self):
		return self._cutmode
	@cutmode.setter
	def cutmode(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,cutmode_type):
			self._cutmode = cutmode_type(value)
		else:
			self._cutmode = value

	@property
	def its_milling_tolerances(self):
		return self._its_milling_tolerances
	@its_milling_tolerances.setter
	def its_milling_tolerances(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,tolerances):
			self._its_milling_tolerances = tolerances(value)
		else:
			self._its_milling_tolerances = value

	@property
	def stepover(self):
		return self._stepover
	@stepover.setter
	def stepover(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,length_measure):
				self._stepover = length_measure(value)
			else:
				self._stepover = value
		else:
			self._stepover = value

####################
 # ENTITY plane_cc_strategy #
####################
class plane_cc_strategy(freeform_strategy):
	'''Entity plane_cc_strategy definition.

	:param its_plane_normal
	:type its_plane_normal:direction
	'''
	def __init__( self , inherited0__pathmode , inherited1__cutmode , inherited2__its_milling_tolerances , inherited3__stepover , its_plane_normal, ):
		freeform_strategy.__init__(self , inherited0__pathmode , inherited1__cutmode , inherited2__its_milling_tolerances , inherited3__stepover , )
		self._its_plane_normal = its_plane_normal

	@property
	def its_plane_normal(self):
		return self._its_plane_normal
	@its_plane_normal.setter
	def its_plane_normal(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,direction):
			self._its_plane_normal = direction(value)
		else:
			self._its_plane_normal = value

####################
 # ENTITY toolpath #
####################
class toolpath(BaseEntityClass):
	'''Entity toolpath definition.

	:param its_priority
	:type its_priority:BOOLEAN

	:param its_type
	:type its_type:toolpath_type

	:param its_speed
	:type its_speed:toolpath_speedprofile

	:param its_technology
	:type its_technology:technology

	:param its_machine_functions
	:type its_machine_functions:machine_functions

	:param its_id
	:type its_id:identifier
	'''
	def __init__( self , its_priority,its_type,its_speed,its_technology,its_machine_functions,its_id, ):
		self._its_priority = its_priority
		self._its_type = its_type
		self._its_speed = its_speed
		self._its_technology = its_technology
		self._its_machine_functions = its_machine_functions
		self._its_id = its_id

	@property
	def its_priority(self):
		return self._its_priority
	@its_priority.setter
	def its_priority(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,BOOLEAN):
			self._its_priority = BOOLEAN(value)
		else:
			self._its_priority = value

	@property
	def its_type(self):
		return self._its_type
	@its_type.setter
	def its_type(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,toolpath_type):
			self._its_type = toolpath_type(value)
		else:
			self._its_type = value

	@property
	def its_speed(self):
		return self._its_speed
	@its_speed.setter
	def its_speed(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,toolpath_speedprofile):
				self._its_speed = toolpath_speedprofile(value)
			else:
				self._its_speed = value
		else:
			self._its_speed = value

	@property
	def its_technology(self):
		return self._its_technology
	@its_technology.setter
	def its_technology(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,technology):
				self._its_technology = technology(value)
			else:
				self._its_technology = value
		else:
			self._its_technology = value

	@property
	def its_machine_functions(self):
		return self._its_machine_functions
	@its_machine_functions.setter
	def its_machine_functions(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,machine_functions):
				self._its_machine_functions = machine_functions(value)
			else:
				self._its_machine_functions = value
		else:
			self._its_machine_functions = value

	@property
	def its_id(self):
		return self._its_id
	@its_id.setter
	def its_id(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,identifier):
			self._its_id = identifier(value)
		else:
			self._its_id = value

####################
 # ENTITY parameterised_path #
####################
class parameterised_path(toolpath):
	'''Entity parameterised_path definition.
	'''
	def __init__( self , inherited0__its_priority , inherited1__its_type , inherited2__its_speed , inherited3__its_technology , inherited4__its_machine_functions , inherited5__its_id ,  ):
		toolpath.__init__(self , inherited0__its_priority , inherited1__its_type , inherited2__its_speed , inherited3__its_technology , inherited4__its_machine_functions , inherited5__its_id , )

####################
 # ENTITY approach_lift_path #
####################
class approach_lift_path(parameterised_path):
	'''Entity approach_lift_path definition.

	:param fix_point
	:type fix_point:cartesian_point

	:param fix_point_dir
	:type fix_point_dir:direction
	'''
	def __init__( self , inherited0__its_priority , inherited1__its_type , inherited2__its_speed , inherited3__its_technology , inherited4__its_machine_functions , inherited5__its_id , fix_point,fix_point_dir, ):
		parameterised_path.__init__(self , inherited0__its_priority , inherited1__its_type , inherited2__its_speed , inherited3__its_technology , inherited4__its_machine_functions , inherited5__its_id , )
		self._fix_point = fix_point
		self._fix_point_dir = fix_point_dir

	@property
	def fix_point(self):
		return self._fix_point
	@fix_point.setter
	def fix_point(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,cartesian_point):
			self._fix_point = cartesian_point(value)
		else:
			self._fix_point = value

	@property
	def fix_point_dir(self):
		return self._fix_point_dir
	@fix_point_dir.setter
	def fix_point_dir(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,direction):
				self._fix_point_dir = direction(value)
			else:
				self._fix_point_dir = value
		else:
			self._fix_point_dir = value

####################
 # ENTITY revolved_feature #
####################
class revolved_feature(turning_feature):
	'''Entity revolved_feature definition.

	:param material_side
	:type material_side:direction

	:param radius
	:type radius:length_measure
	'''
	def __init__( self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , material_side,radius, ):
		turning_feature.__init__(self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , )
		self._material_side = material_side
		self._radius = radius

	@property
	def material_side(self):
		return self._material_side
	@material_side.setter
	def material_side(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,direction):
				self._material_side = direction(value)
			else:
				self._material_side = value
		else:
			self._material_side = value

	@property
	def radius(self):
		return self._radius
	@radius.setter
	def radius(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,length_measure):
			self._radius = length_measure(value)
		else:
			self._radius = value

####################
 # ENTITY general_revolution #
####################
class general_revolution(revolved_feature):
	'''Entity general_revolution definition.

	:param outer_edge_profile
	:type outer_edge_profile:general_profile
	'''
	def __init__( self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , inherited5__material_side , inherited6__radius , outer_edge_profile, ):
		revolved_feature.__init__(self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , inherited5__material_side , inherited6__radius , )
		self._outer_edge_profile = outer_edge_profile

	@property
	def outer_edge_profile(self):
		return self._outer_edge_profile
	@outer_edge_profile.setter
	def outer_edge_profile(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,general_profile):
			self._outer_edge_profile = general_profile(value)
		else:
			self._outer_edge_profile = value

####################
 # ENTITY library_property_value #
####################
class library_property_value(BaseEntityClass):
	'''Entity library_property_value definition.

	:param value_property_bsu
	:type value_property_bsu:property_bsu

	:param value_amount
	:type value_amount:measure_value
	'''
	def __init__( self , value_property_bsu,value_amount, ):
		self._value_property_bsu = value_property_bsu
		self._value_amount = value_amount

	@property
	def value_property_bsu(self):
		return self._value_property_bsu
	@value_property_bsu.setter
	def value_property_bsu(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,property_bsu):
			self._value_property_bsu = property_bsu(value)
		else:
			self._value_property_bsu = value

	@property
	def value_amount(self):
		return self._value_amount
	@value_amount.setter
	def value_amount(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,measure_value):
			self._value_amount = measure_value(value)
		else:
			self._value_amount = value

####################
 # ENTITY circular_pattern #
####################
class circular_pattern(replicate_feature):
	'''Entity circular_pattern definition.

	:param angle_increment
	:type angle_increment:plane_angle_measure

	:param number_of_feature
	:type number_of_feature:INTEGER

	:param relocated_base_feature
	:type relocated_base_feature:SET(0,None,'circular_offset', scope = schema_scope)

	:param missing_base_feature
	:type missing_base_feature:SET(0,None,'circular_omit', scope = schema_scope)

	:param base_feature_diameter
	:type base_feature_diameter:toleranced_length_measure

	:param base_feature_rotation
	:type base_feature_rotation:plane_angle_measure
	'''
	def __init__( self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , inherited5__replicate_base_feature , angle_increment,number_of_feature,relocated_base_feature,missing_base_feature,base_feature_diameter,base_feature_rotation, ):
		replicate_feature.__init__(self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , inherited5__replicate_base_feature , )
		self._angle_increment = angle_increment
		self._number_of_feature = number_of_feature
		self._relocated_base_feature = relocated_base_feature
		self._missing_base_feature = missing_base_feature
		self._base_feature_diameter = base_feature_diameter
		self._base_feature_rotation = base_feature_rotation

	@property
	def angle_increment(self):
		return self._angle_increment
	@angle_increment.setter
	def angle_increment(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,plane_angle_measure):
			self._angle_increment = plane_angle_measure(value)
		else:
			self._angle_increment = value

	@property
	def number_of_feature(self):
		return self._number_of_feature
	@number_of_feature.setter
	def number_of_feature(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,INTEGER):
			self._number_of_feature = INTEGER(value)
		else:
			self._number_of_feature = value

	@property
	def relocated_base_feature(self):
		return self._relocated_base_feature
	@relocated_base_feature.setter
	def relocated_base_feature(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(0,None,'circular_offset', scope = schema_scope)):
			self._relocated_base_feature = SET(value)
		else:
			self._relocated_base_feature = value

	@property
	def missing_base_feature(self):
		return self._missing_base_feature
	@missing_base_feature.setter
	def missing_base_feature(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(0,None,'circular_omit', scope = schema_scope)):
			self._missing_base_feature = SET(value)
		else:
			self._missing_base_feature = value

	@property
	def base_feature_diameter(self):
		return self._base_feature_diameter
	@base_feature_diameter.setter
	def base_feature_diameter(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,toleranced_length_measure):
				self._base_feature_diameter = toleranced_length_measure(value)
			else:
				self._base_feature_diameter = value
		else:
			self._base_feature_diameter = value

	@property
	def base_feature_rotation(self):
		return self._base_feature_rotation
	@base_feature_rotation.setter
	def base_feature_rotation(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,plane_angle_measure):
			self._base_feature_rotation = plane_angle_measure(value)
		else:
			self._base_feature_rotation = value

####################
 # ENTITY approach_retract_strategy #
####################
class approach_retract_strategy(BaseEntityClass):
	'''Entity approach_retract_strategy definition.

	:param tool_orientation
	:type tool_orientation:direction
	'''
	def __init__( self , tool_orientation, ):
		self._tool_orientation = tool_orientation

	@property
	def tool_orientation(self):
		return self._tool_orientation
	@tool_orientation.setter
	def tool_orientation(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,direction):
				self._tool_orientation = direction(value)
			else:
				self._tool_orientation = value
		else:
			self._tool_orientation = value

####################
 # ENTITY plunge_strategy #
####################
class plunge_strategy(approach_retract_strategy):
	'''Entity plunge_strategy definition.
	'''
	def __init__( self , inherited0__tool_orientation ,  ):
		approach_retract_strategy.__init__(self , inherited0__tool_orientation , )

####################
 # ENTITY plunge_toolaxis #
####################
class plunge_toolaxis(plunge_strategy):
	'''Entity plunge_toolaxis definition.
	'''
	def __init__( self , inherited0__tool_orientation ,  ):
		plunge_strategy.__init__(self , inherited0__tool_orientation , )

####################
 # ENTITY workpiece #
####################
class workpiece(BaseEntityClass):
	'''Entity workpiece definition.

	:param its_id
	:type its_id:identifier

	:param its_material
	:type its_material:material

	:param global_tolerance
	:type global_tolerance:length_measure

	:param its_rawpiece
	:type its_rawpiece:workpiece

	:param its_geometry
	:type its_geometry:shape_representation

	:param its_bounding_geometry
	:type its_bounding_geometry:bounding_geometry_select

	:param clamping_positions
	:type clamping_positions:SET(0,None,'STRING', scope = schema_scope)

	:param its_approvals
	:type its_approvals:SET(0,None,'approval', scope = schema_scope)

	:param its_categories
	:type its_categories:SET(0,None,'STRING', scope = schema_scope)

	:param its_components
	:type its_components:SET(0,None,'workpiece_assembly_component', scope = schema_scope)

	:param its_datestamps
	:type its_datestamps:SET(0,None,'assigned_date', scope = schema_scope)

	:param its_orgs
	:type its_orgs:SET(0,None,'assigned_organization', scope = schema_scope)

	:param its_people
	:type its_people:SET(0,None,'assigned_person', scope = schema_scope)

	:param its_related_geometry
	:type its_related_geometry:SET(0,None,'STRING', scope = schema_scope)

	:param its_timestamps
	:type its_timestamps:SET(0,None,'assigned_time', scope = schema_scope)

	:param product_approvals
	:type product_approvals:SET(0,None,'approval', scope = schema_scope)

	:param product_datestamps
	:type product_datestamps:SET(0,None,'assigned_date', scope = schema_scope)

	:param product_orgs
	:type product_orgs:SET(0,None,'assigned_organization', scope = schema_scope)

	:param product_people
	:type product_people:SET(0,None,'assigned_person', scope = schema_scope)

	:param product_timestamps
	:type product_timestamps:SET(0,None,'assigned_time', scope = schema_scope)

	:param revision_approvals
	:type revision_approvals:SET(0,None,'approval', scope = schema_scope)

	:param revision_datestamps
	:type revision_datestamps:SET(0,None,'assigned_date', scope = schema_scope)

	:param revision_id
	:type revision_id:identifier

	:param revision_orgs
	:type revision_orgs:SET(0,None,'assigned_organization', scope = schema_scope)

	:param revision_people
	:type revision_people:SET(0,None,'assigned_person', scope = schema_scope)

	:param revision_timestamps
	:type revision_timestamps:SET(0,None,'assigned_time', scope = schema_scope)
	'''
	def __init__( self , its_id,its_material,global_tolerance,its_rawpiece,its_geometry,its_bounding_geometry,clamping_positions,its_approvals,its_categories,its_components,its_datestamps,its_orgs,its_people,its_related_geometry,its_timestamps,product_approvals,product_datestamps,product_orgs,product_people,product_timestamps,revision_approvals,revision_datestamps,revision_id,revision_orgs,revision_people,revision_timestamps, ):
		self._its_id = its_id
		self._its_material = its_material
		self._global_tolerance = global_tolerance
		self._its_rawpiece = its_rawpiece
		self._its_geometry = its_geometry
		self._its_bounding_geometry = its_bounding_geometry
		self._clamping_positions = clamping_positions
		self._its_approvals = its_approvals
		self._its_categories = its_categories
		self._its_components = its_components
		self._its_datestamps = its_datestamps
		self._its_orgs = its_orgs
		self._its_people = its_people
		self._its_related_geometry = its_related_geometry
		self._its_timestamps = its_timestamps
		self._product_approvals = product_approvals
		self._product_datestamps = product_datestamps
		self._product_orgs = product_orgs
		self._product_people = product_people
		self._product_timestamps = product_timestamps
		self._revision_approvals = revision_approvals
		self._revision_datestamps = revision_datestamps
		self._revision_id = revision_id
		self._revision_orgs = revision_orgs
		self._revision_people = revision_people
		self._revision_timestamps = revision_timestamps

	@property
	def its_id(self):
		return self._its_id
	@its_id.setter
	def its_id(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,identifier):
			self._its_id = identifier(value)
		else:
			self._its_id = value

	@property
	def its_material(self):
		return self._its_material
	@its_material.setter
	def its_material(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,material):
				self._its_material = material(value)
			else:
				self._its_material = value
		else:
			self._its_material = value

	@property
	def global_tolerance(self):
		return self._global_tolerance
	@global_tolerance.setter
	def global_tolerance(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,length_measure):
				self._global_tolerance = length_measure(value)
			else:
				self._global_tolerance = value
		else:
			self._global_tolerance = value

	@property
	def its_rawpiece(self):
		return self._its_rawpiece
	@its_rawpiece.setter
	def its_rawpiece(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,workpiece):
				self._its_rawpiece = workpiece(value)
			else:
				self._its_rawpiece = value
		else:
			self._its_rawpiece = value

	@property
	def its_geometry(self):
		return self._its_geometry
	@its_geometry.setter
	def its_geometry(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,shape_representation):
				self._its_geometry = shape_representation(value)
			else:
				self._its_geometry = value
		else:
			self._its_geometry = value

	@property
	def its_bounding_geometry(self):
		return self._its_bounding_geometry
	@its_bounding_geometry.setter
	def its_bounding_geometry(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,bounding_geometry_select):
				self._its_bounding_geometry = bounding_geometry_select(value)
			else:
				self._its_bounding_geometry = value
		else:
			self._its_bounding_geometry = value

	@property
	def clamping_positions(self):
		return self._clamping_positions
	@clamping_positions.setter
	def clamping_positions(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(0,None,'STRING', scope = schema_scope)):
			self._clamping_positions = SET(value)
		else:
			self._clamping_positions = value

	@property
	def its_approvals(self):
		return self._its_approvals
	@its_approvals.setter
	def its_approvals(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(0,None,'approval', scope = schema_scope)):
			self._its_approvals = SET(value)
		else:
			self._its_approvals = value

	@property
	def its_categories(self):
		return self._its_categories
	@its_categories.setter
	def its_categories(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(0,None,'STRING', scope = schema_scope)):
			self._its_categories = SET(value)
		else:
			self._its_categories = value

	@property
	def its_components(self):
		return self._its_components
	@its_components.setter
	def its_components(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(0,None,'workpiece_assembly_component', scope = schema_scope)):
			self._its_components = SET(value)
		else:
			self._its_components = value

	@property
	def its_datestamps(self):
		return self._its_datestamps
	@its_datestamps.setter
	def its_datestamps(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(0,None,'assigned_date', scope = schema_scope)):
			self._its_datestamps = SET(value)
		else:
			self._its_datestamps = value

	@property
	def its_orgs(self):
		return self._its_orgs
	@its_orgs.setter
	def its_orgs(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(0,None,'assigned_organization', scope = schema_scope)):
			self._its_orgs = SET(value)
		else:
			self._its_orgs = value

	@property
	def its_people(self):
		return self._its_people
	@its_people.setter
	def its_people(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(0,None,'assigned_person', scope = schema_scope)):
			self._its_people = SET(value)
		else:
			self._its_people = value

	@property
	def its_related_geometry(self):
		return self._its_related_geometry
	@its_related_geometry.setter
	def its_related_geometry(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(0,None,'STRING', scope = schema_scope)):
			self._its_related_geometry = SET(value)
		else:
			self._its_related_geometry = value

	@property
	def its_timestamps(self):
		return self._its_timestamps
	@its_timestamps.setter
	def its_timestamps(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(0,None,'assigned_time', scope = schema_scope)):
			self._its_timestamps = SET(value)
		else:
			self._its_timestamps = value

	@property
	def product_approvals(self):
		return self._product_approvals
	@product_approvals.setter
	def product_approvals(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(0,None,'approval', scope = schema_scope)):
			self._product_approvals = SET(value)
		else:
			self._product_approvals = value

	@property
	def product_datestamps(self):
		return self._product_datestamps
	@product_datestamps.setter
	def product_datestamps(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(0,None,'assigned_date', scope = schema_scope)):
			self._product_datestamps = SET(value)
		else:
			self._product_datestamps = value

	@property
	def product_orgs(self):
		return self._product_orgs
	@product_orgs.setter
	def product_orgs(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(0,None,'assigned_organization', scope = schema_scope)):
			self._product_orgs = SET(value)
		else:
			self._product_orgs = value

	@property
	def product_people(self):
		return self._product_people
	@product_people.setter
	def product_people(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(0,None,'assigned_person', scope = schema_scope)):
			self._product_people = SET(value)
		else:
			self._product_people = value

	@property
	def product_timestamps(self):
		return self._product_timestamps
	@product_timestamps.setter
	def product_timestamps(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(0,None,'assigned_time', scope = schema_scope)):
			self._product_timestamps = SET(value)
		else:
			self._product_timestamps = value

	@property
	def revision_approvals(self):
		return self._revision_approvals
	@revision_approvals.setter
	def revision_approvals(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(0,None,'approval', scope = schema_scope)):
			self._revision_approvals = SET(value)
		else:
			self._revision_approvals = value

	@property
	def revision_datestamps(self):
		return self._revision_datestamps
	@revision_datestamps.setter
	def revision_datestamps(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(0,None,'assigned_date', scope = schema_scope)):
			self._revision_datestamps = SET(value)
		else:
			self._revision_datestamps = value

	@property
	def revision_id(self):
		return self._revision_id
	@revision_id.setter
	def revision_id(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,identifier):
				self._revision_id = identifier(value)
			else:
				self._revision_id = value
		else:
			self._revision_id = value

	@property
	def revision_orgs(self):
		return self._revision_orgs
	@revision_orgs.setter
	def revision_orgs(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(0,None,'assigned_organization', scope = schema_scope)):
			self._revision_orgs = SET(value)
		else:
			self._revision_orgs = value

	@property
	def revision_people(self):
		return self._revision_people
	@revision_people.setter
	def revision_people(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(0,None,'assigned_person', scope = schema_scope)):
			self._revision_people = SET(value)
		else:
			self._revision_people = value

	@property
	def revision_timestamps(self):
		return self._revision_timestamps
	@revision_timestamps.setter
	def revision_timestamps(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(0,None,'assigned_time', scope = schema_scope)):
			self._revision_timestamps = SET(value)
		else:
			self._revision_timestamps = value

####################
 # ENTITY square_u_profile #
####################
class square_u_profile(open_profile):
	'''Entity square_u_profile definition.

	:param width
	:type width:toleranced_length_measure

	:param first_radius
	:type first_radius:toleranced_length_measure

	:param first_angle
	:type first_angle:plane_angle_measure

	:param second_radius
	:type second_radius:toleranced_length_measure

	:param second_angle
	:type second_angle:plane_angle_measure

	:param depth
	:type depth:toleranced_length_measure
	'''
	def __init__( self , inherited0__placement , width,first_radius,first_angle,second_radius,second_angle,depth, ):
		open_profile.__init__(self , inherited0__placement , )
		self._width = width
		self._first_radius = first_radius
		self._first_angle = first_angle
		self._second_radius = second_radius
		self._second_angle = second_angle
		self._depth = depth

	@property
	def width(self):
		return self._width
	@width.setter
	def width(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,toleranced_length_measure):
			self._width = toleranced_length_measure(value)
		else:
			self._width = value

	@property
	def first_radius(self):
		return self._first_radius
	@first_radius.setter
	def first_radius(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,toleranced_length_measure):
			self._first_radius = toleranced_length_measure(value)
		else:
			self._first_radius = value

	@property
	def first_angle(self):
		return self._first_angle
	@first_angle.setter
	def first_angle(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,plane_angle_measure):
			self._first_angle = plane_angle_measure(value)
		else:
			self._first_angle = value

	@property
	def second_radius(self):
		return self._second_radius
	@second_radius.setter
	def second_radius(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,toleranced_length_measure):
			self._second_radius = toleranced_length_measure(value)
		else:
			self._second_radius = value

	@property
	def second_angle(self):
		return self._second_angle
	@second_angle.setter
	def second_angle(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,plane_angle_measure):
			self._second_angle = plane_angle_measure(value)
		else:
			self._second_angle = value

	@property
	def depth(self):
		return self._depth
	@depth.setter
	def depth(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,toleranced_length_measure):
				self._depth = toleranced_length_measure(value)
			else:
				self._depth = value
		else:
			self._depth = value

####################
 # ENTITY bidirectional_contour #
####################
class bidirectional_contour(two5d_milling_strategy):
	'''Entity bidirectional_contour definition.

	:param feed_direction
	:type feed_direction:direction

	:param stepover_direction
	:type stepover_direction:left_or_right

	:param rotation_direction
	:type rotation_direction:rot_direction

	:param spiral_cutmode
	:type spiral_cutmode:cutmode_type
	'''
	def __init__( self , inherited0__overlap , inherited1__allow_multiple_passes , feed_direction,stepover_direction,rotation_direction,spiral_cutmode, ):
		two5d_milling_strategy.__init__(self , inherited0__overlap , inherited1__allow_multiple_passes , )
		self._feed_direction = feed_direction
		self._stepover_direction = stepover_direction
		self._rotation_direction = rotation_direction
		self._spiral_cutmode = spiral_cutmode

	@property
	def feed_direction(self):
		return self._feed_direction
	@feed_direction.setter
	def feed_direction(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,direction):
				self._feed_direction = direction(value)
			else:
				self._feed_direction = value
		else:
			self._feed_direction = value

	@property
	def stepover_direction(self):
		return self._stepover_direction
	@stepover_direction.setter
	def stepover_direction(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,left_or_right):
				self._stepover_direction = left_or_right(value)
			else:
				self._stepover_direction = value
		else:
			self._stepover_direction = value

	@property
	def rotation_direction(self):
		return self._rotation_direction
	@rotation_direction.setter
	def rotation_direction(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,rot_direction):
				self._rotation_direction = rot_direction(value)
			else:
				self._rotation_direction = value
		else:
			self._rotation_direction = value

	@property
	def spiral_cutmode(self):
		return self._spiral_cutmode
	@spiral_cutmode.setter
	def spiral_cutmode(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,cutmode_type):
				self._spiral_cutmode = cutmode_type(value)
			else:
				self._spiral_cutmode = value
		else:
			self._spiral_cutmode = value

####################
 # ENTITY curved_distance_dimension #
####################
class curved_distance_dimension(location_dimension):
	'''Entity curved_distance_dimension definition.

	:param used_path
	:type used_path:measurement_path
	'''
	def __init__( self , inherited0__id , inherited1__dimension_value , inherited2__notes , inherited3__description , inherited4__directed , inherited5__origin , inherited6__target , used_path, ):
		location_dimension.__init__(self , inherited0__id , inherited1__dimension_value , inherited2__notes , inherited3__description , inherited4__directed , inherited5__origin , inherited6__target , )
		self._used_path = used_path

	@property
	def used_path(self):
		return self._used_path
	@used_path.setter
	def used_path(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,measurement_path):
			self._used_path = measurement_path(value)
		else:
			self._used_path = value

####################
 # ENTITY externally_defined_representation #
####################
class externally_defined_representation(BaseEntityClass):
	'''Entity externally_defined_representation definition.

	:param identified_by
	:type identified_by:library_part_assignment

	:param location
	:type location:cartesian_point

	:param placement
	:type placement:axis_placement
	'''
	def __init__( self , identified_by,location,placement, ):
		self._identified_by = identified_by
		self._location = location
		self._placement = placement

	@property
	def identified_by(self):
		return self._identified_by
	@identified_by.setter
	def identified_by(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,library_part_assignment):
			self._identified_by = library_part_assignment(value)
		else:
			self._identified_by = value

	@property
	def location(self):
		return self._location
	@location.setter
	def location(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,cartesian_point):
				self._location = cartesian_point(value)
			else:
				self._location = value
		else:
			self._location = value

	@property
	def placement(self):
		return self._placement
	@placement.setter
	def placement(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,axis_placement):
				self._placement = axis_placement(value)
			else:
				self._placement = value
		else:
			self._placement = value

####################
 # ENTITY rectangular_closed_profile #
####################
class rectangular_closed_profile(closed_profile):
	'''Entity rectangular_closed_profile definition.

	:param profile_width
	:type profile_width:toleranced_length_measure

	:param profile_length
	:type profile_length:toleranced_length_measure
	'''
	def __init__( self , inherited0__placement , profile_width,profile_length, ):
		closed_profile.__init__(self , inherited0__placement , )
		self._profile_width = profile_width
		self._profile_length = profile_length

	@property
	def profile_width(self):
		return self._profile_width
	@profile_width.setter
	def profile_width(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,toleranced_length_measure):
			self._profile_width = toleranced_length_measure(value)
		else:
			self._profile_width = value

	@property
	def profile_length(self):
		return self._profile_length
	@profile_length.setter
	def profile_length(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,toleranced_length_measure):
			self._profile_length = toleranced_length_measure(value)
		else:
			self._profile_length = value

####################
 # ENTITY leading_line_strategy #
####################
class leading_line_strategy(freeform_strategy):
	'''Entity leading_line_strategy definition.

	:param its_line
	:type its_line:bounded_curve
	'''
	def __init__( self , inherited0__pathmode , inherited1__cutmode , inherited2__its_milling_tolerances , inherited3__stepover , its_line, ):
		freeform_strategy.__init__(self , inherited0__pathmode , inherited1__cutmode , inherited2__its_milling_tolerances , inherited3__stepover , )
		self._its_line = its_line

	@property
	def its_line(self):
		return self._its_line
	@its_line.setter
	def its_line(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,bounded_curve):
			self._its_line = bounded_curve(value)
		else:
			self._its_line = value

####################
 # ENTITY trajectory #
####################
class trajectory(toolpath):
	'''Entity trajectory definition.

	:param its_direction
	:type its_direction:BOOLEAN

	:param its_material_removal_depth
	:type its_material_removal_depth:material_removal_measure

	:param its_material_removal_overcut
	:type its_material_removal_overcut:material_removal_measure

	:param its_material_removal_total_volume
	:type its_material_removal_total_volume:volume_measure
	'''
	def __init__( self , inherited0__its_priority , inherited1__its_type , inherited2__its_speed , inherited3__its_technology , inherited4__its_machine_functions , inherited5__its_id , its_direction,its_material_removal_depth,its_material_removal_overcut,its_material_removal_total_volume, ):
		toolpath.__init__(self , inherited0__its_priority , inherited1__its_type , inherited2__its_speed , inherited3__its_technology , inherited4__its_machine_functions , inherited5__its_id , )
		self._its_direction = its_direction
		self._its_material_removal_depth = its_material_removal_depth
		self._its_material_removal_overcut = its_material_removal_overcut
		self._its_material_removal_total_volume = its_material_removal_total_volume

	@property
	def its_direction(self):
		return self._its_direction
	@its_direction.setter
	def its_direction(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,BOOLEAN):
				self._its_direction = BOOLEAN(value)
			else:
				self._its_direction = value
		else:
			self._its_direction = value

	@property
	def its_material_removal_depth(self):
		return self._its_material_removal_depth
	@its_material_removal_depth.setter
	def its_material_removal_depth(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,material_removal_measure):
				self._its_material_removal_depth = material_removal_measure(value)
			else:
				self._its_material_removal_depth = value
		else:
			self._its_material_removal_depth = value

	@property
	def its_material_removal_overcut(self):
		return self._its_material_removal_overcut
	@its_material_removal_overcut.setter
	def its_material_removal_overcut(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,material_removal_measure):
				self._its_material_removal_overcut = material_removal_measure(value)
			else:
				self._its_material_removal_overcut = value
		else:
			self._its_material_removal_overcut = value

	@property
	def its_material_removal_total_volume(self):
		return self._its_material_removal_total_volume
	@its_material_removal_total_volume.setter
	def its_material_removal_total_volume(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,volume_measure):
				self._its_material_removal_total_volume = volume_measure(value)
			else:
				self._its_material_removal_total_volume = value
		else:
			self._its_material_removal_total_volume = value

####################
 # ENTITY cutter_location_trajectory #
####################
class cutter_location_trajectory(trajectory):
	'''Entity cutter_location_trajectory definition.

	:param basiccurve
	:type basiccurve:bounded_curve

	:param its_toolaxis
	:type its_toolaxis:bounded_curve

	:param surface_normal
	:type surface_normal:bounded_curve

	:param path_maximum_deviation
	:type path_maximum_deviation:length_measure

	:param tool_axis_maximum_deviation
	:type tool_axis_maximum_deviation:plane_angle_measure
	'''
	def __init__( self , inherited0__its_priority , inherited1__its_type , inherited2__its_speed , inherited3__its_technology , inherited4__its_machine_functions , inherited5__its_id , inherited6__its_direction , inherited7__its_material_removal_depth , inherited8__its_material_removal_overcut , inherited9__its_material_removal_total_volume , basiccurve,its_toolaxis,surface_normal,path_maximum_deviation,tool_axis_maximum_deviation, ):
		trajectory.__init__(self , inherited0__its_priority , inherited1__its_type , inherited2__its_speed , inherited3__its_technology , inherited4__its_machine_functions , inherited5__its_id , inherited6__its_direction , inherited7__its_material_removal_depth , inherited8__its_material_removal_overcut , inherited9__its_material_removal_total_volume , )
		self._basiccurve = basiccurve
		self._its_toolaxis = its_toolaxis
		self._surface_normal = surface_normal
		self._path_maximum_deviation = path_maximum_deviation
		self._tool_axis_maximum_deviation = tool_axis_maximum_deviation

	@property
	def basiccurve(self):
		return self._basiccurve
	@basiccurve.setter
	def basiccurve(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,bounded_curve):
			self._basiccurve = bounded_curve(value)
		else:
			self._basiccurve = value

	@property
	def its_toolaxis(self):
		return self._its_toolaxis
	@its_toolaxis.setter
	def its_toolaxis(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,bounded_curve):
				self._its_toolaxis = bounded_curve(value)
			else:
				self._its_toolaxis = value
		else:
			self._its_toolaxis = value

	@property
	def surface_normal(self):
		return self._surface_normal
	@surface_normal.setter
	def surface_normal(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,bounded_curve):
				self._surface_normal = bounded_curve(value)
			else:
				self._surface_normal = value
		else:
			self._surface_normal = value

	@property
	def path_maximum_deviation(self):
		return self._path_maximum_deviation
	@path_maximum_deviation.setter
	def path_maximum_deviation(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,length_measure):
				self._path_maximum_deviation = length_measure(value)
			else:
				self._path_maximum_deviation = value
		else:
			self._path_maximum_deviation = value

	@property
	def tool_axis_maximum_deviation(self):
		return self._tool_axis_maximum_deviation
	@tool_axis_maximum_deviation.setter
	def tool_axis_maximum_deviation(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,plane_angle_measure):
				self._tool_axis_maximum_deviation = plane_angle_measure(value)
			else:
				self._tool_axis_maximum_deviation = value
		else:
			self._tool_axis_maximum_deviation = value

####################
 # ENTITY plunge_zigzag #
####################
class plunge_zigzag(plunge_strategy):
	'''Entity plunge_zigzag definition.

	:param angle
	:type angle:plane_angle_measure

	:param width
	:type width:length_measure
	'''
	def __init__( self , inherited0__tool_orientation , angle,width, ):
		plunge_strategy.__init__(self , inherited0__tool_orientation , )
		self._angle = angle
		self._width = width

	@property
	def angle(self):
		return self._angle
	@angle.setter
	def angle(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,plane_angle_measure):
			self._angle = plane_angle_measure(value)
		else:
			self._angle = value

	@property
	def width(self):
		return self._width
	@width.setter
	def width(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,length_measure):
			self._width = length_measure(value)
		else:
			self._width = value

####################
 # ENTITY toleranced_length_measure #
####################
class toleranced_length_measure(value_with_tolerance):
	'''Entity toleranced_length_measure definition.
	'''
	def __init__( self , inherited0__unit , inherited1__value_component , inherited2__limitation , inherited3__significant_digits ,  ):
		value_with_tolerance.__init__(self , inherited0__unit , inherited1__value_component , inherited2__limitation , inherited3__significant_digits , )

####################
 # ENTITY toolpath_list #
####################
class toolpath_list(BaseEntityClass):
	'''Entity toolpath_list definition.

	:param its_list
	:type its_list:LIST(1,None,'toolpath', scope = schema_scope)
	'''
	def __init__( self , its_list, ):
		self._its_list = its_list

	@property
	def its_list(self):
		return self._its_list
	@its_list.setter
	def its_list(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,LIST(1,None,'toolpath', scope = schema_scope)):
			self._its_list = LIST(value)
		else:
			self._its_list = value

####################
 # ENTITY machine_axis_constraint #
####################
class machine_axis_constraint(BaseEntityClass):
	'''Entity machine_axis_constraint definition.

	:param axis_identifier
	:type axis_identifier:STRING

	:param axis_range
	:type axis_range:value_range
	'''
	def __init__( self , axis_identifier,axis_range, ):
		self._axis_identifier = axis_identifier
		self._axis_range = axis_range

	@property
	def axis_identifier(self):
		return self._axis_identifier
	@axis_identifier.setter
	def axis_identifier(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,STRING):
			self._axis_identifier = STRING(value)
		else:
			self._axis_identifier = value

	@property
	def axis_range(self):
		return self._axis_range
	@axis_range.setter
	def axis_range(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,value_range):
			self._axis_range = value_range(value)
		else:
			self._axis_range = value

####################
 # ENTITY length_measure #
####################
class length_measure(value_with_unit):
	'''Entity length_measure definition.
	'''
	def __init__( self , inherited0__unit , inherited1__value_component ,  ):
		value_with_unit.__init__(self , inherited0__unit , inherited1__value_component , )

####################
 # ENTITY approval #
####################
class approval(BaseEntityClass):
	'''Entity approval definition.

	:param status
	:type status:approval_status

	:param purpose
	:type purpose:STRING

	:param planned_date
	:type planned_date:STRING

	:param actual_date
	:type actual_date:STRING
	'''
	def __init__( self , status,purpose,planned_date,actual_date, ):
		self._status = status
		self._purpose = purpose
		self._planned_date = planned_date
		self._actual_date = actual_date

	@property
	def status(self):
		return self._status
	@status.setter
	def status(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,approval_status):
			self._status = approval_status(value)
		else:
			self._status = value

	@property
	def purpose(self):
		return self._purpose
	@purpose.setter
	def purpose(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,STRING):
			self._purpose = STRING(value)
		else:
			self._purpose = value

	@property
	def planned_date(self):
		return self._planned_date
	@planned_date.setter
	def planned_date(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,STRING):
				self._planned_date = STRING(value)
			else:
				self._planned_date = value
		else:
			self._planned_date = value

	@property
	def actual_date(self):
		return self._actual_date
	@actual_date.setter
	def actual_date(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,STRING):
				self._actual_date = STRING(value)
			else:
				self._actual_date = value
		else:
			self._actual_date = value

####################
 # ENTITY general_shape_profile #
####################
class general_shape_profile(shape_profile):
	'''Entity general_shape_profile definition.

	:param profile_boundary
	:type profile_boundary:profile
	'''
	def __init__( self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , inherited5__depth , inherited6__profile_swept_shape , inherited7__floor_condition , inherited8__removal_direction , profile_boundary, ):
		shape_profile.__init__(self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , inherited5__depth , inherited6__profile_swept_shape , inherited7__floor_condition , inherited8__removal_direction , )
		self._profile_boundary = profile_boundary

	@property
	def profile_boundary(self):
		return self._profile_boundary
	@profile_boundary.setter
	def profile_boundary(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,profile):
			self._profile_boundary = profile(value)
		else:
			self._profile_boundary = value

####################
 # ENTITY rapid_movement #
####################
class rapid_movement(workingstep,operation):
	'''Entity rapid_movement definition.
	'''
	def __init__( self , inherited0__its_id , inherited1__its_secplane , inherited2__its_toolpath , inherited3__its_tool_direction ,  ):
		workingstep.__init__(self , inherited0__its_id , inherited1__its_secplane , )
		operation.__init__(self , inherited2__its_toolpath , inherited3__its_tool_direction , )

####################
 # ENTITY cutter_contact_trajectory #
####################
class cutter_contact_trajectory(trajectory):
	'''Entity cutter_contact_trajectory definition.

	:param basiccurve
	:type basiccurve:curve_with_surface_normal

	:param its_toolaxis
	:type its_toolaxis:bounded_curve

	:param its_contact_type
	:type its_contact_type:contact_type

	:param path_maximum_deviation
	:type path_maximum_deviation:length_measure

	:param tool_axis_maximum_deviation
	:type tool_axis_maximum_deviation:plane_angle_measure
	'''
	def __init__( self , inherited0__its_priority , inherited1__its_type , inherited2__its_speed , inherited3__its_technology , inherited4__its_machine_functions , inherited5__its_id , inherited6__its_direction , inherited7__its_material_removal_depth , inherited8__its_material_removal_overcut , inherited9__its_material_removal_total_volume , basiccurve,its_toolaxis,its_contact_type,path_maximum_deviation,tool_axis_maximum_deviation, ):
		trajectory.__init__(self , inherited0__its_priority , inherited1__its_type , inherited2__its_speed , inherited3__its_technology , inherited4__its_machine_functions , inherited5__its_id , inherited6__its_direction , inherited7__its_material_removal_depth , inherited8__its_material_removal_overcut , inherited9__its_material_removal_total_volume , )
		self._basiccurve = basiccurve
		self._its_toolaxis = its_toolaxis
		self._its_contact_type = its_contact_type
		self._path_maximum_deviation = path_maximum_deviation
		self._tool_axis_maximum_deviation = tool_axis_maximum_deviation

	@property
	def basiccurve(self):
		return self._basiccurve
	@basiccurve.setter
	def basiccurve(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,curve_with_surface_normal):
			self._basiccurve = curve_with_surface_normal(value)
		else:
			self._basiccurve = value

	@property
	def its_toolaxis(self):
		return self._its_toolaxis
	@its_toolaxis.setter
	def its_toolaxis(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,bounded_curve):
				self._its_toolaxis = bounded_curve(value)
			else:
				self._its_toolaxis = value
		else:
			self._its_toolaxis = value

	@property
	def its_contact_type(self):
		return self._its_contact_type
	@its_contact_type.setter
	def its_contact_type(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,contact_type):
				self._its_contact_type = contact_type(value)
			else:
				self._its_contact_type = value
		else:
			self._its_contact_type = value

	@property
	def path_maximum_deviation(self):
		return self._path_maximum_deviation
	@path_maximum_deviation.setter
	def path_maximum_deviation(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,length_measure):
				self._path_maximum_deviation = length_measure(value)
			else:
				self._path_maximum_deviation = value
		else:
			self._path_maximum_deviation = value

	@property
	def tool_axis_maximum_deviation(self):
		return self._tool_axis_maximum_deviation
	@tool_axis_maximum_deviation.setter
	def tool_axis_maximum_deviation(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,plane_angle_measure):
				self._tool_axis_maximum_deviation = plane_angle_measure(value)
			else:
				self._tool_axis_maximum_deviation = value
		else:
			self._tool_axis_maximum_deviation = value

####################
 # ENTITY t_slot_mill #
####################
class t_slot_mill(milling_cutting_tool):
	'''Entity t_slot_mill definition.

	:param cutting_width
	:type cutting_width:length_measure
	'''
	def __init__( self , inherited0__its_id , inherited1__its_usage , inherited2__its_cutting_edges , inherited3__overall_assembly_length , inherited4__effective_cutting_diameter , inherited5__maximum_depth_of_cut , inherited6__hand_of_cut , inherited7__coolant_through_tool , inherited8__number_of_effective_teeth , inherited9__edge_radius , cutting_width, ):
		milling_cutting_tool.__init__(self , inherited0__its_id , inherited1__its_usage , inherited2__its_cutting_edges , inherited3__overall_assembly_length , inherited4__effective_cutting_diameter , inherited5__maximum_depth_of_cut , inherited6__hand_of_cut , inherited7__coolant_through_tool , inherited8__number_of_effective_teeth , inherited9__edge_radius , )
		self._cutting_width = cutting_width

	@property
	def cutting_width(self):
		return self._cutting_width
	@cutting_width.setter
	def cutting_width(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,length_measure):
			self._cutting_width = length_measure(value)
		else:
			self._cutting_width = value

####################
 # ENTITY corner_transition #
####################
class corner_transition(BaseEntityClass):
	'''Entity corner_transition definition.

	:param corner_identity
	:type corner_identity:INTEGER

	:param transition
	:type transition:corner_transition_select
	'''
	def __init__( self , corner_identity,transition, ):
		self._corner_identity = corner_identity
		self._transition = transition

	@property
	def corner_identity(self):
		return self._corner_identity
	@corner_identity.setter
	def corner_identity(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,INTEGER):
			self._corner_identity = INTEGER(value)
		else:
			self._corner_identity = value

	@property
	def transition(self):
		return self._transition
	@transition.setter
	def transition(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,corner_transition_select):
			self._transition = corner_transition_select(value)
		else:
			self._transition = value

####################
 # ENTITY thread_drilling #
####################
class thread_drilling(drilling_type_operation):
	'''Entity thread_drilling definition.

	:param helical_movement_on_forward
	:type helical_movement_on_forward:BOOLEAN
	'''
	def __init__( self , inherited0__its_toolpath , inherited1__its_tool_direction , inherited2__its_id , inherited3__retract_plane , inherited4__start_point , inherited5__its_tool , inherited6__its_technology , inherited7__its_machine_functions , inherited8__overcut_length , inherited9__cutting_depth , inherited10__previous_diameter , inherited11__dwell_time_bottom , inherited12__feed_on_retract , inherited13__its_machining_strategy , helical_movement_on_forward, ):
		drilling_type_operation.__init__(self , inherited0__its_toolpath , inherited1__its_tool_direction , inherited2__its_id , inherited3__retract_plane , inherited4__start_point , inherited5__its_tool , inherited6__its_technology , inherited7__its_machine_functions , inherited8__overcut_length , inherited9__cutting_depth , inherited10__previous_diameter , inherited11__dwell_time_bottom , inherited12__feed_on_retract , inherited13__its_machining_strategy , )
		self._helical_movement_on_forward = helical_movement_on_forward

	@property
	def helical_movement_on_forward(self):
		return self._helical_movement_on_forward
	@helical_movement_on_forward.setter
	def helical_movement_on_forward(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,BOOLEAN):
			self._helical_movement_on_forward = BOOLEAN(value)
		else:
			self._helical_movement_on_forward = value

####################
 # ENTITY non_sequential #
####################
class non_sequential(program_structure):
	'''Entity non_sequential definition.

	:param its_elements
	:type its_elements:SET(2,None,'executable', scope = schema_scope)
	'''
	def __init__( self , inherited0__its_id , its_elements, ):
		program_structure.__init__(self , inherited0__its_id , )
		self._its_elements = its_elements

	@property
	def its_elements(self):
		return self._its_elements
	@its_elements.setter
	def its_elements(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(2,None,'executable', scope = schema_scope)):
			self._its_elements = SET(value)
		else:
			self._its_elements = value

####################
 # ENTITY comparison_expression #
####################
class comparison_expression(boolean_expression):
	'''Entity comparison_expression definition.

	:param operand1
	:type operand1:nc_variable

	:param operand2
	:type operand2:rvalue
	'''
	def __init__( self , operand1,operand2, ):
		boolean_expression.__init__(self , )
		self._operand1 = operand1
		self._operand2 = operand2

	@property
	def operand1(self):
		return self._operand1
	@operand1.setter
	def operand1(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,nc_variable):
			self._operand1 = nc_variable(value)
		else:
			self._operand1 = value

	@property
	def operand2(self):
		return self._operand2
	@operand2.setter
	def operand2(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,rvalue):
			self._operand2 = rvalue(value)
		else:
			self._operand2 = value

####################
 # ENTITY comparison_not_equal #
####################
class comparison_not_equal(comparison_expression):
	'''Entity comparison_not_equal definition.
	'''
	def __init__( self , inherited0__operand1 , inherited1__operand2 ,  ):
		comparison_expression.__init__(self , inherited0__operand1 , inherited1__operand2 , )

####################
 # ENTITY surface_profile_tolerance #
####################
class surface_profile_tolerance(geometric_tolerance):
	'''Entity surface_profile_tolerance definition.

	:param reference_datum
	:type reference_datum:SET(0,3,'datum_reference', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__applied_to , inherited2__modification , inherited3__qualifying_note , inherited4__segment_size , inherited5__significant_digits , inherited6__tolerance_value , reference_datum, ):
		geometric_tolerance.__init__(self , inherited0__name , inherited1__applied_to , inherited2__modification , inherited3__qualifying_note , inherited4__segment_size , inherited5__significant_digits , inherited6__tolerance_value , )
		self._reference_datum = reference_datum

	@property
	def reference_datum(self):
		return self._reference_datum
	@reference_datum.setter
	def reference_datum(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(0,3,'datum_reference', scope = schema_scope)):
			self._reference_datum = SET(value)
		else:
			self._reference_datum = value

####################
 # ENTITY connector #
####################
class connector(parameterised_path):
	'''Entity connector definition.
	'''
	def __init__( self , inherited0__its_priority , inherited1__its_type , inherited2__its_speed , inherited3__its_technology , inherited4__its_machine_functions , inherited5__its_id ,  ):
		parameterised_path.__init__(self , inherited0__its_priority , inherited1__its_type , inherited2__its_speed , inherited3__its_technology , inherited4__its_machine_functions , inherited5__its_id , )

####################
 # ENTITY connect_secplane #
####################
class connect_secplane(connector):
	'''Entity connect_secplane definition.

	:param up_dir
	:type up_dir:direction

	:param down_dir
	:type down_dir:direction
	'''
	def __init__( self , inherited0__its_priority , inherited1__its_type , inherited2__its_speed , inherited3__its_technology , inherited4__its_machine_functions , inherited5__its_id , up_dir,down_dir, ):
		connector.__init__(self , inherited0__its_priority , inherited1__its_type , inherited2__its_speed , inherited3__its_technology , inherited4__its_machine_functions , inherited5__its_id , )
		self._up_dir = up_dir
		self._down_dir = down_dir

	@property
	def up_dir(self):
		return self._up_dir
	@up_dir.setter
	def up_dir(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,direction):
				self._up_dir = direction(value)
			else:
				self._up_dir = value
		else:
			self._up_dir = value

	@property
	def down_dir(self):
		return self._down_dir
	@down_dir.setter
	def down_dir(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,direction):
				self._down_dir = direction(value)
			else:
				self._down_dir = value
		else:
			self._down_dir = value

####################
 # ENTITY contouring #
####################
class contouring(turning_machining_operation):
	'''Entity contouring definition.

	:param allowance
	:type allowance:length_measure
	'''
	def __init__( self , inherited0__its_toolpath , inherited1__its_tool_direction , inherited2__its_id , inherited3__retract_plane , inherited4__start_point , inherited5__its_tool , inherited6__its_technology , inherited7__its_machine_functions , inherited8__approach , inherited9__retract , inherited10__its_machining_strategy , allowance, ):
		turning_machining_operation.__init__(self , inherited0__its_toolpath , inherited1__its_tool_direction , inherited2__its_id , inherited3__retract_plane , inherited4__start_point , inherited5__its_tool , inherited6__its_technology , inherited7__its_machine_functions , inherited8__approach , inherited9__retract , inherited10__its_machining_strategy , )
		self._allowance = allowance

	@property
	def allowance(self):
		return self._allowance
	@allowance.setter
	def allowance(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,length_measure):
				self._allowance = length_measure(value)
			else:
				self._allowance = value
		else:
			self._allowance = value

####################
 # ENTITY contouring_finish #
####################
class contouring_finish(contouring):
	'''Entity contouring_finish definition.
	'''
	def __init__( self , inherited0__its_toolpath , inherited1__its_tool_direction , inherited2__its_id , inherited3__retract_plane , inherited4__start_point , inherited5__its_tool , inherited6__its_technology , inherited7__its_machine_functions , inherited8__approach , inherited9__retract , inherited10__its_machining_strategy , inherited11__allowance ,  ):
		contouring.__init__(self , inherited0__its_toolpath , inherited1__its_tool_direction , inherited2__its_id , inherited3__retract_plane , inherited4__start_point , inherited5__its_tool , inherited6__its_technology , inherited7__its_machine_functions , inherited8__approach , inherited9__retract , inherited10__its_machining_strategy , inherited11__allowance , )

####################
 # ENTITY uv_strategy #
####################
class uv_strategy(freeform_strategy):
	'''Entity uv_strategy definition.

	:param forward_direction
	:type forward_direction:direction

	:param sideward_direction
	:type sideward_direction:direction
	'''
	def __init__( self , inherited0__pathmode , inherited1__cutmode , inherited2__its_milling_tolerances , inherited3__stepover , forward_direction,sideward_direction, ):
		freeform_strategy.__init__(self , inherited0__pathmode , inherited1__cutmode , inherited2__its_milling_tolerances , inherited3__stepover , )
		self._forward_direction = forward_direction
		self._sideward_direction = sideward_direction

	@property
	def forward_direction(self):
		return self._forward_direction
	@forward_direction.setter
	def forward_direction(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,direction):
			self._forward_direction = direction(value)
		else:
			self._forward_direction = value

	@property
	def sideward_direction(self):
		return self._sideward_direction
	@sideward_direction.setter
	def sideward_direction(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,direction):
			self._sideward_direction = direction(value)
		else:
			self._sideward_direction = value

####################
 # ENTITY thickness_size_dimension #
####################
class thickness_size_dimension(size_dimension):
	'''Entity thickness_size_dimension definition.

	:param used_path
	:type used_path:measurement_path
	'''
	def __init__( self , inherited0__id , inherited1__dimension_value , inherited2__notes , inherited3__applied_to , inherited4__envelope_principle , used_path, ):
		size_dimension.__init__(self , inherited0__id , inherited1__dimension_value , inherited2__notes , inherited3__applied_to , inherited4__envelope_principle , )
		self._used_path = used_path

	@property
	def used_path(self):
		return self._used_path
	@used_path.setter
	def used_path(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,measurement_path):
				self._used_path = measurement_path(value)
			else:
				self._used_path = value
		else:
			self._used_path = value

####################
 # ENTITY angularity_tolerance #
####################
class angularity_tolerance(geometric_tolerance):
	'''Entity angularity_tolerance definition.

	:param reference_datum
	:type reference_datum:SET(1,2,'datum_reference', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__applied_to , inherited2__modification , inherited3__qualifying_note , inherited4__segment_size , inherited5__significant_digits , inherited6__tolerance_value , reference_datum, ):
		geometric_tolerance.__init__(self , inherited0__name , inherited1__applied_to , inherited2__modification , inherited3__qualifying_note , inherited4__segment_size , inherited5__significant_digits , inherited6__tolerance_value , )
		self._reference_datum = reference_datum

	@property
	def reference_datum(self):
		return self._reference_datum
	@reference_datum.setter
	def reference_datum(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(1,2,'datum_reference', scope = schema_scope)):
			self._reference_datum = SET(value)
		else:
			self._reference_datum = value

####################
 # ENTITY contouring_rough #
####################
class contouring_rough(contouring):
	'''Entity contouring_rough definition.
	'''
	def __init__( self , inherited0__its_toolpath , inherited1__its_tool_direction , inherited2__its_id , inherited3__retract_plane , inherited4__start_point , inherited5__its_tool , inherited6__its_technology , inherited7__its_machine_functions , inherited8__approach , inherited9__retract , inherited10__its_machining_strategy , inherited11__allowance ,  ):
		contouring.__init__(self , inherited0__its_toolpath , inherited1__its_tool_direction , inherited2__its_id , inherited3__retract_plane , inherited4__start_point , inherited5__its_tool , inherited6__its_technology , inherited7__its_machine_functions , inherited8__approach , inherited9__retract , inherited10__its_machining_strategy , inherited11__allowance , )
	def wr1(self):
		eval_wr1_wr = (EXISTS(self.self.allowance)  and  (self.self.allowance  >=  0))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY datum_defined_by_targets #
####################
class datum_defined_by_targets(single_datum):
	'''Entity datum_defined_by_targets definition.

	:param rule_description
	:type rule_description:STRING

	:param defined_by
	:type defined_by:SET(1,None,'datum_target', scope = schema_scope)
	'''
	def __init__( self , inherited0__datum_name , inherited1__modification , rule_description,defined_by, ):
		single_datum.__init__(self , inherited0__datum_name , inherited1__modification , )
		self._rule_description = rule_description
		self._defined_by = defined_by

	@property
	def rule_description(self):
		return self._rule_description
	@rule_description.setter
	def rule_description(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,STRING):
			self._rule_description = STRING(value)
		else:
			self._rule_description = value

	@property
	def defined_by(self):
		return self._defined_by
	@defined_by.setter
	def defined_by(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(1,None,'datum_target', scope = schema_scope)):
			self._defined_by = SET(value)
		else:
			self._defined_by = value

####################
 # ENTITY partial_area_definition #
####################
class partial_area_definition(BaseEntityClass):
	'''Entity partial_area_definition definition.

	:param effective_length
	:type effective_length:length_measure

	:param placement
	:type placement:axis2_placement_3d

	:param maximum_length
	:type maximum_length:length_measure
	'''
	def __init__( self , effective_length,placement,maximum_length, ):
		self._effective_length = effective_length
		self._placement = placement
		self._maximum_length = maximum_length

	@property
	def effective_length(self):
		return self._effective_length
	@effective_length.setter
	def effective_length(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,length_measure):
			self._effective_length = length_measure(value)
		else:
			self._effective_length = value

	@property
	def placement(self):
		return self._placement
	@placement.setter
	def placement(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,axis2_placement_3d):
			self._placement = axis2_placement_3d(value)
		else:
			self._placement = value

	@property
	def maximum_length(self):
		return self._maximum_length
	@maximum_length.setter
	def maximum_length(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,length_measure):
				self._maximum_length = length_measure(value)
			else:
				self._maximum_length = value
		else:
			self._maximum_length = value

####################
 # ENTITY plane_angle_measure #
####################
class plane_angle_measure(value_with_tolerance):
	'''Entity plane_angle_measure definition.
	'''
	def __init__( self , inherited0__unit , inherited1__value_component , inherited2__limitation , inherited3__significant_digits ,  ):
		value_with_tolerance.__init__(self , inherited0__unit , inherited1__value_component , inherited2__limitation , inherited3__significant_digits , )

####################
 # ENTITY grooving_tool #
####################
class grooving_tool(turning_machine_cutting_tool):
	'''Entity grooving_tool definition.

	:param cutting_width
	:type cutting_width:length_measure

	:param maximum_grooving_depth
	:type maximum_grooving_depth:length_measure

	:param corner_radius
	:type corner_radius:length_measure

	:param maximum_axial_grooving_diameter
	:type maximum_axial_grooving_diameter:length_measure

	:param minimum_axial_grooving_diameter
	:type minimum_axial_grooving_diameter:length_measure
	'''
	def __init__( self , inherited0__its_id , inherited1__its_usage , inherited2__functional_length , inherited3__f_dimension , inherited4__minimum_cutting_diameter , inherited5__a_dimension_on_f , inherited6__a_dimension_on_lf , inherited7__cutting_edge , inherited8__hand_of_tool , cutting_width,maximum_grooving_depth,corner_radius,maximum_axial_grooving_diameter,minimum_axial_grooving_diameter, ):
		turning_machine_cutting_tool.__init__(self , inherited0__its_id , inherited1__its_usage , inherited2__functional_length , inherited3__f_dimension , inherited4__minimum_cutting_diameter , inherited5__a_dimension_on_f , inherited6__a_dimension_on_lf , inherited7__cutting_edge , inherited8__hand_of_tool , )
		self._cutting_width = cutting_width
		self._maximum_grooving_depth = maximum_grooving_depth
		self._corner_radius = corner_radius
		self._maximum_axial_grooving_diameter = maximum_axial_grooving_diameter
		self._minimum_axial_grooving_diameter = minimum_axial_grooving_diameter

	@property
	def cutting_width(self):
		return self._cutting_width
	@cutting_width.setter
	def cutting_width(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,length_measure):
			self._cutting_width = length_measure(value)
		else:
			self._cutting_width = value

	@property
	def maximum_grooving_depth(self):
		return self._maximum_grooving_depth
	@maximum_grooving_depth.setter
	def maximum_grooving_depth(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,length_measure):
			self._maximum_grooving_depth = length_measure(value)
		else:
			self._maximum_grooving_depth = value

	@property
	def corner_radius(self):
		return self._corner_radius
	@corner_radius.setter
	def corner_radius(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,length_measure):
				self._corner_radius = length_measure(value)
			else:
				self._corner_radius = value
		else:
			self._corner_radius = value

	@property
	def maximum_axial_grooving_diameter(self):
		return self._maximum_axial_grooving_diameter
	@maximum_axial_grooving_diameter.setter
	def maximum_axial_grooving_diameter(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,length_measure):
				self._maximum_axial_grooving_diameter = length_measure(value)
			else:
				self._maximum_axial_grooving_diameter = value
		else:
			self._maximum_axial_grooving_diameter = value

	@property
	def minimum_axial_grooving_diameter(self):
		return self._minimum_axial_grooving_diameter
	@minimum_axial_grooving_diameter.setter
	def minimum_axial_grooving_diameter(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,length_measure):
				self._minimum_axial_grooving_diameter = length_measure(value)
			else:
				self._minimum_axial_grooving_diameter = value
		else:
			self._minimum_axial_grooving_diameter = value

####################
 # ENTITY spherical_cap #
####################
class spherical_cap(machining_feature):
	'''Entity spherical_cap definition.

	:param internal_angle
	:type internal_angle:numeric_parameter

	:param radius
	:type radius:numeric_parameter
	'''
	def __init__( self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , inherited5__depth , internal_angle,radius, ):
		machining_feature.__init__(self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , inherited5__depth , )
		self._internal_angle = internal_angle
		self._radius = radius

	@property
	def internal_angle(self):
		return self._internal_angle
	@internal_angle.setter
	def internal_angle(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,numeric_parameter):
			self._internal_angle = numeric_parameter(value)
		else:
			self._internal_angle = value

	@property
	def radius(self):
		return self._radius
	@radius.setter
	def radius(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,numeric_parameter):
			self._radius = numeric_parameter(value)
		else:
			self._radius = value

####################
 # ENTITY endmill #
####################
class endmill(milling_cutting_tool):
	'''Entity endmill definition.

	:param tool_cutting_edge_angle
	:type tool_cutting_edge_angle:plane_angle_measure
	'''
	def __init__( self , inherited0__its_id , inherited1__its_usage , inherited2__its_cutting_edges , inherited3__overall_assembly_length , inherited4__effective_cutting_diameter , inherited5__maximum_depth_of_cut , inherited6__hand_of_cut , inherited7__coolant_through_tool , inherited8__number_of_effective_teeth , inherited9__edge_radius , tool_cutting_edge_angle, ):
		milling_cutting_tool.__init__(self , inherited0__its_id , inherited1__its_usage , inherited2__its_cutting_edges , inherited3__overall_assembly_length , inherited4__effective_cutting_diameter , inherited5__maximum_depth_of_cut , inherited6__hand_of_cut , inherited7__coolant_through_tool , inherited8__number_of_effective_teeth , inherited9__edge_radius , )
		self._tool_cutting_edge_angle = tool_cutting_edge_angle

	@property
	def tool_cutting_edge_angle(self):
		return self._tool_cutting_edge_angle
	@tool_cutting_edge_angle.setter
	def tool_cutting_edge_angle(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,plane_angle_measure):
			self._tool_cutting_edge_angle = plane_angle_measure(value)
		else:
			self._tool_cutting_edge_angle = value

####################
 # ENTITY ballnose_endmill #
####################
class ballnose_endmill(endmill):
	'''Entity ballnose_endmill definition.
	'''
	def __init__( self , inherited0__its_id , inherited1__its_usage , inherited2__its_cutting_edges , inherited3__overall_assembly_length , inherited4__effective_cutting_diameter , inherited5__maximum_depth_of_cut , inherited6__hand_of_cut , inherited7__coolant_through_tool , inherited8__number_of_effective_teeth , inherited9__edge_radius , inherited10__tool_cutting_edge_angle ,  ):
		endmill.__init__(self , inherited0__its_id , inherited1__its_usage , inherited2__its_cutting_edges , inherited3__overall_assembly_length , inherited4__effective_cutting_diameter , inherited5__maximum_depth_of_cut , inherited6__hand_of_cut , inherited7__coolant_through_tool , inherited8__number_of_effective_teeth , inherited9__edge_radius , inherited10__tool_cutting_edge_angle , )
	def wr1(self):
		eval_wr1_wr = (( not EXISTS(self.self.edge_radius))  or  ((EXISTS(self.self.edge_radius)  and  EXISTS(self.self.effective_cutting_diameter))  and  (self.self.edge_radius  ==  (self.self.effective_cutting_diameter / 2))))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY machine_parameters #
####################
class machine_parameters(BaseEntityClass):
	'''Entity machine_parameters definition.

	:param feedrate
	:type feedrate:speed_measure

	:param spindle_speed
	:type spindle_speed:rot_speed_measure

	:param spindle_power
	:type spindle_power:value_with_unit

	:param spindle_torque
	:type spindle_torque:value_with_unit

	:param number_of_control_axis
	:type number_of_control_axis:INTEGER

	:param number_of_simultaneous_axis
	:type number_of_simultaneous_axis:INTEGER

	:param positioning_accuracy
	:type positioning_accuracy:length_measure

	:param table_indexing
	:type table_indexing:BOOLEAN

	:param table_length
	:type table_length:length_measure

	:param table_width
	:type table_width:length_measure

	:param axis_travel
	:type axis_travel:SET(0,None,'machine_axis_travel', scope = schema_scope)

	:param work_volume_length
	:type work_volume_length:length_measure

	:param work_volume_width
	:type work_volume_width:length_measure

	:param work_volume_height
	:type work_volume_height:length_measure
	'''
	def __init__( self , feedrate,spindle_speed,spindle_power,spindle_torque,number_of_control_axis,number_of_simultaneous_axis,positioning_accuracy,table_indexing,table_length,table_width,axis_travel,work_volume_length,work_volume_width,work_volume_height, ):
		self._feedrate = feedrate
		self._spindle_speed = spindle_speed
		self._spindle_power = spindle_power
		self._spindle_torque = spindle_torque
		self._number_of_control_axis = number_of_control_axis
		self._number_of_simultaneous_axis = number_of_simultaneous_axis
		self._positioning_accuracy = positioning_accuracy
		self._table_indexing = table_indexing
		self._table_length = table_length
		self._table_width = table_width
		self._axis_travel = axis_travel
		self._work_volume_length = work_volume_length
		self._work_volume_width = work_volume_width
		self._work_volume_height = work_volume_height

	@property
	def feedrate(self):
		return self._feedrate
	@feedrate.setter
	def feedrate(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,speed_measure):
				self._feedrate = speed_measure(value)
			else:
				self._feedrate = value
		else:
			self._feedrate = value

	@property
	def spindle_speed(self):
		return self._spindle_speed
	@spindle_speed.setter
	def spindle_speed(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,rot_speed_measure):
				self._spindle_speed = rot_speed_measure(value)
			else:
				self._spindle_speed = value
		else:
			self._spindle_speed = value

	@property
	def spindle_power(self):
		return self._spindle_power
	@spindle_power.setter
	def spindle_power(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,value_with_unit):
				self._spindle_power = value_with_unit(value)
			else:
				self._spindle_power = value
		else:
			self._spindle_power = value

	@property
	def spindle_torque(self):
		return self._spindle_torque
	@spindle_torque.setter
	def spindle_torque(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,value_with_unit):
				self._spindle_torque = value_with_unit(value)
			else:
				self._spindle_torque = value
		else:
			self._spindle_torque = value

	@property
	def number_of_control_axis(self):
		return self._number_of_control_axis
	@number_of_control_axis.setter
	def number_of_control_axis(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,INTEGER):
				self._number_of_control_axis = INTEGER(value)
			else:
				self._number_of_control_axis = value
		else:
			self._number_of_control_axis = value

	@property
	def number_of_simultaneous_axis(self):
		return self._number_of_simultaneous_axis
	@number_of_simultaneous_axis.setter
	def number_of_simultaneous_axis(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,INTEGER):
				self._number_of_simultaneous_axis = INTEGER(value)
			else:
				self._number_of_simultaneous_axis = value
		else:
			self._number_of_simultaneous_axis = value

	@property
	def positioning_accuracy(self):
		return self._positioning_accuracy
	@positioning_accuracy.setter
	def positioning_accuracy(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,length_measure):
				self._positioning_accuracy = length_measure(value)
			else:
				self._positioning_accuracy = value
		else:
			self._positioning_accuracy = value

	@property
	def table_indexing(self):
		return self._table_indexing
	@table_indexing.setter
	def table_indexing(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,BOOLEAN):
				self._table_indexing = BOOLEAN(value)
			else:
				self._table_indexing = value
		else:
			self._table_indexing = value

	@property
	def table_length(self):
		return self._table_length
	@table_length.setter
	def table_length(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,length_measure):
				self._table_length = length_measure(value)
			else:
				self._table_length = value
		else:
			self._table_length = value

	@property
	def table_width(self):
		return self._table_width
	@table_width.setter
	def table_width(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,length_measure):
				self._table_width = length_measure(value)
			else:
				self._table_width = value
		else:
			self._table_width = value

	@property
	def axis_travel(self):
		return self._axis_travel
	@axis_travel.setter
	def axis_travel(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(0,None,'machine_axis_travel', scope = schema_scope)):
			self._axis_travel = SET(value)
		else:
			self._axis_travel = value

	@property
	def work_volume_length(self):
		return self._work_volume_length
	@work_volume_length.setter
	def work_volume_length(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,length_measure):
				self._work_volume_length = length_measure(value)
			else:
				self._work_volume_length = value
		else:
			self._work_volume_length = value

	@property
	def work_volume_width(self):
		return self._work_volume_width
	@work_volume_width.setter
	def work_volume_width(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,length_measure):
				self._work_volume_width = length_measure(value)
			else:
				self._work_volume_width = value
		else:
			self._work_volume_width = value

	@property
	def work_volume_height(self):
		return self._work_volume_height
	@work_volume_height.setter
	def work_volume_height(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,length_measure):
				self._work_volume_height = length_measure(value)
			else:
				self._work_volume_height = value
		else:
			self._work_volume_height = value
	def wr1(self):
		eval_wr1_wr = ((0  ==  SIZEOF(self.axis_travel))  or  ((( not EXISTS(self.work_volume_length))  and  ( not EXISTS(self.work_volume_width)))  and  ( not EXISTS(self.work_volume_length))))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY plane_milling #
####################
class plane_milling(two5d_milling_operation):
	'''Entity plane_milling definition.

	:param axial_cutting_depth
	:type axial_cutting_depth:length_measure

	:param allowance_bottom
	:type allowance_bottom:length_measure
	'''
	def __init__( self , inherited0__its_toolpath , inherited1__its_tool_direction , inherited2__its_id , inherited3__retract_plane , inherited4__start_point , inherited5__its_tool , inherited6__its_technology , inherited7__its_machine_functions , inherited8__overcut_length , inherited9__approach , inherited10__retract , inherited11__its_machining_strategy , axial_cutting_depth,allowance_bottom, ):
		two5d_milling_operation.__init__(self , inherited0__its_toolpath , inherited1__its_tool_direction , inherited2__its_id , inherited3__retract_plane , inherited4__start_point , inherited5__its_tool , inherited6__its_technology , inherited7__its_machine_functions , inherited8__overcut_length , inherited9__approach , inherited10__retract , inherited11__its_machining_strategy , )
		self._axial_cutting_depth = axial_cutting_depth
		self._allowance_bottom = allowance_bottom

	@property
	def axial_cutting_depth(self):
		return self._axial_cutting_depth
	@axial_cutting_depth.setter
	def axial_cutting_depth(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,length_measure):
				self._axial_cutting_depth = length_measure(value)
			else:
				self._axial_cutting_depth = value
		else:
			self._axial_cutting_depth = value

	@property
	def allowance_bottom(self):
		return self._allowance_bottom
	@allowance_bottom.setter
	def allowance_bottom(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,length_measure):
				self._allowance_bottom = length_measure(value)
			else:
				self._allowance_bottom = value
		else:
			self._allowance_bottom = value

####################
 # ENTITY plus_minus_value #
####################
class plus_minus_value(BaseEntityClass):
	'''Entity plus_minus_value definition.

	:param lower_limit
	:type lower_limit:(null)

	:param upper_limit
	:type upper_limit:(null)
	'''
	def __init__( self , lower_limit,upper_limit, ):
		self._lower_limit = lower_limit
		self._upper_limit = upper_limit

	@property
	def lower_limit(self):
		return self._lower_limit
	@lower_limit.setter
	def lower_limit(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,(null)):
			self._lower_limit = (null)(value)
		else:
			self._lower_limit = value

	@property
	def upper_limit(self):
		return self._upper_limit
	@upper_limit.setter
	def upper_limit(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,(null)):
			self._upper_limit = (null)(value)
		else:
			self._upper_limit = value

####################
 # ENTITY workpiece_complete_probing #
####################
class workpiece_complete_probing(touch_probing):
	'''Entity workpiece_complete_probing definition.

	:param its_workpiece
	:type its_workpiece:workpiece

	:param probing_distance
	:type probing_distance:toleranced_length_measure

	:param its_probe
	:type its_probe:touch_probe

	:param computed_offset
	:type computed_offset:offset_vector
	'''
	def __init__( self , inherited0__its_id , inherited1__its_secplane , inherited2__its_toolpath , inherited3__its_tool_direction , inherited4__measured_offset , its_workpiece,probing_distance,its_probe,computed_offset, ):
		touch_probing.__init__(self , inherited0__its_id , inherited1__its_secplane , inherited2__its_toolpath , inherited3__its_tool_direction , inherited4__measured_offset , )
		self._its_workpiece = its_workpiece
		self._probing_distance = probing_distance
		self._its_probe = its_probe
		self._computed_offset = computed_offset

	@property
	def its_workpiece(self):
		return self._its_workpiece
	@its_workpiece.setter
	def its_workpiece(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,workpiece):
			self._its_workpiece = workpiece(value)
		else:
			self._its_workpiece = value

	@property
	def probing_distance(self):
		return self._probing_distance
	@probing_distance.setter
	def probing_distance(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,toleranced_length_measure):
			self._probing_distance = toleranced_length_measure(value)
		else:
			self._probing_distance = value

	@property
	def its_probe(self):
		return self._its_probe
	@its_probe.setter
	def its_probe(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,touch_probe):
			self._its_probe = touch_probe(value)
		else:
			self._its_probe = value

	@property
	def computed_offset(self):
		return self._computed_offset
	@computed_offset.setter
	def computed_offset(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,offset_vector):
			self._computed_offset = offset_vector(value)
		else:
			self._computed_offset = value

####################
 # ENTITY rectangular_pattern #
####################
class rectangular_pattern(replicate_feature):
	'''Entity rectangular_pattern definition.

	:param spacing
	:type spacing:toleranced_length_measure

	:param its_direction
	:type its_direction:direction

	:param number_of_rows
	:type number_of_rows:INTEGER

	:param number_of_columns
	:type number_of_columns:INTEGER

	:param row_spacing
	:type row_spacing:toleranced_length_measure

	:param row_layout_direction
	:type row_layout_direction:direction

	:param relocated_base_feature
	:type relocated_base_feature:SET(0,None,'rectangular_offset', scope = schema_scope)

	:param missing_base_feature
	:type missing_base_feature:SET(0,None,'rectangular_omit', scope = schema_scope)
	'''
	def __init__( self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , inherited5__replicate_base_feature , spacing,its_direction,number_of_rows,number_of_columns,row_spacing,row_layout_direction,relocated_base_feature,missing_base_feature, ):
		replicate_feature.__init__(self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , inherited5__replicate_base_feature , )
		self._spacing = spacing
		self._its_direction = its_direction
		self._number_of_rows = number_of_rows
		self._number_of_columns = number_of_columns
		self._row_spacing = row_spacing
		self._row_layout_direction = row_layout_direction
		self._relocated_base_feature = relocated_base_feature
		self._missing_base_feature = missing_base_feature

	@property
	def spacing(self):
		return self._spacing
	@spacing.setter
	def spacing(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,toleranced_length_measure):
			self._spacing = toleranced_length_measure(value)
		else:
			self._spacing = value

	@property
	def its_direction(self):
		return self._its_direction
	@its_direction.setter
	def its_direction(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,direction):
			self._its_direction = direction(value)
		else:
			self._its_direction = value

	@property
	def number_of_rows(self):
		return self._number_of_rows
	@number_of_rows.setter
	def number_of_rows(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,INTEGER):
				self._number_of_rows = INTEGER(value)
			else:
				self._number_of_rows = value
		else:
			self._number_of_rows = value

	@property
	def number_of_columns(self):
		return self._number_of_columns
	@number_of_columns.setter
	def number_of_columns(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,INTEGER):
			self._number_of_columns = INTEGER(value)
		else:
			self._number_of_columns = value

	@property
	def row_spacing(self):
		return self._row_spacing
	@row_spacing.setter
	def row_spacing(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,toleranced_length_measure):
				self._row_spacing = toleranced_length_measure(value)
			else:
				self._row_spacing = value
		else:
			self._row_spacing = value

	@property
	def row_layout_direction(self):
		return self._row_layout_direction
	@row_layout_direction.setter
	def row_layout_direction(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,direction):
				self._row_layout_direction = direction(value)
			else:
				self._row_layout_direction = value
		else:
			self._row_layout_direction = value

	@property
	def relocated_base_feature(self):
		return self._relocated_base_feature
	@relocated_base_feature.setter
	def relocated_base_feature(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(0,None,'rectangular_offset', scope = schema_scope)):
			self._relocated_base_feature = SET(value)
		else:
			self._relocated_base_feature = value

	@property
	def missing_base_feature(self):
		return self._missing_base_feature
	@missing_base_feature.setter
	def missing_base_feature(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(0,None,'rectangular_omit', scope = schema_scope)):
			self._missing_base_feature = SET(value)
		else:
			self._missing_base_feature = value
	def wr1(self):
		eval_wr1_wr = (((self.self.number_of_rows  >  1)  and  EXISTS(self.self.row_spacing))  and  EXISTS(self.self.row_layout_direction))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY region #
####################
class region(manufacturing_feature):
	'''Entity region definition.

	:param feature_placement
	:type feature_placement:axis2_placement_3d
	'''
	def __init__( self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , feature_placement, ):
		manufacturing_feature.__init__(self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , )
		self._feature_placement = feature_placement

	@property
	def feature_placement(self):
		return self._feature_placement
	@feature_placement.setter
	def feature_placement(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,axis2_placement_3d):
				self._feature_placement = axis2_placement_3d(value)
			else:
				self._feature_placement = value
		else:
			self._feature_placement = value

####################
 # ENTITY slot_end_type #
####################
class slot_end_type(BaseEntityClass):
	'''Entity slot_end_type definition.
	'''
	# This class does not define any attribute.
	pass

####################
 # ENTITY open_slot_end_type #
####################
class open_slot_end_type(slot_end_type):
	'''Entity open_slot_end_type definition.
	'''
	def __init__( self ,  ):
		slot_end_type.__init__(self , )

####################
 # ENTITY rectangular_open_shape_profile #
####################
class rectangular_open_shape_profile(shape_profile):
	'''Entity rectangular_open_shape_profile definition.

	:param open_boundary
	:type open_boundary:square_u_profile
	'''
	def __init__( self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , inherited5__depth , inherited6__profile_swept_shape , inherited7__floor_condition , inherited8__removal_direction , open_boundary, ):
		shape_profile.__init__(self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , inherited5__depth , inherited6__profile_swept_shape , inherited7__floor_condition , inherited8__removal_direction , )
		self._open_boundary = open_boundary

	@property
	def open_boundary(self):
		return self._open_boundary
	@open_boundary.setter
	def open_boundary(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,square_u_profile):
			self._open_boundary = square_u_profile(value)
		else:
			self._open_boundary = value

####################
 # ENTITY compound_feature #
####################
class compound_feature(two5d_manufacturing_feature):
	'''Entity compound_feature definition.

	:param elements
	:type elements:SET(2,None,'compound_feature_select', scope = schema_scope)

	:param feature_description
	:type feature_description:text

	:param feature_name
	:type feature_name:label
	'''
	def __init__( self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , elements,feature_description,feature_name, ):
		two5d_manufacturing_feature.__init__(self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , )
		self._elements = elements
		self._feature_description = feature_description
		self._feature_name = feature_name

	@property
	def elements(self):
		return self._elements
	@elements.setter
	def elements(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(2,None,'compound_feature_select', scope = schema_scope)):
			self._elements = SET(value)
		else:
			self._elements = value

	@property
	def feature_description(self):
		return self._feature_description
	@feature_description.setter
	def feature_description(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,text):
				self._feature_description = text(value)
			else:
				self._feature_description = value
		else:
			self._feature_description = value

	@property
	def feature_name(self):
		return self._feature_name
	@feature_name.setter
	def feature_name(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,label):
			self._feature_name = label(value)
		else:
			self._feature_name = value
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY comparison_greater #
####################
class comparison_greater(comparison_expression):
	'''Entity comparison_greater definition.
	'''
	def __init__( self , inherited0__operand1 , inherited1__operand2 ,  ):
		comparison_expression.__init__(self , inherited0__operand1 , inherited1__operand2 , )

####################
 # ENTITY pocket_bottom_condition #
####################
class pocket_bottom_condition(BaseEntityClass):
	'''Entity pocket_bottom_condition definition.
	'''
	# This class does not define any attribute.
	pass

####################
 # ENTITY radiused_pocket_bottom_condition #
####################
class radiused_pocket_bottom_condition(pocket_bottom_condition):
	'''Entity radiused_pocket_bottom_condition definition.

	:param floor_radius_center
	:type floor_radius_center:cartesian_point

	:param floor_radius
	:type floor_radius:toleranced_length_measure
	'''
	def __init__( self , floor_radius_center,floor_radius, ):
		pocket_bottom_condition.__init__(self , )
		self._floor_radius_center = floor_radius_center
		self._floor_radius = floor_radius

	@property
	def floor_radius_center(self):
		return self._floor_radius_center
	@floor_radius_center.setter
	def floor_radius_center(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,cartesian_point):
			self._floor_radius_center = cartesian_point(value)
		else:
			self._floor_radius_center = value

	@property
	def floor_radius(self):
		return self._floor_radius
	@floor_radius.setter
	def floor_radius(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,toleranced_length_measure):
			self._floor_radius = toleranced_length_measure(value)
		else:
			self._floor_radius = value

####################
 # ENTITY blind_bottom_condition #
####################
class blind_bottom_condition(hole_bottom_condition):
	'''Entity blind_bottom_condition definition.
	'''
	def __init__( self ,  ):
		hole_bottom_condition.__init__(self , )

####################
 # ENTITY conical_hole_bottom #
####################
class conical_hole_bottom(blind_bottom_condition):
	'''Entity conical_hole_bottom definition.

	:param tip_angle
	:type tip_angle:plane_angle_measure

	:param tip_radius
	:type tip_radius:toleranced_length_measure
	'''
	def __init__( self , tip_angle,tip_radius, ):
		blind_bottom_condition.__init__(self , )
		self._tip_angle = tip_angle
		self._tip_radius = tip_radius

	@property
	def tip_angle(self):
		return self._tip_angle
	@tip_angle.setter
	def tip_angle(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,plane_angle_measure):
			self._tip_angle = plane_angle_measure(value)
		else:
			self._tip_angle = value

	@property
	def tip_radius(self):
		return self._tip_radius
	@tip_radius.setter
	def tip_radius(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,toleranced_length_measure):
				self._tip_radius = toleranced_length_measure(value)
			else:
				self._tip_radius = value
		else:
			self._tip_radius = value

####################
 # ENTITY transition_feature #
####################
class transition_feature(manufacturing_feature):
	'''Entity transition_feature definition.

	:param first_feature
	:type first_feature:machining_feature

	:param second_feature
	:type second_feature:machining_feature
	'''
	def __init__( self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , first_feature,second_feature, ):
		manufacturing_feature.__init__(self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , )
		self._first_feature = first_feature
		self._second_feature = second_feature

	@property
	def first_feature(self):
		return self._first_feature
	@first_feature.setter
	def first_feature(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,machining_feature):
				self._first_feature = machining_feature(value)
			else:
				self._first_feature = value
		else:
			self._first_feature = value

	@property
	def second_feature(self):
		return self._second_feature
	@second_feature.setter
	def second_feature(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,machining_feature):
				self._second_feature = machining_feature(value)
			else:
				self._second_feature = value
		else:
			self._second_feature = value

####################
 # ENTITY selective #
####################
class selective(program_structure):
	'''Entity selective definition.

	:param its_elements
	:type its_elements:SET(2,None,'executable', scope = schema_scope)
	'''
	def __init__( self , inherited0__its_id , its_elements, ):
		program_structure.__init__(self , inherited0__its_id , )
		self._its_elements = its_elements

	@property
	def its_elements(self):
		return self._its_elements
	@its_elements.setter
	def its_elements(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(2,None,'executable', scope = schema_scope)):
			self._its_elements = SET(value)
		else:
			self._its_elements = value

####################
 # ENTITY rounded_end #
####################
class rounded_end(machining_feature):
	'''Entity rounded_end definition.

	:param course_of_travel
	:type course_of_travel:linear_path

	:param partial_circular_boundary
	:type partial_circular_boundary:partial_circular_profile
	'''
	def __init__( self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , inherited5__depth , course_of_travel,partial_circular_boundary, ):
		machining_feature.__init__(self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , inherited5__depth , )
		self._course_of_travel = course_of_travel
		self._partial_circular_boundary = partial_circular_boundary

	@property
	def course_of_travel(self):
		return self._course_of_travel
	@course_of_travel.setter
	def course_of_travel(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,linear_path):
			self._course_of_travel = linear_path(value)
		else:
			self._course_of_travel = value

	@property
	def partial_circular_boundary(self):
		return self._partial_circular_boundary
	@partial_circular_boundary.setter
	def partial_circular_boundary(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,partial_circular_profile):
			self._partial_circular_boundary = partial_circular_profile(value)
		else:
			self._partial_circular_boundary = value

####################
 # ENTITY tool_direction_for_milling #
####################
class tool_direction_for_milling(tool_direction):
	'''Entity tool_direction_for_milling definition.
	'''
	def __init__( self ,  ):
		tool_direction.__init__(self , )

####################
 # ENTITY part_property #
####################
class part_property(general_property):
	'''Entity part_property definition.

	:param part_characteristics
	:type part_characteristics:SET(0,None,'property_parameter', scope = schema_scope)
	'''
	def __init__( self , inherited0__description , inherited1__owner , inherited2__related_properties , inherited3__specifications , part_characteristics, ):
		general_property.__init__(self , inherited0__description , inherited1__owner , inherited2__related_properties , inherited3__specifications , )
		self._part_characteristics = part_characteristics

	@property
	def part_characteristics(self):
		return self._part_characteristics
	@part_characteristics.setter
	def part_characteristics(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(0,None,'property_parameter', scope = schema_scope)):
			self._part_characteristics = SET(value)
		else:
			self._part_characteristics = value

####################
 # ENTITY workpiece_probing #
####################
class workpiece_probing(touch_probing):
	'''Entity workpiece_probing definition.

	:param start_position
	:type start_position:axis2_placement_3d

	:param its_workpiece
	:type its_workpiece:workpiece

	:param its_direction
	:type its_direction:direction

	:param expected_value
	:type expected_value:toleranced_length_measure

	:param its_probe
	:type its_probe:touch_probe
	'''
	def __init__( self , inherited0__its_id , inherited1__its_secplane , inherited2__its_toolpath , inherited3__its_tool_direction , inherited4__measured_offset , start_position,its_workpiece,its_direction,expected_value,its_probe, ):
		touch_probing.__init__(self , inherited0__its_id , inherited1__its_secplane , inherited2__its_toolpath , inherited3__its_tool_direction , inherited4__measured_offset , )
		self._start_position = start_position
		self._its_workpiece = its_workpiece
		self._its_direction = its_direction
		self._expected_value = expected_value
		self._its_probe = its_probe

	@property
	def start_position(self):
		return self._start_position
	@start_position.setter
	def start_position(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,axis2_placement_3d):
			self._start_position = axis2_placement_3d(value)
		else:
			self._start_position = value

	@property
	def its_workpiece(self):
		return self._its_workpiece
	@its_workpiece.setter
	def its_workpiece(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,workpiece):
			self._its_workpiece = workpiece(value)
		else:
			self._its_workpiece = value

	@property
	def its_direction(self):
		return self._its_direction
	@its_direction.setter
	def its_direction(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,direction):
			self._its_direction = direction(value)
		else:
			self._its_direction = value

	@property
	def expected_value(self):
		return self._expected_value
	@expected_value.setter
	def expected_value(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,toleranced_length_measure):
			self._expected_value = toleranced_length_measure(value)
		else:
			self._expected_value = value

	@property
	def its_probe(self):
		return self._its_probe
	@its_probe.setter
	def its_probe(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,touch_probe):
			self._its_probe = touch_probe(value)
		else:
			self._its_probe = value

####################
 # ENTITY exchange_pallet #
####################
class exchange_pallet(nc_function):
	'''Entity exchange_pallet definition.
	'''
	def __init__( self , inherited0__its_id ,  ):
		nc_function.__init__(self , inherited0__its_id , )

####################
 # ENTITY plane_finish_milling #
####################
class plane_finish_milling(plane_milling):
	'''Entity plane_finish_milling definition.
	'''
	def __init__( self , inherited0__its_toolpath , inherited1__its_tool_direction , inherited2__its_id , inherited3__retract_plane , inherited4__start_point , inherited5__its_tool , inherited6__its_technology , inherited7__its_machine_functions , inherited8__overcut_length , inherited9__approach , inherited10__retract , inherited11__its_machining_strategy , inherited12__axial_cutting_depth , inherited13__allowance_bottom ,  ):
		plane_milling.__init__(self , inherited0__its_toolpath , inherited1__its_tool_direction , inherited2__its_id , inherited3__retract_plane , inherited4__start_point , inherited5__its_tool , inherited6__its_technology , inherited7__its_machine_functions , inherited8__overcut_length , inherited9__approach , inherited10__retract , inherited11__its_machining_strategy , inherited12__axial_cutting_depth , inherited13__allowance_bottom , )

####################
 # ENTITY descriptive_parameter #
####################
class descriptive_parameter(property_parameter):
	'''Entity descriptive_parameter definition.

	:param descriptive_string
	:type descriptive_string:text
	'''
	def __init__( self , inherited0__parameter_name , descriptive_string, ):
		property_parameter.__init__(self , inherited0__parameter_name , )
		self._descriptive_string = descriptive_string

	@property
	def descriptive_string(self):
		return self._descriptive_string
	@descriptive_string.setter
	def descriptive_string(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,text):
			self._descriptive_string = text(value)
		else:
			self._descriptive_string = value

####################
 # ENTITY plunge_ramp #
####################
class plunge_ramp(plunge_strategy):
	'''Entity plunge_ramp definition.

	:param angle
	:type angle:plane_angle_measure
	'''
	def __init__( self , inherited0__tool_orientation , angle, ):
		plunge_strategy.__init__(self , inherited0__tool_orientation , )
		self._angle = angle

	@property
	def angle(self):
		return self._angle
	@angle.setter
	def angle(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,plane_angle_measure):
			self._angle = plane_angle_measure(value)
		else:
			self._angle = value

####################
 # ENTITY revolved_flat #
####################
class revolved_flat(revolved_feature):
	'''Entity revolved_flat definition.

	:param flat_edge_shape
	:type flat_edge_shape:linear_profile
	'''
	def __init__( self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , inherited5__material_side , inherited6__radius , flat_edge_shape, ):
		revolved_feature.__init__(self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , inherited5__material_side , inherited6__radius , )
		self._flat_edge_shape = flat_edge_shape

	@property
	def flat_edge_shape(self):
		return self._flat_edge_shape
	@flat_edge_shape.setter
	def flat_edge_shape(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,linear_profile):
			self._flat_edge_shape = linear_profile(value)
		else:
			self._flat_edge_shape = value

####################
 # ENTITY adaptive_control #
####################
class adaptive_control(BaseEntityClass):
	'''Entity adaptive_control definition.
	'''
	# This class does not define any attribute.
	pass

####################
 # ENTITY tool_usage #
####################
class tool_usage(BaseEntityClass):
	'''Entity tool_usage definition.

	:param its_id
	:type its_id:label

	:param its_position
	:type its_position:identifier

	:param its_carousel
	:type its_carousel:identifier

	:param its_product
	:type its_product:workpiece

	:param its_library_reference
	:type its_library_reference:externally_defined_representation
	'''
	def __init__( self , its_id,its_position,its_carousel,its_product,its_library_reference, ):
		self._its_id = its_id
		self._its_position = its_position
		self._its_carousel = its_carousel
		self._its_product = its_product
		self._its_library_reference = its_library_reference

	@property
	def its_id(self):
		return self._its_id
	@its_id.setter
	def its_id(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,label):
			self._its_id = label(value)
		else:
			self._its_id = value

	@property
	def its_position(self):
		return self._its_position
	@its_position.setter
	def its_position(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,identifier):
				self._its_position = identifier(value)
			else:
				self._its_position = value
		else:
			self._its_position = value

	@property
	def its_carousel(self):
		return self._its_carousel
	@its_carousel.setter
	def its_carousel(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,identifier):
				self._its_carousel = identifier(value)
			else:
				self._its_carousel = value
		else:
			self._its_carousel = value

	@property
	def its_product(self):
		return self._its_product
	@its_product.setter
	def its_product(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,workpiece):
				self._its_product = workpiece(value)
			else:
				self._its_product = value
		else:
			self._its_product = value

	@property
	def its_library_reference(self):
		return self._its_library_reference
	@its_library_reference.setter
	def its_library_reference(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,externally_defined_representation):
				self._its_library_reference = externally_defined_representation(value)
			else:
				self._its_library_reference = value
		else:
			self._its_library_reference = value

####################
 # ENTITY three_axes #
####################
class three_axes(tool_direction):
	'''Entity three_axes definition.
	'''
	def __init__( self ,  ):
		tool_direction.__init__(self , )

####################
 # ENTITY datum_reference #
####################
class datum_reference(BaseEntityClass):
	'''Entity datum_reference definition.

	:param precedence
	:type precedence:INTEGER

	:param referenced_datum
	:type referenced_datum:datum
	'''
	def __init__( self , precedence,referenced_datum, ):
		self._precedence = precedence
		self._referenced_datum = referenced_datum

	@property
	def precedence(self):
		return self._precedence
	@precedence.setter
	def precedence(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,INTEGER):
			self._precedence = INTEGER(value)
		else:
			self._precedence = value

	@property
	def referenced_datum(self):
		return self._referenced_datum
	@referenced_datum.setter
	def referenced_datum(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,datum):
			self._referenced_datum = datum(value)
		else:
			self._referenced_datum = value

####################
 # ENTITY rectangular_offset #
####################
class rectangular_offset(BaseEntityClass):
	'''Entity rectangular_offset definition.

	:param offset_direction
	:type offset_direction:direction

	:param offset_distance
	:type offset_distance:length_measure

	:param row_index
	:type row_index:INTEGER

	:param column_index
	:type column_index:INTEGER
	'''
	def __init__( self , offset_direction,offset_distance,row_index,column_index, ):
		self._offset_direction = offset_direction
		self._offset_distance = offset_distance
		self._row_index = row_index
		self._column_index = column_index

	@property
	def offset_direction(self):
		return self._offset_direction
	@offset_direction.setter
	def offset_direction(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,direction):
			self._offset_direction = direction(value)
		else:
			self._offset_direction = value

	@property
	def offset_distance(self):
		return self._offset_distance
	@offset_distance.setter
	def offset_distance(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,length_measure):
			self._offset_distance = length_measure(value)
		else:
			self._offset_distance = value

	@property
	def row_index(self):
		return self._row_index
	@row_index.setter
	def row_index(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,INTEGER):
			self._row_index = INTEGER(value)
		else:
			self._row_index = value

	@property
	def column_index(self):
		return self._column_index
	@column_index.setter
	def column_index(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,INTEGER):
			self._column_index = INTEGER(value)
		else:
			self._column_index = value

####################
 # ENTITY twist_drill #
####################
class twist_drill(drilling_cutting_tool):
	'''Entity twist_drill definition.
	'''
	def __init__( self , inherited0__its_id , inherited1__its_usage , inherited2__its_cutting_edges , inherited3__overall_assembly_length , inherited4__effective_cutting_diameter , inherited5__maximum_depth_of_cut , inherited6__hand_of_cut , inherited7__coolant_through_tool , inherited8__point_angle ,  ):
		drilling_cutting_tool.__init__(self , inherited0__its_id , inherited1__its_usage , inherited2__its_cutting_edges , inherited3__overall_assembly_length , inherited4__effective_cutting_diameter , inherited5__maximum_depth_of_cut , inherited6__hand_of_cut , inherited7__coolant_through_tool , inherited8__point_angle , )

####################
 # ENTITY mass_measure #
####################
class mass_measure(value_with_tolerance):
	'''Entity mass_measure definition.
	'''
	def __init__( self , inherited0__unit , inherited1__value_component , inherited2__limitation , inherited3__significant_digits ,  ):
		value_with_tolerance.__init__(self , inherited0__unit , inherited1__value_component , inherited2__limitation , inherited3__significant_digits , )

####################
 # ENTITY limit_qualifier #
####################
class limit_qualifier(BaseEntityClass):
	'''Entity limit_qualifier definition.

	:param qualifier
	:type qualifier:STRING
	'''
	def __init__( self , qualifier, ):
		self._qualifier = qualifier

	@property
	def qualifier(self):
		return self._qualifier
	@qualifier.setter
	def qualifier(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,STRING):
			self._qualifier = STRING(value)
		else:
			self._qualifier = value

####################
 # ENTITY machine_functions #
####################
class machine_functions(BaseEntityClass):
	'''Entity machine_functions definition.
	'''
	# This class does not define any attribute.
	pass

####################
 # ENTITY side_mill #
####################
class side_mill(milling_cutting_tool):
	'''Entity side_mill definition.

	:param cutter_width
	:type cutter_width:length_measure
	'''
	def __init__( self , inherited0__its_id , inherited1__its_usage , inherited2__its_cutting_edges , inherited3__overall_assembly_length , inherited4__effective_cutting_diameter , inherited5__maximum_depth_of_cut , inherited6__hand_of_cut , inherited7__coolant_through_tool , inherited8__number_of_effective_teeth , inherited9__edge_radius , cutter_width, ):
		milling_cutting_tool.__init__(self , inherited0__its_id , inherited1__its_usage , inherited2__its_cutting_edges , inherited3__overall_assembly_length , inherited4__effective_cutting_diameter , inherited5__maximum_depth_of_cut , inherited6__hand_of_cut , inherited7__coolant_through_tool , inherited8__number_of_effective_teeth , inherited9__edge_radius , )
		self._cutter_width = cutter_width

	@property
	def cutter_width(self):
		return self._cutter_width
	@cutter_width.setter
	def cutter_width(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,length_measure):
			self._cutter_width = length_measure(value)
		else:
			self._cutter_width = value

####################
 # ENTITY center_milling #
####################
class center_milling(two5d_milling_strategy):
	'''Entity center_milling definition.
	'''
	def __init__( self , inherited0__overlap , inherited1__allow_multiple_passes ,  ):
		two5d_milling_strategy.__init__(self , inherited0__overlap , inherited1__allow_multiple_passes , )

####################
 # ENTITY tee_profile #
####################
class tee_profile(open_profile):
	'''Entity tee_profile definition.

	:param first_angle
	:type first_angle:plane_angle_measure

	:param second_angle
	:type second_angle:plane_angle_measure

	:param cross_bar_width
	:type cross_bar_width:toleranced_length_measure

	:param cross_bar_depth
	:type cross_bar_depth:toleranced_length_measure

	:param radius
	:type radius:toleranced_length_measure

	:param width
	:type width:toleranced_length_measure

	:param first_offset
	:type first_offset:toleranced_length_measure

	:param second_offset
	:type second_offset:toleranced_length_measure
	'''
	def __init__( self , inherited0__placement , first_angle,second_angle,cross_bar_width,cross_bar_depth,radius,width,first_offset,second_offset, ):
		open_profile.__init__(self , inherited0__placement , )
		self._first_angle = first_angle
		self._second_angle = second_angle
		self._cross_bar_width = cross_bar_width
		self._cross_bar_depth = cross_bar_depth
		self._radius = radius
		self._width = width
		self._first_offset = first_offset
		self._second_offset = second_offset

	@property
	def first_angle(self):
		return self._first_angle
	@first_angle.setter
	def first_angle(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,plane_angle_measure):
			self._first_angle = plane_angle_measure(value)
		else:
			self._first_angle = value

	@property
	def second_angle(self):
		return self._second_angle
	@second_angle.setter
	def second_angle(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,plane_angle_measure):
			self._second_angle = plane_angle_measure(value)
		else:
			self._second_angle = value

	@property
	def cross_bar_width(self):
		return self._cross_bar_width
	@cross_bar_width.setter
	def cross_bar_width(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,toleranced_length_measure):
			self._cross_bar_width = toleranced_length_measure(value)
		else:
			self._cross_bar_width = value

	@property
	def cross_bar_depth(self):
		return self._cross_bar_depth
	@cross_bar_depth.setter
	def cross_bar_depth(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,toleranced_length_measure):
			self._cross_bar_depth = toleranced_length_measure(value)
		else:
			self._cross_bar_depth = value

	@property
	def radius(self):
		return self._radius
	@radius.setter
	def radius(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,toleranced_length_measure):
			self._radius = toleranced_length_measure(value)
		else:
			self._radius = value

	@property
	def width(self):
		return self._width
	@width.setter
	def width(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,toleranced_length_measure):
			self._width = toleranced_length_measure(value)
		else:
			self._width = value

	@property
	def first_offset(self):
		return self._first_offset
	@first_offset.setter
	def first_offset(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,toleranced_length_measure):
			self._first_offset = toleranced_length_measure(value)
		else:
			self._first_offset = value

	@property
	def second_offset(self):
		return self._second_offset
	@second_offset.setter
	def second_offset(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,toleranced_length_measure):
			self._second_offset = toleranced_length_measure(value)
		else:
			self._second_offset = value

####################
 # ENTITY process_property #
####################
class process_property(general_property):
	'''Entity process_property definition.

	:param process_name
	:type process_name:label

	:param process_characteristics
	:type process_characteristics:SET(0,None,'property_parameter', scope = schema_scope)
	'''
	def __init__( self , inherited0__description , inherited1__owner , inherited2__related_properties , inherited3__specifications , process_name,process_characteristics, ):
		general_property.__init__(self , inherited0__description , inherited1__owner , inherited2__related_properties , inherited3__specifications , )
		self._process_name = process_name
		self._process_characteristics = process_characteristics

	@property
	def process_name(self):
		return self._process_name
	@process_name.setter
	def process_name(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,label):
			self._process_name = label(value)
		else:
			self._process_name = value

	@property
	def process_characteristics(self):
		return self._process_characteristics
	@process_characteristics.setter
	def process_characteristics(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(0,None,'property_parameter', scope = schema_scope)):
			self._process_characteristics = SET(value)
		else:
			self._process_characteristics = value

####################
 # ENTITY rotating_boring_cutting_tool #
####################
class rotating_boring_cutting_tool(milling_machine_cutting_tool):
	'''Entity rotating_boring_cutting_tool definition.

	:param retract_movement_forbidden
	:type retract_movement_forbidden:BOOLEAN
	'''
	def __init__( self , inherited0__its_id , inherited1__its_usage , inherited2__its_cutting_edges , inherited3__overall_assembly_length , inherited4__effective_cutting_diameter , inherited5__maximum_depth_of_cut , inherited6__hand_of_cut , inherited7__coolant_through_tool , retract_movement_forbidden, ):
		milling_machine_cutting_tool.__init__(self , inherited0__its_id , inherited1__its_usage , inherited2__its_cutting_edges , inherited3__overall_assembly_length , inherited4__effective_cutting_diameter , inherited5__maximum_depth_of_cut , inherited6__hand_of_cut , inherited7__coolant_through_tool , )
		self._retract_movement_forbidden = retract_movement_forbidden

	@property
	def retract_movement_forbidden(self):
		return self._retract_movement_forbidden
	@retract_movement_forbidden.setter
	def retract_movement_forbidden(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,BOOLEAN):
			self._retract_movement_forbidden = BOOLEAN(value)
		else:
			self._retract_movement_forbidden = value

####################
 # ENTITY facing #
####################
class facing(turning_machining_operation):
	'''Entity facing definition.

	:param allowance
	:type allowance:length_measure
	'''
	def __init__( self , inherited0__its_toolpath , inherited1__its_tool_direction , inherited2__its_id , inherited3__retract_plane , inherited4__start_point , inherited5__its_tool , inherited6__its_technology , inherited7__its_machine_functions , inherited8__approach , inherited9__retract , inherited10__its_machining_strategy , allowance, ):
		turning_machining_operation.__init__(self , inherited0__its_toolpath , inherited1__its_tool_direction , inherited2__its_id , inherited3__retract_plane , inherited4__start_point , inherited5__its_tool , inherited6__its_technology , inherited7__its_machine_functions , inherited8__approach , inherited9__retract , inherited10__its_machining_strategy , )
		self._allowance = allowance

	@property
	def allowance(self):
		return self._allowance
	@allowance.setter
	def allowance(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,length_measure):
				self._allowance = length_measure(value)
			else:
				self._allowance = value
		else:
			self._allowance = value

####################
 # ENTITY vee_profile #
####################
class vee_profile(open_profile):
	'''Entity vee_profile definition.

	:param profile_radius
	:type profile_radius:toleranced_length_measure

	:param profile_angle
	:type profile_angle:plane_angle_measure

	:param tilt_angle
	:type tilt_angle:plane_angle_measure

	:param first_side_length
	:type first_side_length:toleranced_length_measure

	:param second_side_length
	:type second_side_length:toleranced_length_measure
	'''
	def __init__( self , inherited0__placement , profile_radius,profile_angle,tilt_angle,first_side_length,second_side_length, ):
		open_profile.__init__(self , inherited0__placement , )
		self._profile_radius = profile_radius
		self._profile_angle = profile_angle
		self._tilt_angle = tilt_angle
		self._first_side_length = first_side_length
		self._second_side_length = second_side_length

	@property
	def profile_radius(self):
		return self._profile_radius
	@profile_radius.setter
	def profile_radius(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,toleranced_length_measure):
			self._profile_radius = toleranced_length_measure(value)
		else:
			self._profile_radius = value

	@property
	def profile_angle(self):
		return self._profile_angle
	@profile_angle.setter
	def profile_angle(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,plane_angle_measure):
			self._profile_angle = plane_angle_measure(value)
		else:
			self._profile_angle = value

	@property
	def tilt_angle(self):
		return self._tilt_angle
	@tilt_angle.setter
	def tilt_angle(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,plane_angle_measure):
			self._tilt_angle = plane_angle_measure(value)
		else:
			self._tilt_angle = value

	@property
	def first_side_length(self):
		return self._first_side_length
	@first_side_length.setter
	def first_side_length(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,toleranced_length_measure):
				self._first_side_length = toleranced_length_measure(value)
			else:
				self._first_side_length = value
		else:
			self._first_side_length = value

	@property
	def second_side_length(self):
		return self._second_side_length
	@second_side_length.setter
	def second_side_length(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,toleranced_length_measure):
				self._second_side_length = toleranced_length_measure(value)
			else:
				self._second_side_length = value
		else:
			self._second_side_length = value

####################
 # ENTITY region_surface_list #
####################
class region_surface_list(region):
	'''Entity region_surface_list definition.

	:param surface_list
	:type surface_list:LIST(1,None,'STRING', scope = schema_scope)
	'''
	def __init__( self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , surface_list, ):
		region.__init__(self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , )
		self._surface_list = surface_list

	@property
	def surface_list(self):
		return self._surface_list
	@surface_list.setter
	def surface_list(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,LIST(1,None,'STRING', scope = schema_scope)):
			self._surface_list = LIST(value)
		else:
			self._surface_list = value

####################
 # ENTITY slot #
####################
class slot(machining_feature):
	'''Entity slot definition.

	:param course_of_travel
	:type course_of_travel:travel_path

	:param swept_shape
	:type swept_shape:open_profile

	:param end_conditions
	:type end_conditions:LIST(0,2,'slot_end_type', scope = schema_scope)
	'''
	def __init__( self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , inherited5__depth , course_of_travel,swept_shape,end_conditions, ):
		machining_feature.__init__(self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , inherited5__depth , )
		self._course_of_travel = course_of_travel
		self._swept_shape = swept_shape
		self._end_conditions = end_conditions

	@property
	def course_of_travel(self):
		return self._course_of_travel
	@course_of_travel.setter
	def course_of_travel(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,travel_path):
			self._course_of_travel = travel_path(value)
		else:
			self._course_of_travel = value

	@property
	def swept_shape(self):
		return self._swept_shape
	@swept_shape.setter
	def swept_shape(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,open_profile):
			self._swept_shape = open_profile(value)
		else:
			self._swept_shape = value

	@property
	def end_conditions(self):
		return self._end_conditions
	@end_conditions.setter
	def end_conditions(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,LIST(0,2,'slot_end_type', scope = schema_scope)):
			self._end_conditions = LIST(value)
		else:
			self._end_conditions = value
	def wr1(self):
		eval_wr1_wr = (((SIZEOF(None)  ==  1)  and  (SIZEOF(self.end_conditions)  ==  1))  or  (SIZEOF(self.end_conditions)  !=  1))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY machine_axis_travel #
####################
class machine_axis_travel(BaseEntityClass):
	'''Entity machine_axis_travel definition.

	:param axis_identifier
	:type axis_identifier:STRING

	:param travel_distance
	:type travel_distance:value_with_unit
	'''
	def __init__( self , axis_identifier,travel_distance, ):
		self._axis_identifier = axis_identifier
		self._travel_distance = travel_distance

	@property
	def axis_identifier(self):
		return self._axis_identifier
	@axis_identifier.setter
	def axis_identifier(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,STRING):
			self._axis_identifier = STRING(value)
		else:
			self._axis_identifier = value

	@property
	def travel_distance(self):
		return self._travel_distance
	@travel_distance.setter
	def travel_distance(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,value_with_unit):
			self._travel_distance = value_with_unit(value)
		else:
			self._travel_distance = value

####################
 # ENTITY height_size_dimension #
####################
class height_size_dimension(size_dimension):
	'''Entity height_size_dimension definition.

	:param used_path
	:type used_path:measurement_path
	'''
	def __init__( self , inherited0__id , inherited1__dimension_value , inherited2__notes , inherited3__applied_to , inherited4__envelope_principle , used_path, ):
		size_dimension.__init__(self , inherited0__id , inherited1__dimension_value , inherited2__notes , inherited3__applied_to , inherited4__envelope_principle , )
		self._used_path = used_path

	@property
	def used_path(self):
		return self._used_path
	@used_path.setter
	def used_path(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,measurement_path):
				self._used_path = measurement_path(value)
			else:
				self._used_path = value
		else:
			self._used_path = value

####################
 # ENTITY counter_sinking #
####################
class counter_sinking(drilling_operation):
	'''Entity counter_sinking definition.
	'''
	def __init__( self , inherited0__its_toolpath , inherited1__its_tool_direction , inherited2__its_id , inherited3__retract_plane , inherited4__start_point , inherited5__its_tool , inherited6__its_technology , inherited7__its_machine_functions , inherited8__overcut_length , inherited9__cutting_depth , inherited10__previous_diameter , inherited11__dwell_time_bottom , inherited12__feed_on_retract , inherited13__its_machining_strategy ,  ):
		drilling_operation.__init__(self , inherited0__its_toolpath , inherited1__its_tool_direction , inherited2__its_id , inherited3__retract_plane , inherited4__start_point , inherited5__its_tool , inherited6__its_technology , inherited7__its_machine_functions , inherited8__overcut_length , inherited9__cutting_depth , inherited10__previous_diameter , inherited11__dwell_time_bottom , inherited12__feed_on_retract , inherited13__its_machining_strategy , )

####################
 # ENTITY toolpath_feature #
####################
class toolpath_feature(machining_feature):
	'''Entity toolpath_feature definition.
	'''
	def __init__( self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , inherited5__depth ,  ):
		machining_feature.__init__(self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , inherited5__depth , )

####################
 # ENTITY linear_path #
####################
class linear_path(travel_path):
	'''Entity linear_path definition.

	:param distance
	:type distance:toleranced_length_measure

	:param its_direction
	:type its_direction:direction
	'''
	def __init__( self , inherited0__placement , distance,its_direction, ):
		travel_path.__init__(self , inherited0__placement , )
		self._distance = distance
		self._its_direction = its_direction

	@property
	def distance(self):
		return self._distance
	@distance.setter
	def distance(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,toleranced_length_measure):
			self._distance = toleranced_length_measure(value)
		else:
			self._distance = value

	@property
	def its_direction(self):
		return self._its_direction
	@its_direction.setter
	def its_direction(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,direction):
			self._its_direction = direction(value)
		else:
			self._its_direction = value

####################
 # ENTITY multiple_arity_boolean_expression #
####################
class multiple_arity_boolean_expression(boolean_expression):
	'''Entity multiple_arity_boolean_expression definition.

	:param operands
	:type operands:LIST(2,None,'boolean_expression', scope = schema_scope)
	'''
	def __init__( self , operands, ):
		boolean_expression.__init__(self , )
		self._operands = operands

	@property
	def operands(self):
		return self._operands
	@operands.setter
	def operands(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,LIST(2,None,'boolean_expression', scope = schema_scope)):
			self._operands = LIST(value)
		else:
			self._operands = value

####################
 # ENTITY or_expression #
####################
class or_expression(multiple_arity_boolean_expression):
	'''Entity or_expression definition.
	'''
	def __init__( self , inherited0__operands ,  ):
		multiple_arity_boolean_expression.__init__(self , inherited0__operands , )

####################
 # ENTITY comparison_greater_equal #
####################
class comparison_greater_equal(comparison_expression):
	'''Entity comparison_greater_equal definition.
	'''
	def __init__( self , inherited0__operand1 , inherited1__operand2 ,  ):
		comparison_expression.__init__(self , inherited0__operand1 , inherited1__operand2 , )

####################
 # ENTITY unidirectional_turning #
####################
class unidirectional_turning(turning_machining_strategy):
	'''Entity unidirectional_turning definition.

	:param feed_direction
	:type feed_direction:direction

	:param back_path_direction
	:type back_path_direction:direction

	:param lift_direction
	:type lift_direction:direction

	:param stepover_direction
	:type stepover_direction:direction

	:param lift_height
	:type lift_height:length_measure

	:param lift_feed
	:type lift_feed:feed_select

	:param stepover_feed
	:type stepover_feed:feed_select
	'''
	def __init__( self , inherited0__overcut_length , inherited1__allow_multiple_passes , inherited2__cutting_depth , inherited3__variable_feedrate , feed_direction,back_path_direction,lift_direction,stepover_direction,lift_height,lift_feed,stepover_feed, ):
		turning_machining_strategy.__init__(self , inherited0__overcut_length , inherited1__allow_multiple_passes , inherited2__cutting_depth , inherited3__variable_feedrate , )
		self._feed_direction = feed_direction
		self._back_path_direction = back_path_direction
		self._lift_direction = lift_direction
		self._stepover_direction = stepover_direction
		self._lift_height = lift_height
		self._lift_feed = lift_feed
		self._stepover_feed = stepover_feed

	@property
	def feed_direction(self):
		return self._feed_direction
	@feed_direction.setter
	def feed_direction(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,direction):
				self._feed_direction = direction(value)
			else:
				self._feed_direction = value
		else:
			self._feed_direction = value

	@property
	def back_path_direction(self):
		return self._back_path_direction
	@back_path_direction.setter
	def back_path_direction(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,direction):
				self._back_path_direction = direction(value)
			else:
				self._back_path_direction = value
		else:
			self._back_path_direction = value

	@property
	def lift_direction(self):
		return self._lift_direction
	@lift_direction.setter
	def lift_direction(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,direction):
				self._lift_direction = direction(value)
			else:
				self._lift_direction = value
		else:
			self._lift_direction = value

	@property
	def stepover_direction(self):
		return self._stepover_direction
	@stepover_direction.setter
	def stepover_direction(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,direction):
				self._stepover_direction = direction(value)
			else:
				self._stepover_direction = value
		else:
			self._stepover_direction = value

	@property
	def lift_height(self):
		return self._lift_height
	@lift_height.setter
	def lift_height(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,length_measure):
				self._lift_height = length_measure(value)
			else:
				self._lift_height = value
		else:
			self._lift_height = value

	@property
	def lift_feed(self):
		return self._lift_feed
	@lift_feed.setter
	def lift_feed(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,feed_select):
				self._lift_feed = feed_select(value)
			else:
				self._lift_feed = value
		else:
			self._lift_feed = value

	@property
	def stepover_feed(self):
		return self._stepover_feed
	@stepover_feed.setter
	def stepover_feed(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,feed_select):
				self._stepover_feed = feed_select(value)
			else:
				self._stepover_feed = value
		else:
			self._stepover_feed = value

####################
 # ENTITY five_axes_const_tilt_yaw #
####################
class five_axes_const_tilt_yaw(tool_direction_for_milling):
	'''Entity five_axes_const_tilt_yaw definition.

	:param tilt_angle
	:type tilt_angle:plane_angle_measure

	:param yaw_angle
	:type yaw_angle:plane_angle_measure
	'''
	def __init__( self , tilt_angle,yaw_angle, ):
		tool_direction_for_milling.__init__(self , )
		self._tilt_angle = tilt_angle
		self._yaw_angle = yaw_angle

	@property
	def tilt_angle(self):
		return self._tilt_angle
	@tilt_angle.setter
	def tilt_angle(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,plane_angle_measure):
			self._tilt_angle = plane_angle_measure(value)
		else:
			self._tilt_angle = value

	@property
	def yaw_angle(self):
		return self._yaw_angle
	@yaw_angle.setter
	def yaw_angle(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,plane_angle_measure):
			self._yaw_angle = plane_angle_measure(value)
		else:
			self._yaw_angle = value

####################
 # ENTITY reaming #
####################
class reaming(boring_operation):
	'''Entity reaming definition.
	'''
	def __init__( self , inherited0__its_toolpath , inherited1__its_tool_direction , inherited2__its_id , inherited3__retract_plane , inherited4__start_point , inherited5__its_tool , inherited6__its_technology , inherited7__its_machine_functions , inherited8__overcut_length , inherited9__cutting_depth , inherited10__previous_diameter , inherited11__dwell_time_bottom , inherited12__feed_on_retract , inherited13__its_machining_strategy , inherited14__spindle_stop_at_bottom , inherited15__depth_of_testcut , inherited16__waiting_position ,  ):
		boring_operation.__init__(self , inherited0__its_toolpath , inherited1__its_tool_direction , inherited2__its_id , inherited3__retract_plane , inherited4__start_point , inherited5__its_tool , inherited6__its_technology , inherited7__its_machine_functions , inherited8__overcut_length , inherited9__cutting_depth , inherited10__previous_diameter , inherited11__dwell_time_bottom , inherited12__feed_on_retract , inherited13__its_machining_strategy , inherited14__spindle_stop_at_bottom , inherited15__depth_of_testcut , inherited16__waiting_position , )

####################
 # ENTITY groove #
####################
class groove(revolved_feature):
	'''Entity groove definition.

	:param sweep
	:type sweep:open_profile
	'''
	def __init__( self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , inherited5__material_side , inherited6__radius , sweep, ):
		revolved_feature.__init__(self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , inherited5__material_side , inherited6__radius , )
		self._sweep = sweep

	@property
	def sweep(self):
		return self._sweep
	@sweep.setter
	def sweep(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,open_profile):
			self._sweep = open_profile(value)
		else:
			self._sweep = value

####################
 # ENTITY general_path #
####################
class general_path(travel_path):
	'''Entity general_path definition.

	:param swept_path
	:type swept_path:path_shape_item
	'''
	def __init__( self , inherited0__placement , swept_path, ):
		travel_path.__init__(self , inherited0__placement , )
		self._swept_path = swept_path

	@property
	def swept_path(self):
		return self._swept_path
	@swept_path.setter
	def swept_path(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,path_shape_item):
			self._swept_path = path_shape_item(value)
		else:
			self._swept_path = value

####################
 # ENTITY roundness_tolerance #
####################
class roundness_tolerance(geometric_tolerance):
	'''Entity roundness_tolerance definition.
	'''
	def __init__( self , inherited0__name , inherited1__applied_to , inherited2__modification , inherited3__qualifying_note , inherited4__segment_size , inherited5__significant_digits , inherited6__tolerance_value ,  ):
		geometric_tolerance.__init__(self , inherited0__name , inherited1__applied_to , inherited2__modification , inherited3__qualifying_note , inherited4__segment_size , inherited5__significant_digits , inherited6__tolerance_value , )

####################
 # ENTITY symmetry_tolerance #
####################
class symmetry_tolerance(geometric_tolerance):
	'''Entity symmetry_tolerance definition.

	:param affected_plane
	:type affected_plane:axis_placement

	:param reference_datum
	:type reference_datum:SET(1,3,'datum_reference', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__applied_to , inherited2__modification , inherited3__qualifying_note , inherited4__segment_size , inherited5__significant_digits , inherited6__tolerance_value , affected_plane,reference_datum, ):
		geometric_tolerance.__init__(self , inherited0__name , inherited1__applied_to , inherited2__modification , inherited3__qualifying_note , inherited4__segment_size , inherited5__significant_digits , inherited6__tolerance_value , )
		self._affected_plane = affected_plane
		self._reference_datum = reference_datum

	@property
	def affected_plane(self):
		return self._affected_plane
	@affected_plane.setter
	def affected_plane(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,axis_placement):
				self._affected_plane = axis_placement(value)
			else:
				self._affected_plane = value
		else:
			self._affected_plane = value

	@property
	def reference_datum(self):
		return self._reference_datum
	@reference_datum.setter
	def reference_datum(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(1,3,'datum_reference', scope = schema_scope)):
			self._reference_datum = SET(value)
		else:
			self._reference_datum = value

####################
 # ENTITY property_bsu #
####################
class property_bsu(bsu):
	'''Entity property_bsu definition.

	:param name_scope
	:type name_scope:class_bsu

	:param version
	:type version:label
	'''
	def __init__( self , inherited0__code , name_scope,version, ):
		bsu.__init__(self , inherited0__code , )
		self._name_scope = name_scope
		self._version = version

	@property
	def name_scope(self):
		return self._name_scope
	@name_scope.setter
	def name_scope(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,class_bsu):
			self._name_scope = class_bsu(value)
		else:
			self._name_scope = value

	@property
	def version(self):
		return self._version
	@version.setter
	def version(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,label):
			self._version = label(value)
		else:
			self._version = value

####################
 # ENTITY optional_stop #
####################
class optional_stop(nc_function):
	'''Entity optional_stop definition.
	'''
	def __init__( self , inherited0__its_id ,  ):
		nc_function.__init__(self , inherited0__its_id , )

####################
 # ENTITY profile_floor #
####################
class profile_floor(BaseEntityClass):
	'''Entity profile_floor definition.

	:param floor_radius
	:type floor_radius:numeric_parameter

	:param start_or_end
	:type start_or_end:BOOLEAN
	'''
	def __init__( self , floor_radius,start_or_end, ):
		self._floor_radius = floor_radius
		self._start_or_end = start_or_end

	@property
	def floor_radius(self):
		return self._floor_radius
	@floor_radius.setter
	def floor_radius(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,numeric_parameter):
				self._floor_radius = numeric_parameter(value)
			else:
				self._floor_radius = value
		else:
			self._floor_radius = value

	@property
	def start_or_end(self):
		return self._start_or_end
	@start_or_end.setter
	def start_or_end(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,BOOLEAN):
			self._start_or_end = BOOLEAN(value)
		else:
			self._start_or_end = value

####################
 # ENTITY general_profile_floor #
####################
class general_profile_floor(profile_floor):
	'''Entity general_profile_floor definition.

	:param floor
	:type floor:face
	'''
	def __init__( self , inherited0__floor_radius , inherited1__start_or_end , floor, ):
		profile_floor.__init__(self , inherited0__floor_radius , inherited1__start_or_end , )
		self._floor = floor

	@property
	def floor(self):
		return self._floor
	@floor.setter
	def floor(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,face):
			self._floor = face(value)
		else:
			self._floor = value

####################
 # ENTITY three_axes_tilted_tool #
####################
class three_axes_tilted_tool(tool_direction_for_milling):
	'''Entity three_axes_tilted_tool definition.

	:param its_tool_direction
	:type its_tool_direction:direction
	'''
	def __init__( self , its_tool_direction, ):
		tool_direction_for_milling.__init__(self , )
		self._its_tool_direction = its_tool_direction

	@property
	def its_tool_direction(self):
		return self._its_tool_direction
	@its_tool_direction.setter
	def its_tool_direction(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,direction):
			self._its_tool_direction = direction(value)
		else:
			self._its_tool_direction = value

####################
 # ENTITY linear_profile #
####################
class linear_profile(open_profile):
	'''Entity linear_profile definition.

	:param profile_length
	:type profile_length:numeric_parameter
	'''
	def __init__( self , inherited0__placement , profile_length, ):
		open_profile.__init__(self , inherited0__placement , )
		self._profile_length = profile_length

	@property
	def profile_length(self):
		return self._profile_length
	@profile_length.setter
	def profile_length(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,numeric_parameter):
			self._profile_length = numeric_parameter(value)
		else:
			self._profile_length = value

####################
 # ENTITY pocket #
####################
class pocket(machining_feature):
	'''Entity pocket definition.

	:param its_boss
	:type its_boss:SET(0,None,'boss', scope = schema_scope)

	:param slope
	:type slope:plane_angle_measure

	:param bottom_condition
	:type bottom_condition:pocket_bottom_condition

	:param planar_radius
	:type planar_radius:toleranced_length_measure

	:param orthogonal_radius
	:type orthogonal_radius:toleranced_length_measure

	:param bottom_at_path_end
	:type bottom_at_path_end:BOOLEAN

	:param course_of_travel
	:type course_of_travel:linear_path

	:param top_fillet_radius
	:type top_fillet_radius:toleranced_length_measure
	'''
	def __init__( self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , inherited5__depth , its_boss,slope,bottom_condition,planar_radius,orthogonal_radius,bottom_at_path_end,course_of_travel,top_fillet_radius, ):
		machining_feature.__init__(self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , inherited5__depth , )
		self._its_boss = its_boss
		self._slope = slope
		self._bottom_condition = bottom_condition
		self._planar_radius = planar_radius
		self._orthogonal_radius = orthogonal_radius
		self._bottom_at_path_end = bottom_at_path_end
		self._course_of_travel = course_of_travel
		self._top_fillet_radius = top_fillet_radius

	@property
	def its_boss(self):
		return self._its_boss
	@its_boss.setter
	def its_boss(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(0,None,'boss', scope = schema_scope)):
			self._its_boss = SET(value)
		else:
			self._its_boss = value

	@property
	def slope(self):
		return self._slope
	@slope.setter
	def slope(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,plane_angle_measure):
				self._slope = plane_angle_measure(value)
			else:
				self._slope = value
		else:
			self._slope = value

	@property
	def bottom_condition(self):
		return self._bottom_condition
	@bottom_condition.setter
	def bottom_condition(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,pocket_bottom_condition):
			self._bottom_condition = pocket_bottom_condition(value)
		else:
			self._bottom_condition = value

	@property
	def planar_radius(self):
		return self._planar_radius
	@planar_radius.setter
	def planar_radius(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,toleranced_length_measure):
				self._planar_radius = toleranced_length_measure(value)
			else:
				self._planar_radius = value
		else:
			self._planar_radius = value

	@property
	def orthogonal_radius(self):
		return self._orthogonal_radius
	@orthogonal_radius.setter
	def orthogonal_radius(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,toleranced_length_measure):
				self._orthogonal_radius = toleranced_length_measure(value)
			else:
				self._orthogonal_radius = value
		else:
			self._orthogonal_radius = value

	@property
	def bottom_at_path_end(self):
		return self._bottom_at_path_end
	@bottom_at_path_end.setter
	def bottom_at_path_end(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,BOOLEAN):
			self._bottom_at_path_end = BOOLEAN(value)
		else:
			self._bottom_at_path_end = value

	@property
	def course_of_travel(self):
		return self._course_of_travel
	@course_of_travel.setter
	def course_of_travel(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,linear_path):
			self._course_of_travel = linear_path(value)
		else:
			self._course_of_travel = value

	@property
	def top_fillet_radius(self):
		return self._top_fillet_radius
	@top_fillet_radius.setter
	def top_fillet_radius(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,toleranced_length_measure):
				self._top_fillet_radius = toleranced_length_measure(value)
			else:
				self._top_fillet_radius = value
		else:
			self._top_fillet_radius = value

####################
 # ENTITY open_pocket #
####################
class open_pocket(pocket):
	'''Entity open_pocket definition.

	:param open_boundary
	:type open_boundary:open_profile

	:param wall_boundary
	:type wall_boundary:open_profile
	'''
	def __init__( self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , inherited5__depth , inherited6__its_boss , inherited7__slope , inherited8__bottom_condition , inherited9__planar_radius , inherited10__orthogonal_radius , inherited11__bottom_at_path_end , inherited12__course_of_travel , inherited13__top_fillet_radius , open_boundary,wall_boundary, ):
		pocket.__init__(self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , inherited5__depth , inherited6__its_boss , inherited7__slope , inherited8__bottom_condition , inherited9__planar_radius , inherited10__orthogonal_radius , inherited11__bottom_at_path_end , inherited12__course_of_travel , inherited13__top_fillet_radius , )
		self._open_boundary = open_boundary
		self._wall_boundary = wall_boundary

	@property
	def open_boundary(self):
		return self._open_boundary
	@open_boundary.setter
	def open_boundary(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,open_profile):
			self._open_boundary = open_profile(value)
		else:
			self._open_boundary = value

	@property
	def wall_boundary(self):
		return self._wall_boundary
	@wall_boundary.setter
	def wall_boundary(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,open_profile):
				self._wall_boundary = open_profile(value)
			else:
				self._wall_boundary = value
		else:
			self._wall_boundary = value

####################
 # ENTITY workpiece_setup #
####################
class workpiece_setup(BaseEntityClass):
	'''Entity workpiece_setup definition.

	:param its_workpiece
	:type its_workpiece:workpiece

	:param its_origin
	:type its_origin:axis2_placement_3d

	:param its_offset
	:type its_offset:offset_vector

	:param its_restricted_area
	:type its_restricted_area:restricted_area_select

	:param its_instructions
	:type its_instructions:LIST(0,None,'setup_instruction', scope = schema_scope)
	'''
	def __init__( self , its_workpiece,its_origin,its_offset,its_restricted_area,its_instructions, ):
		self._its_workpiece = its_workpiece
		self._its_origin = its_origin
		self._its_offset = its_offset
		self._its_restricted_area = its_restricted_area
		self._its_instructions = its_instructions

	@property
	def its_workpiece(self):
		return self._its_workpiece
	@its_workpiece.setter
	def its_workpiece(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,workpiece):
			self._its_workpiece = workpiece(value)
		else:
			self._its_workpiece = value

	@property
	def its_origin(self):
		return self._its_origin
	@its_origin.setter
	def its_origin(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,axis2_placement_3d):
			self._its_origin = axis2_placement_3d(value)
		else:
			self._its_origin = value

	@property
	def its_offset(self):
		return self._its_offset
	@its_offset.setter
	def its_offset(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,offset_vector):
				self._its_offset = offset_vector(value)
			else:
				self._its_offset = value
		else:
			self._its_offset = value

	@property
	def its_restricted_area(self):
		return self._its_restricted_area
	@its_restricted_area.setter
	def its_restricted_area(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,restricted_area_select):
				self._its_restricted_area = restricted_area_select(value)
			else:
				self._its_restricted_area = value
		else:
			self._its_restricted_area = value

	@property
	def its_instructions(self):
		return self._its_instructions
	@its_instructions.setter
	def its_instructions(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,LIST(0,None,'setup_instruction', scope = schema_scope)):
			self._its_instructions = LIST(value)
		else:
			self._its_instructions = value

####################
 # ENTITY connect_direct #
####################
class connect_direct(connector):
	'''Entity connect_direct definition.
	'''
	def __init__( self , inherited0__its_priority , inherited1__its_type , inherited2__its_speed , inherited3__its_technology , inherited4__its_machine_functions , inherited5__its_id ,  ):
		connector.__init__(self , inherited0__its_priority , inherited1__its_type , inherited2__its_speed , inherited3__its_technology , inherited4__its_machine_functions , inherited5__its_id , )

####################
 # ENTITY bottom_and_side_rough_milling #
####################
class bottom_and_side_rough_milling(bottom_and_side_milling):
	'''Entity bottom_and_side_rough_milling definition.
	'''
	def __init__( self , inherited0__its_toolpath , inherited1__its_tool_direction , inherited2__its_id , inherited3__retract_plane , inherited4__start_point , inherited5__its_tool , inherited6__its_technology , inherited7__its_machine_functions , inherited8__overcut_length , inherited9__approach , inherited10__retract , inherited11__its_machining_strategy , inherited12__axial_cutting_depth , inherited13__radial_cutting_depth , inherited14__allowance_side , inherited15__allowance_bottom ,  ):
		bottom_and_side_milling.__init__(self , inherited0__its_toolpath , inherited1__its_tool_direction , inherited2__its_id , inherited3__retract_plane , inherited4__start_point , inherited5__its_tool , inherited6__its_technology , inherited7__its_machine_functions , inherited8__overcut_length , inherited9__approach , inherited10__retract , inherited11__its_machining_strategy , inherited12__axial_cutting_depth , inherited13__radial_cutting_depth , inherited14__allowance_side , inherited15__allowance_bottom , )
	def wr1(self):
		eval_wr1_wr = (EXISTS(self.self.allowance_side)  and  (self.self.allowance_side  >=  0))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (EXISTS(self.self.allowance_bottom)  and  (self.self.allowance_bottom  >=  0))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY rounded_u_profile #
####################
class rounded_u_profile(open_profile):
	'''Entity rounded_u_profile definition.

	:param width
	:type width:toleranced_length_measure

	:param depth
	:type depth:toleranced_length_measure
	'''
	def __init__( self , inherited0__placement , width,depth, ):
		open_profile.__init__(self , inherited0__placement , )
		self._width = width
		self._depth = depth

	@property
	def width(self):
		return self._width
	@width.setter
	def width(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,toleranced_length_measure):
			self._width = toleranced_length_measure(value)
		else:
			self._width = value

	@property
	def depth(self):
		return self._depth
	@depth.setter
	def depth(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,toleranced_length_measure):
				self._depth = toleranced_length_measure(value)
			else:
				self._depth = value
		else:
			self._depth = value

####################
 # ENTITY specification #
####################
class specification(BaseEntityClass):
	'''Entity specification definition.

	:param constraint
	:type constraint:SET(0,None,'specification_usage_constraint', scope = schema_scope)

	:param specification_id
	:type specification_id:text

	:param specification_description
	:type specification_description:text

	:param specification_class
	:type specification_class:text
	'''
	def __init__( self , constraint,specification_id,specification_description,specification_class, ):
		self._constraint = constraint
		self._specification_id = specification_id
		self._specification_description = specification_description
		self._specification_class = specification_class

	@property
	def constraint(self):
		return self._constraint
	@constraint.setter
	def constraint(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(0,None,'specification_usage_constraint', scope = schema_scope)):
			self._constraint = SET(value)
		else:
			self._constraint = value

	@property
	def specification_id(self):
		return self._specification_id
	@specification_id.setter
	def specification_id(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,text):
			self._specification_id = text(value)
		else:
			self._specification_id = value

	@property
	def specification_description(self):
		return self._specification_description
	@specification_description.setter
	def specification_description(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,text):
				self._specification_description = text(value)
			else:
				self._specification_description = value
		else:
			self._specification_description = value

	@property
	def specification_class(self):
		return self._specification_class
	@specification_class.setter
	def specification_class(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,text):
				self._specification_class = text(value)
			else:
				self._specification_class = value
		else:
			self._specification_class = value

####################
 # ENTITY air_strategy #
####################
class air_strategy(approach_retract_strategy):
	'''Entity air_strategy definition.
	'''
	def __init__( self , inherited0__tool_orientation ,  ):
		approach_retract_strategy.__init__(self , inherited0__tool_orientation , )

####################
 # ENTITY ap_retract_angle #
####################
class ap_retract_angle(air_strategy):
	'''Entity ap_retract_angle definition.

	:param angle
	:type angle:plane_angle_measure

	:param travel_length
	:type travel_length:length_measure
	'''
	def __init__( self , inherited0__tool_orientation , angle,travel_length, ):
		air_strategy.__init__(self , inherited0__tool_orientation , )
		self._angle = angle
		self._travel_length = travel_length

	@property
	def angle(self):
		return self._angle
	@angle.setter
	def angle(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,plane_angle_measure):
			self._angle = plane_angle_measure(value)
		else:
			self._angle = value

	@property
	def travel_length(self):
		return self._travel_length
	@travel_length.setter
	def travel_length(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,length_measure):
			self._travel_length = length_measure(value)
		else:
			self._travel_length = value

####################
 # ENTITY general_outside_profile #
####################
class general_outside_profile(profile_feature):
	'''Entity general_outside_profile definition.

	:param feature_boundary
	:type feature_boundary:profile
	'''
	def __init__( self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , inherited5__depth , inherited6__profile_swept_shape , feature_boundary, ):
		profile_feature.__init__(self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , inherited5__depth , inherited6__profile_swept_shape , )
		self._feature_boundary = feature_boundary

	@property
	def feature_boundary(self):
		return self._feature_boundary
	@feature_boundary.setter
	def feature_boundary(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,profile):
			self._feature_boundary = profile(value)
		else:
			self._feature_boundary = value

####################
 # ENTITY threading_rough #
####################
class threading_rough(threading):
	'''Entity threading_rough definition.
	'''
	def __init__( self , inherited0__its_toolpath , inherited1__its_tool_direction , inherited2__its_id , inherited3__retract_plane , inherited4__start_point , inherited5__its_tool , inherited6__its_technology , inherited7__its_machine_functions , inherited8__approach , inherited9__retract , inherited10__its_machining_strategy , inherited11__allowance ,  ):
		threading.__init__(self , inherited0__its_toolpath , inherited1__its_tool_direction , inherited2__its_id , inherited3__retract_plane , inherited4__start_point , inherited5__its_tool , inherited6__its_technology , inherited7__its_machine_functions , inherited8__approach , inherited9__retract , inherited10__its_machining_strategy , inherited11__allowance , )
	def wr1(self):
		eval_wr1_wr = (EXISTS(self.self.allowance)  and  (self.self.allowance  >=  0))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY rot_speed_measure #
####################
class rot_speed_measure(value_with_tolerance):
	'''Entity rot_speed_measure definition.
	'''
	def __init__( self , inherited0__unit , inherited1__value_component , inherited2__limitation , inherited3__significant_digits ,  ):
		value_with_tolerance.__init__(self , inherited0__unit , inherited1__value_component , inherited2__limitation , inherited3__significant_digits , )

####################
 # ENTITY knurling_tool #
####################
class knurling_tool(turning_machine_cutting_tool):
	'''Entity knurling_tool definition.

	:param knurl_pattern
	:type knurl_pattern:knurl_pattern_type

	:param cutting_length
	:type cutting_length:length_measure

	:param angle
	:type angle:plane_angle_measure

	:param pitch
	:type pitch:length_measure
	'''
	def __init__( self , inherited0__its_id , inherited1__its_usage , inherited2__functional_length , inherited3__f_dimension , inherited4__minimum_cutting_diameter , inherited5__a_dimension_on_f , inherited6__a_dimension_on_lf , inherited7__cutting_edge , inherited8__hand_of_tool , knurl_pattern,cutting_length,angle,pitch, ):
		turning_machine_cutting_tool.__init__(self , inherited0__its_id , inherited1__its_usage , inherited2__functional_length , inherited3__f_dimension , inherited4__minimum_cutting_diameter , inherited5__a_dimension_on_f , inherited6__a_dimension_on_lf , inherited7__cutting_edge , inherited8__hand_of_tool , )
		self._knurl_pattern = knurl_pattern
		self._cutting_length = cutting_length
		self._angle = angle
		self._pitch = pitch

	@property
	def knurl_pattern(self):
		return self._knurl_pattern
	@knurl_pattern.setter
	def knurl_pattern(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,knurl_pattern_type):
			self._knurl_pattern = knurl_pattern_type(value)
		else:
			self._knurl_pattern = value

	@property
	def cutting_length(self):
		return self._cutting_length
	@cutting_length.setter
	def cutting_length(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,length_measure):
				self._cutting_length = length_measure(value)
			else:
				self._cutting_length = value
		else:
			self._cutting_length = value

	@property
	def angle(self):
		return self._angle
	@angle.setter
	def angle(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,plane_angle_measure):
				self._angle = plane_angle_measure(value)
			else:
				self._angle = value
		else:
			self._angle = value

	@property
	def pitch(self):
		return self._pitch
	@pitch.setter
	def pitch(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,length_measure):
				self._pitch = length_measure(value)
			else:
				self._pitch = value
		else:
			self._pitch = value

####################
 # ENTITY circular_path #
####################
class circular_path(travel_path):
	'''Entity circular_path definition.

	:param radius
	:type radius:toleranced_length_measure
	'''
	def __init__( self , inherited0__placement , radius, ):
		travel_path.__init__(self , inherited0__placement , )
		self._radius = radius

	@property
	def radius(self):
		return self._radius
	@radius.setter
	def radius(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,toleranced_length_measure):
			self._radius = toleranced_length_measure(value)
		else:
			self._radius = value

####################
 # ENTITY complete_circular_path #
####################
class complete_circular_path(circular_path):
	'''Entity complete_circular_path definition.
	'''
	def __init__( self , inherited0__placement , inherited1__radius ,  ):
		circular_path.__init__(self , inherited0__placement , inherited1__radius , )

####################
 # ENTITY and_expression #
####################
class and_expression(multiple_arity_boolean_expression):
	'''Entity and_expression definition.
	'''
	def __init__( self , inherited0__operands ,  ):
		multiple_arity_boolean_expression.__init__(self , inherited0__operands , )

####################
 # ENTITY tool_radius_probing #
####################
class tool_radius_probing(tool_probing):
	'''Entity tool_radius_probing definition.
	'''
	def __init__( self , inherited0__its_id , inherited1__its_secplane , inherited2__its_toolpath , inherited3__its_tool_direction , inherited4__measured_offset , inherited5__offset , inherited6__max_wear , inherited7__its_tool ,  ):
		tool_probing.__init__(self , inherited0__its_id , inherited1__its_secplane , inherited2__its_toolpath , inherited3__its_tool_direction , inherited4__measured_offset , inherited5__offset , inherited6__max_wear , inherited7__its_tool , )

####################
 # ENTITY index_table #
####################
class index_table(nc_function):
	'''Entity index_table definition.

	:param its_index
	:type its_index:INTEGER
	'''
	def __init__( self , inherited0__its_id , its_index, ):
		nc_function.__init__(self , inherited0__its_id , )
		self._its_index = its_index

	@property
	def its_index(self):
		return self._its_index
	@its_index.setter
	def its_index(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,INTEGER):
			self._its_index = INTEGER(value)
		else:
			self._its_index = value

####################
 # ENTITY externally_defined_size_dimension #
####################
class externally_defined_size_dimension(size_dimension):
	'''Entity externally_defined_size_dimension definition.

	:param name
	:type name:STRING

	:param used_path
	:type used_path:measurement_path

	:param defining_document
	:type defining_document:STRING
	'''
	def __init__( self , inherited0__id , inherited1__dimension_value , inherited2__notes , inherited3__applied_to , inherited4__envelope_principle , name,used_path,defining_document, ):
		size_dimension.__init__(self , inherited0__id , inherited1__dimension_value , inherited2__notes , inherited3__applied_to , inherited4__envelope_principle , )
		self._name = name
		self._used_path = used_path
		self._defining_document = defining_document

	@property
	def name(self):
		return self._name
	@name.setter
	def name(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,STRING):
			self._name = STRING(value)
		else:
			self._name = value

	@property
	def used_path(self):
		return self._used_path
	@used_path.setter
	def used_path(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,measurement_path):
				self._used_path = measurement_path(value)
			else:
				self._used_path = value
		else:
			self._used_path = value

	@property
	def defining_document(self):
		return self._defining_document
	@defining_document.setter
	def defining_document(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,STRING):
			self._defining_document = STRING(value)
		else:
			self._defining_document = value

####################
 # ENTITY security_classification_assignment #
####################
class security_classification_assignment(BaseEntityClass):
	'''Entity security_classification_assignment definition.

	:param classification
	:type classification:security_classification

	:param items
	:type items:SET(1,None,'security_classification_item', scope = schema_scope)
	'''
	def __init__( self , classification,items, ):
		self._classification = classification
		self._items = items

	@property
	def classification(self):
		return self._classification
	@classification.setter
	def classification(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,security_classification):
			self._classification = security_classification(value)
		else:
			self._classification = value

	@property
	def items(self):
		return self._items
	@items.setter
	def items(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(1,None,'security_classification_item', scope = schema_scope)):
			self._items = SET(value)
		else:
			self._items = value

####################
 # ENTITY cutting_component #
####################
class cutting_component(BaseEntityClass):
	'''Entity cutting_component definition.

	:param tool_functional_length
	:type tool_functional_length:length_measure

	:param its_material
	:type its_material:material

	:param expected_tool_life
	:type expected_tool_life:time_measure

	:param its_technology
	:type its_technology:technology
	'''
	def __init__( self , tool_functional_length,its_material,expected_tool_life,its_technology, ):
		self._tool_functional_length = tool_functional_length
		self._its_material = its_material
		self._expected_tool_life = expected_tool_life
		self._its_technology = its_technology

	@property
	def tool_functional_length(self):
		return self._tool_functional_length
	@tool_functional_length.setter
	def tool_functional_length(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,length_measure):
			self._tool_functional_length = length_measure(value)
		else:
			self._tool_functional_length = value

	@property
	def its_material(self):
		return self._its_material
	@its_material.setter
	def its_material(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,material):
				self._its_material = material(value)
			else:
				self._its_material = value
		else:
			self._its_material = value

	@property
	def expected_tool_life(self):
		return self._expected_tool_life
	@expected_tool_life.setter
	def expected_tool_life(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,time_measure):
				self._expected_tool_life = time_measure(value)
			else:
				self._expected_tool_life = value
		else:
			self._expected_tool_life = value

	@property
	def its_technology(self):
		return self._its_technology
	@its_technology.setter
	def its_technology(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,technology):
				self._its_technology = technology(value)
			else:
				self._its_technology = value
		else:
			self._its_technology = value

####################
 # ENTITY step_drill #
####################
class step_drill(drilling_cutting_tool):
	'''Entity step_drill definition.

	:param diameters
	:type diameters:LIST(1,None,'length_measure', scope = schema_scope)

	:param step_length
	:type step_length:LIST(1,None,'length_measure', scope = schema_scope)
	'''
	def __init__( self , inherited0__its_id , inherited1__its_usage , inherited2__its_cutting_edges , inherited3__overall_assembly_length , inherited4__effective_cutting_diameter , inherited5__maximum_depth_of_cut , inherited6__hand_of_cut , inherited7__coolant_through_tool , inherited8__point_angle , diameters,step_length, ):
		drilling_cutting_tool.__init__(self , inherited0__its_id , inherited1__its_usage , inherited2__its_cutting_edges , inherited3__overall_assembly_length , inherited4__effective_cutting_diameter , inherited5__maximum_depth_of_cut , inherited6__hand_of_cut , inherited7__coolant_through_tool , inherited8__point_angle , )
		self._diameters = diameters
		self._step_length = step_length

	@property
	def diameters(self):
		return self._diameters
	@diameters.setter
	def diameters(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,LIST(1,None,'length_measure', scope = schema_scope)):
			self._diameters = LIST(value)
		else:
			self._diameters = value

	@property
	def step_length(self):
		return self._step_length
	@step_length.setter
	def step_length(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,LIST(1,None,'length_measure', scope = schema_scope)):
			self._step_length = LIST(value)
		else:
			self._step_length = value

####################
 # ENTITY two_axes #
####################
class two_axes(tool_direction):
	'''Entity two_axes definition.
	'''
	def __init__( self ,  ):
		tool_direction.__init__(self , )

####################
 # ENTITY coaxiality_tolerance #
####################
class coaxiality_tolerance(geometric_tolerance):
	'''Entity coaxiality_tolerance definition.

	:param reference_datum
	:type reference_datum:SET(1,2,'datum_reference', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__applied_to , inherited2__modification , inherited3__qualifying_note , inherited4__segment_size , inherited5__significant_digits , inherited6__tolerance_value , reference_datum, ):
		geometric_tolerance.__init__(self , inherited0__name , inherited1__applied_to , inherited2__modification , inherited3__qualifying_note , inherited4__segment_size , inherited5__significant_digits , inherited6__tolerance_value , )
		self._reference_datum = reference_datum

	@property
	def reference_datum(self):
		return self._reference_datum
	@reference_datum.setter
	def reference_datum(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(1,2,'datum_reference', scope = schema_scope)):
			self._reference_datum = SET(value)
		else:
			self._reference_datum = value

####################
 # ENTITY comparison_less_equal #
####################
class comparison_less_equal(comparison_expression):
	'''Entity comparison_less_equal definition.
	'''
	def __init__( self , inherited0__operand1 , inherited1__operand2 ,  ):
		comparison_expression.__init__(self , inherited0__operand1 , inherited1__operand2 , )

####################
 # ENTITY outer_diameter_to_shoulder #
####################
class outer_diameter_to_shoulder(outer_round):
	'''Entity outer_diameter_to_shoulder definition.

	:param diameter_at_placement
	:type diameter_at_placement:toleranced_length_measure

	:param v_shape_boundary
	:type v_shape_boundary:vee_profile
	'''
	def __init__( self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , diameter_at_placement,v_shape_boundary, ):
		outer_round.__init__(self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , )
		self._diameter_at_placement = diameter_at_placement
		self._v_shape_boundary = v_shape_boundary

	@property
	def diameter_at_placement(self):
		return self._diameter_at_placement
	@diameter_at_placement.setter
	def diameter_at_placement(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,toleranced_length_measure):
			self._diameter_at_placement = toleranced_length_measure(value)
		else:
			self._diameter_at_placement = value

	@property
	def v_shape_boundary(self):
		return self._v_shape_boundary
	@v_shape_boundary.setter
	def v_shape_boundary(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,vee_profile):
			self._v_shape_boundary = vee_profile(value)
		else:
			self._v_shape_boundary = value

####################
 # ENTITY const_spindle_speed #
####################
class const_spindle_speed(BaseEntityClass):
	'''Entity const_spindle_speed definition.

	:param rot_speed
	:type rot_speed:rot_speed_measure
	'''
	def __init__( self , rot_speed, ):
		self._rot_speed = rot_speed

	@property
	def rot_speed(self):
		return self._rot_speed
	@rot_speed.setter
	def rot_speed(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,rot_speed_measure):
			self._rot_speed = rot_speed_measure(value)
		else:
			self._rot_speed = value

####################
 # ENTITY contour_turning #
####################
class contour_turning(turning_machining_strategy):
	'''Entity contour_turning definition.

	:param feed_direction
	:type feed_direction:direction

	:param back_path_direction
	:type back_path_direction:direction

	:param lift_direction
	:type lift_direction:direction

	:param stepover_direction
	:type stepover_direction:direction

	:param lift_height
	:type lift_height:length_measure

	:param lift_feed
	:type lift_feed:feed_select

	:param stepover_feed
	:type stepover_feed:feed_select

	:param variable_stepover_feed
	:type variable_stepover_feed:positive_ratio_measure
	'''
	def __init__( self , inherited0__overcut_length , inherited1__allow_multiple_passes , inherited2__cutting_depth , inherited3__variable_feedrate , feed_direction,back_path_direction,lift_direction,stepover_direction,lift_height,lift_feed,stepover_feed,variable_stepover_feed, ):
		turning_machining_strategy.__init__(self , inherited0__overcut_length , inherited1__allow_multiple_passes , inherited2__cutting_depth , inherited3__variable_feedrate , )
		self._feed_direction = feed_direction
		self._back_path_direction = back_path_direction
		self._lift_direction = lift_direction
		self._stepover_direction = stepover_direction
		self._lift_height = lift_height
		self._lift_feed = lift_feed
		self._stepover_feed = stepover_feed
		self._variable_stepover_feed = variable_stepover_feed

	@property
	def feed_direction(self):
		return self._feed_direction
	@feed_direction.setter
	def feed_direction(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,direction):
				self._feed_direction = direction(value)
			else:
				self._feed_direction = value
		else:
			self._feed_direction = value

	@property
	def back_path_direction(self):
		return self._back_path_direction
	@back_path_direction.setter
	def back_path_direction(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,direction):
				self._back_path_direction = direction(value)
			else:
				self._back_path_direction = value
		else:
			self._back_path_direction = value

	@property
	def lift_direction(self):
		return self._lift_direction
	@lift_direction.setter
	def lift_direction(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,direction):
				self._lift_direction = direction(value)
			else:
				self._lift_direction = value
		else:
			self._lift_direction = value

	@property
	def stepover_direction(self):
		return self._stepover_direction
	@stepover_direction.setter
	def stepover_direction(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,direction):
				self._stepover_direction = direction(value)
			else:
				self._stepover_direction = value
		else:
			self._stepover_direction = value

	@property
	def lift_height(self):
		return self._lift_height
	@lift_height.setter
	def lift_height(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,length_measure):
				self._lift_height = length_measure(value)
			else:
				self._lift_height = value
		else:
			self._lift_height = value

	@property
	def lift_feed(self):
		return self._lift_feed
	@lift_feed.setter
	def lift_feed(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,feed_select):
				self._lift_feed = feed_select(value)
			else:
				self._lift_feed = value
		else:
			self._lift_feed = value

	@property
	def stepover_feed(self):
		return self._stepover_feed
	@stepover_feed.setter
	def stepover_feed(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,feed_select):
				self._stepover_feed = feed_select(value)
			else:
				self._stepover_feed = value
		else:
			self._stepover_feed = value

	@property
	def variable_stepover_feed(self):
		return self._variable_stepover_feed
	@variable_stepover_feed.setter
	def variable_stepover_feed(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,positive_ratio_measure):
				self._variable_stepover_feed = positive_ratio_measure(value)
			else:
				self._variable_stepover_feed = value
		else:
			self._variable_stepover_feed = value

####################
 # ENTITY plane_cl_strategy #
####################
class plane_cl_strategy(freeform_strategy):
	'''Entity plane_cl_strategy definition.

	:param its_plane_normal
	:type its_plane_normal:direction
	'''
	def __init__( self , inherited0__pathmode , inherited1__cutmode , inherited2__its_milling_tolerances , inherited3__stepover , its_plane_normal, ):
		freeform_strategy.__init__(self , inherited0__pathmode , inherited1__cutmode , inherited2__its_milling_tolerances , inherited3__stepover , )
		self._its_plane_normal = its_plane_normal

	@property
	def its_plane_normal(self):
		return self._its_plane_normal
	@its_plane_normal.setter
	def its_plane_normal(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,direction):
			self._its_plane_normal = direction(value)
		else:
			self._its_plane_normal = value

####################
 # ENTITY woodruff_slot_end_type #
####################
class woodruff_slot_end_type(slot_end_type):
	'''Entity woodruff_slot_end_type definition.

	:param radius
	:type radius:toleranced_length_measure
	'''
	def __init__( self , radius, ):
		slot_end_type.__init__(self , )
		self._radius = radius

	@property
	def radius(self):
		return self._radius
	@radius.setter
	def radius(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,toleranced_length_measure):
			self._radius = toleranced_length_measure(value)
		else:
			self._radius = value

####################
 # ENTITY tolerance_condition #
####################
class tolerance_condition(BaseEntityClass):
	'''Entity tolerance_condition definition.

	:param condition
	:type condition:STRING
	'''
	def __init__( self , condition, ):
		self._condition = condition

	@property
	def condition(self):
		return self._condition
	@condition.setter
	def condition(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,STRING):
			self._condition = STRING(value)
		else:
			self._condition = value

####################
 # ENTITY milling_machine_functions #
####################
class milling_machine_functions(machine_functions):
	'''Entity milling_machine_functions definition.

	:param coolant
	:type coolant:BOOLEAN

	:param coolant_pressure
	:type coolant_pressure:pressure_measure

	:param mist
	:type mist:BOOLEAN

	:param through_spindle_coolant
	:type through_spindle_coolant:BOOLEAN

	:param through_pressure
	:type through_pressure:pressure_measure

	:param axis_clamping
	:type axis_clamping:LIST(0,None,'STRING', scope = schema_scope)

	:param chip_removal
	:type chip_removal:BOOLEAN

	:param oriented_spindle_stop
	:type oriented_spindle_stop:direction

	:param its_process_model
	:type its_process_model:process_model_list

	:param other_functions
	:type other_functions:SET(0,None,'property_parameter', scope = schema_scope)

	:param axis_constraints
	:type axis_constraints:SET(0,None,'machine_axis_constraint', scope = schema_scope)
	'''
	def __init__( self , coolant,coolant_pressure,mist,through_spindle_coolant,through_pressure,axis_clamping,chip_removal,oriented_spindle_stop,its_process_model,other_functions,axis_constraints, ):
		machine_functions.__init__(self , )
		self._coolant = coolant
		self._coolant_pressure = coolant_pressure
		self._mist = mist
		self._through_spindle_coolant = through_spindle_coolant
		self._through_pressure = through_pressure
		self._axis_clamping = axis_clamping
		self._chip_removal = chip_removal
		self._oriented_spindle_stop = oriented_spindle_stop
		self._its_process_model = its_process_model
		self._other_functions = other_functions
		self._axis_constraints = axis_constraints

	@property
	def coolant(self):
		return self._coolant
	@coolant.setter
	def coolant(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,BOOLEAN):
			self._coolant = BOOLEAN(value)
		else:
			self._coolant = value

	@property
	def coolant_pressure(self):
		return self._coolant_pressure
	@coolant_pressure.setter
	def coolant_pressure(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,pressure_measure):
				self._coolant_pressure = pressure_measure(value)
			else:
				self._coolant_pressure = value
		else:
			self._coolant_pressure = value

	@property
	def mist(self):
		return self._mist
	@mist.setter
	def mist(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,BOOLEAN):
				self._mist = BOOLEAN(value)
			else:
				self._mist = value
		else:
			self._mist = value

	@property
	def through_spindle_coolant(self):
		return self._through_spindle_coolant
	@through_spindle_coolant.setter
	def through_spindle_coolant(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,BOOLEAN):
			self._through_spindle_coolant = BOOLEAN(value)
		else:
			self._through_spindle_coolant = value

	@property
	def through_pressure(self):
		return self._through_pressure
	@through_pressure.setter
	def through_pressure(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,pressure_measure):
				self._through_pressure = pressure_measure(value)
			else:
				self._through_pressure = value
		else:
			self._through_pressure = value

	@property
	def axis_clamping(self):
		return self._axis_clamping
	@axis_clamping.setter
	def axis_clamping(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,LIST(0,None,'STRING', scope = schema_scope)):
			self._axis_clamping = LIST(value)
		else:
			self._axis_clamping = value

	@property
	def chip_removal(self):
		return self._chip_removal
	@chip_removal.setter
	def chip_removal(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,BOOLEAN):
			self._chip_removal = BOOLEAN(value)
		else:
			self._chip_removal = value

	@property
	def oriented_spindle_stop(self):
		return self._oriented_spindle_stop
	@oriented_spindle_stop.setter
	def oriented_spindle_stop(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,direction):
				self._oriented_spindle_stop = direction(value)
			else:
				self._oriented_spindle_stop = value
		else:
			self._oriented_spindle_stop = value

	@property
	def its_process_model(self):
		return self._its_process_model
	@its_process_model.setter
	def its_process_model(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,process_model_list):
				self._its_process_model = process_model_list(value)
			else:
				self._its_process_model = value
		else:
			self._its_process_model = value

	@property
	def other_functions(self):
		return self._other_functions
	@other_functions.setter
	def other_functions(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(0,None,'property_parameter', scope = schema_scope)):
			self._other_functions = SET(value)
		else:
			self._other_functions = value

	@property
	def axis_constraints(self):
		return self._axis_constraints
	@axis_constraints.setter
	def axis_constraints(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,SET(0,None,'machine_axis_constraint', scope = schema_scope)):
				self._axis_constraints = SET(value)
			else:
				self._axis_constraints = value
		else:
			self._axis_constraints = value

####################
 # ENTITY topological_region #
####################
class topological_region(region):
	'''Entity topological_region definition.
	'''
	def __init__( self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement ,  ):
		region.__init__(self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , )

####################
 # ENTITY tool_length_probing #
####################
class tool_length_probing(tool_probing):
	'''Entity tool_length_probing definition.
	'''
	def __init__( self , inherited0__its_id , inherited1__its_secplane , inherited2__its_toolpath , inherited3__its_tool_direction , inherited4__measured_offset , inherited5__offset , inherited6__max_wear , inherited7__its_tool ,  ):
		tool_probing.__init__(self , inherited0__its_id , inherited1__its_secplane , inherited2__its_toolpath , inherited3__its_tool_direction , inherited4__measured_offset , inherited5__offset , inherited6__max_wear , inherited7__its_tool , )

####################
 # ENTITY curved_size_dimension #
####################
class curved_size_dimension(size_dimension):
	'''Entity curved_size_dimension definition.
	'''
	def __init__( self , inherited0__id , inherited1__dimension_value , inherited2__notes , inherited3__applied_to , inherited4__envelope_principle ,  ):
		size_dimension.__init__(self , inherited0__id , inherited1__dimension_value , inherited2__notes , inherited3__applied_to , inherited4__envelope_principle , )

####################
 # ENTITY countersunk_hole #
####################
class countersunk_hole(compound_feature):
	'''Entity countersunk_hole definition.
	'''
	def __init__( self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , inherited5__elements , inherited6__feature_description , inherited7__feature_name ,  ):
		compound_feature.__init__(self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , inherited5__elements , inherited6__feature_description , inherited7__feature_name , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(self.elements)  ==  2)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  2)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (self.self.elements[1].self.diameter.self.theoretical_size  !=  self.self.elements[2].self.diameter.self.theoretical_size)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (( not EXISTS(self.self.elements[1].self.change_in_diameter))  and  EXISTS(self.self.elements[2].self.change_in_diameter))
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr


####################
 # ENTITY along_path #
####################
class along_path(approach_retract_strategy):
	'''Entity along_path definition.

	:param path
	:type path:toolpath_list
	'''
	def __init__( self , inherited0__tool_orientation , path, ):
		approach_retract_strategy.__init__(self , inherited0__tool_orientation , )
		self._path = path

	@property
	def path(self):
		return self._path
	@path.setter
	def path(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,toolpath_list):
			self._path = toolpath_list(value)
		else:
			self._path = value

####################
 # ENTITY revolved_round #
####################
class revolved_round(revolved_feature):
	'''Entity revolved_round definition.

	:param rounded_edge_shape
	:type rounded_edge_shape:partial_circular_profile
	'''
	def __init__( self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , inherited5__material_side , inherited6__radius , rounded_edge_shape, ):
		revolved_feature.__init__(self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , inherited5__material_side , inherited6__radius , )
		self._rounded_edge_shape = rounded_edge_shape

	@property
	def rounded_edge_shape(self):
		return self._rounded_edge_shape
	@rounded_edge_shape.setter
	def rounded_edge_shape(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,partial_circular_profile):
			self._rounded_edge_shape = partial_circular_profile(value)
		else:
			self._rounded_edge_shape = value

####################
 # ENTITY step #
####################
class step(machining_feature):
	'''Entity step definition.

	:param open_boundary
	:type open_boundary:linear_path

	:param wall_boundary
	:type wall_boundary:vee_profile

	:param its_boss
	:type its_boss:SET(0,None,'boss', scope = schema_scope)
	'''
	def __init__( self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , inherited5__depth , open_boundary,wall_boundary,its_boss, ):
		machining_feature.__init__(self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , inherited5__depth , )
		self._open_boundary = open_boundary
		self._wall_boundary = wall_boundary
		self._its_boss = its_boss

	@property
	def open_boundary(self):
		return self._open_boundary
	@open_boundary.setter
	def open_boundary(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,linear_path):
			self._open_boundary = linear_path(value)
		else:
			self._open_boundary = value

	@property
	def wall_boundary(self):
		return self._wall_boundary
	@wall_boundary.setter
	def wall_boundary(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,vee_profile):
				self._wall_boundary = vee_profile(value)
			else:
				self._wall_boundary = value
		else:
			self._wall_boundary = value

	@property
	def its_boss(self):
		return self._its_boss
	@its_boss.setter
	def its_boss(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(0,None,'boss', scope = schema_scope)):
			self._its_boss = SET(value)
		else:
			self._its_boss = value

####################
 # ENTITY axis_trajectory #
####################
class axis_trajectory(trajectory):
	'''Entity axis_trajectory definition.

	:param axis_list
	:type axis_list:LIST(1,None,'STRING', scope = schema_scope)

	:param commands
	:type commands:LIST(1,None,'STRING', scope = schema_scope)
	'''
	def __init__( self , inherited0__its_priority , inherited1__its_type , inherited2__its_speed , inherited3__its_technology , inherited4__its_machine_functions , inherited5__its_id , inherited6__its_direction , inherited7__its_material_removal_depth , inherited8__its_material_removal_overcut , inherited9__its_material_removal_total_volume , axis_list,commands, ):
		trajectory.__init__(self , inherited0__its_priority , inherited1__its_type , inherited2__its_speed , inherited3__its_technology , inherited4__its_machine_functions , inherited5__its_id , inherited6__its_direction , inherited7__its_material_removal_depth , inherited8__its_material_removal_overcut , inherited9__its_material_removal_total_volume , )
		self._axis_list = axis_list
		self._commands = commands

	@property
	def axis_list(self):
		return self._axis_list
	@axis_list.setter
	def axis_list(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,LIST(1,None,'STRING', scope = schema_scope)):
			self._axis_list = LIST(value)
		else:
			self._axis_list = value

	@property
	def commands(self):
		return self._commands
	@commands.setter
	def commands(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,LIST(1,None,'STRING', scope = schema_scope)):
			self._commands = LIST(value)
		else:
			self._commands = value

####################
 # ENTITY spotdrill #
####################
class spotdrill(drilling_cutting_tool):
	'''Entity spotdrill definition.
	'''
	def __init__( self , inherited0__its_id , inherited1__its_usage , inherited2__its_cutting_edges , inherited3__overall_assembly_length , inherited4__effective_cutting_diameter , inherited5__maximum_depth_of_cut , inherited6__hand_of_cut , inherited7__coolant_through_tool , inherited8__point_angle ,  ):
		drilling_cutting_tool.__init__(self , inherited0__its_id , inherited1__its_usage , inherited2__its_cutting_edges , inherited3__overall_assembly_length , inherited4__effective_cutting_diameter , inherited5__maximum_depth_of_cut , inherited6__hand_of_cut , inherited7__coolant_through_tool , inherited8__point_angle , )

####################
 # ENTITY thread_mill #
####################
class thread_mill(milling_cutting_tool):
	'''Entity thread_mill definition.

	:param thread_form_type
	:type thread_form_type:STRING

	:param thread_size
	:type thread_size:length_measure

	:param thread_pitch
	:type thread_pitch:REAL
	'''
	def __init__( self , inherited0__its_id , inherited1__its_usage , inherited2__its_cutting_edges , inherited3__overall_assembly_length , inherited4__effective_cutting_diameter , inherited5__maximum_depth_of_cut , inherited6__hand_of_cut , inherited7__coolant_through_tool , inherited8__number_of_effective_teeth , inherited9__edge_radius , thread_form_type,thread_size,thread_pitch, ):
		milling_cutting_tool.__init__(self , inherited0__its_id , inherited1__its_usage , inherited2__its_cutting_edges , inherited3__overall_assembly_length , inherited4__effective_cutting_diameter , inherited5__maximum_depth_of_cut , inherited6__hand_of_cut , inherited7__coolant_through_tool , inherited8__number_of_effective_teeth , inherited9__edge_radius , )
		self._thread_form_type = thread_form_type
		self._thread_size = thread_size
		self._thread_pitch = thread_pitch

	@property
	def thread_form_type(self):
		return self._thread_form_type
	@thread_form_type.setter
	def thread_form_type(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,STRING):
			self._thread_form_type = STRING(value)
		else:
			self._thread_form_type = value

	@property
	def thread_size(self):
		return self._thread_size
	@thread_size.setter
	def thread_size(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,length_measure):
			self._thread_size = length_measure(value)
		else:
			self._thread_size = value

	@property
	def thread_pitch(self):
		return self._thread_pitch
	@thread_pitch.setter
	def thread_pitch(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,REAL):
			self._thread_pitch = REAL(value)
		else:
			self._thread_pitch = value

####################
 # ENTITY tapping_cutting_tool #
####################
class tapping_cutting_tool(milling_machine_cutting_tool):
	'''Entity tapping_cutting_tool definition.

	:param thread_form_type
	:type thread_form_type:STRING

	:param thread_size
	:type thread_size:length_measure

	:param thread_pitch
	:type thread_pitch:REAL

	:param taper_thread_count
	:type taper_thread_count:REAL
	'''
	def __init__( self , inherited0__its_id , inherited1__its_usage , inherited2__its_cutting_edges , inherited3__overall_assembly_length , inherited4__effective_cutting_diameter , inherited5__maximum_depth_of_cut , inherited6__hand_of_cut , inherited7__coolant_through_tool , thread_form_type,thread_size,thread_pitch,taper_thread_count, ):
		milling_machine_cutting_tool.__init__(self , inherited0__its_id , inherited1__its_usage , inherited2__its_cutting_edges , inherited3__overall_assembly_length , inherited4__effective_cutting_diameter , inherited5__maximum_depth_of_cut , inherited6__hand_of_cut , inherited7__coolant_through_tool , )
		self._thread_form_type = thread_form_type
		self._thread_size = thread_size
		self._thread_pitch = thread_pitch
		self._taper_thread_count = taper_thread_count

	@property
	def thread_form_type(self):
		return self._thread_form_type
	@thread_form_type.setter
	def thread_form_type(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,STRING):
			self._thread_form_type = STRING(value)
		else:
			self._thread_form_type = value

	@property
	def thread_size(self):
		return self._thread_size
	@thread_size.setter
	def thread_size(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,length_measure):
			self._thread_size = length_measure(value)
		else:
			self._thread_size = value

	@property
	def thread_pitch(self):
		return self._thread_pitch
	@thread_pitch.setter
	def thread_pitch(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,REAL):
			self._thread_pitch = REAL(value)
		else:
			self._thread_pitch = value

	@property
	def taper_thread_count(self):
		return self._taper_thread_count
	@taper_thread_count.setter
	def taper_thread_count(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,REAL):
			self._taper_thread_count = REAL(value)
		else:
			self._taper_thread_count = value

####################
 # ENTITY flat_slot_end_type #
####################
class flat_slot_end_type(slot_end_type):
	'''Entity flat_slot_end_type definition.

	:param corner_radius1
	:type corner_radius1:toleranced_length_measure

	:param corner_radius2
	:type corner_radius2:toleranced_length_measure
	'''
	def __init__( self , corner_radius1,corner_radius2, ):
		slot_end_type.__init__(self , )
		self._corner_radius1 = corner_radius1
		self._corner_radius2 = corner_radius2

	@property
	def corner_radius1(self):
		return self._corner_radius1
	@corner_radius1.setter
	def corner_radius1(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,toleranced_length_measure):
			self._corner_radius1 = toleranced_length_measure(value)
		else:
			self._corner_radius1 = value

	@property
	def corner_radius2(self):
		return self._corner_radius2
	@corner_radius2.setter
	def corner_radius2(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,toleranced_length_measure):
			self._corner_radius2 = toleranced_length_measure(value)
		else:
			self._corner_radius2 = value

####################
 # ENTITY drilling #
####################
class drilling(drilling_operation):
	'''Entity drilling definition.
	'''
	def __init__( self , inherited0__its_toolpath , inherited1__its_tool_direction , inherited2__its_id , inherited3__retract_plane , inherited4__start_point , inherited5__its_tool , inherited6__its_technology , inherited7__its_machine_functions , inherited8__overcut_length , inherited9__cutting_depth , inherited10__previous_diameter , inherited11__dwell_time_bottom , inherited12__feed_on_retract , inherited13__its_machining_strategy ,  ):
		drilling_operation.__init__(self , inherited0__its_toolpath , inherited1__its_tool_direction , inherited2__its_id , inherited3__retract_plane , inherited4__start_point , inherited5__its_tool , inherited6__its_technology , inherited7__its_machine_functions , inherited8__overcut_length , inherited9__cutting_depth , inherited10__previous_diameter , inherited11__dwell_time_bottom , inherited12__feed_on_retract , inherited13__its_machining_strategy , )

####################
 # ENTITY ap_lift_path_angle #
####################
class ap_lift_path_angle(approach_lift_path):
	'''Entity ap_lift_path_angle definition.

	:param angle
	:type angle:plane_angle_measure

	:param benddist
	:type benddist:length_measure
	'''
	def __init__( self , inherited0__its_priority , inherited1__its_type , inherited2__its_speed , inherited3__its_technology , inherited4__its_machine_functions , inherited5__its_id , inherited6__fix_point , inherited7__fix_point_dir , angle,benddist, ):
		approach_lift_path.__init__(self , inherited0__its_priority , inherited1__its_type , inherited2__its_speed , inherited3__its_technology , inherited4__its_machine_functions , inherited5__its_id , inherited6__fix_point , inherited7__fix_point_dir , )
		self._angle = angle
		self._benddist = benddist

	@property
	def angle(self):
		return self._angle
	@angle.setter
	def angle(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,plane_angle_measure):
			self._angle = plane_angle_measure(value)
		else:
			self._angle = value

	@property
	def benddist(self):
		return self._benddist
	@benddist.setter
	def benddist(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,length_measure):
			self._benddist = length_measure(value)
		else:
			self._benddist = value

####################
 # ENTITY diameter_size_dimension #
####################
class diameter_size_dimension(size_dimension):
	'''Entity diameter_size_dimension definition.
	'''
	def __init__( self , inherited0__id , inherited1__dimension_value , inherited2__notes , inherited3__applied_to , inherited4__envelope_principle ,  ):
		size_dimension.__init__(self , inherited0__id , inherited1__dimension_value , inherited2__notes , inherited3__applied_to , inherited4__envelope_principle , )

####################
 # ENTITY load_tool #
####################
class load_tool(nc_function):
	'''Entity load_tool definition.

	:param its_tool
	:type its_tool:machining_tool
	'''
	def __init__( self , inherited0__its_id , its_tool, ):
		nc_function.__init__(self , inherited0__its_id , )
		self._its_tool = its_tool

	@property
	def its_tool(self):
		return self._its_tool
	@its_tool.setter
	def its_tool(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,machining_tool):
			self._its_tool = machining_tool(value)
		else:
			self._its_tool = value

####################
 # ENTITY freeform_finish_milling #
####################
class freeform_finish_milling(freeform_operation):
	'''Entity freeform_finish_milling definition.
	'''
	def __init__( self , inherited0__its_toolpath , inherited1__its_tool_direction , inherited2__its_id , inherited3__retract_plane , inherited4__start_point , inherited5__its_tool , inherited6__its_technology , inherited7__its_machine_functions , inherited8__overcut_length , inherited9__approach , inherited10__retract , inherited11__its_machining_strategy ,  ):
		freeform_operation.__init__(self , inherited0__its_toolpath , inherited1__its_tool_direction , inherited2__its_id , inherited3__retract_plane , inherited4__start_point , inherited5__its_tool , inherited6__its_technology , inherited7__its_machine_functions , inherited8__overcut_length , inherited9__approach , inherited10__retract , inherited11__its_machining_strategy , )

####################
 # ENTITY concentricity_tolerance #
####################
class concentricity_tolerance(geometric_tolerance):
	'''Entity concentricity_tolerance definition.

	:param reference_datum
	:type reference_datum:SET(1,2,'datum_reference', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__applied_to , inherited2__modification , inherited3__qualifying_note , inherited4__segment_size , inherited5__significant_digits , inherited6__tolerance_value , reference_datum, ):
		geometric_tolerance.__init__(self , inherited0__name , inherited1__applied_to , inherited2__modification , inherited3__qualifying_note , inherited4__segment_size , inherited5__significant_digits , inherited6__tolerance_value , )
		self._reference_datum = reference_datum

	@property
	def reference_datum(self):
		return self._reference_datum
	@reference_datum.setter
	def reference_datum(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(1,2,'datum_reference', scope = schema_scope)):
			self._reference_datum = SET(value)
		else:
			self._reference_datum = value

####################
 # ENTITY general_pocket_bottom_condition #
####################
class general_pocket_bottom_condition(pocket_bottom_condition):
	'''Entity general_pocket_bottom_condition definition.

	:param shape
	:type shape:region
	'''
	def __init__( self , shape, ):
		pocket_bottom_condition.__init__(self , )
		self._shape = shape

	@property
	def shape(self):
		return self._shape
	@shape.setter
	def shape(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,region):
			self._shape = region(value)
		else:
			self._shape = value
	def wr1(self):
		eval_wr1_wr = (SIZEOF(self.shape.self.manufacturing_feature.self.its_operations)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY ap_retract_tangent #
####################
class ap_retract_tangent(air_strategy):
	'''Entity ap_retract_tangent definition.

	:param radius
	:type radius:length_measure
	'''
	def __init__( self , inherited0__tool_orientation , radius, ):
		air_strategy.__init__(self , inherited0__tool_orientation , )
		self._radius = radius

	@property
	def radius(self):
		return self._radius
	@radius.setter
	def radius(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,length_measure):
			self._radius = length_measure(value)
		else:
			self._radius = value

####################
 # ENTITY turning_workingstep #
####################
class turning_workingstep(workingstep):
	'''Entity turning_workingstep definition.

	:param its_features
	:type its_features:LIST(2,None,'manufacturing_feature', scope = schema_scope)

	:param its_operation
	:type its_operation:turning_machining_operation

	:param its_effect
	:type its_effect:in_process_geometry
	'''
	def __init__( self , inherited0__its_id , inherited1__its_secplane , its_features,its_operation,its_effect, ):
		workingstep.__init__(self , inherited0__its_id , inherited1__its_secplane , )
		self._its_features = its_features
		self._its_operation = its_operation
		self._its_effect = its_effect

	@property
	def its_features(self):
		return self._its_features
	@its_features.setter
	def its_features(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,LIST(2,None,'manufacturing_feature', scope = schema_scope)):
			self._its_features = LIST(value)
		else:
			self._its_features = value

	@property
	def its_operation(self):
		return self._its_operation
	@its_operation.setter
	def its_operation(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,turning_machining_operation):
			self._its_operation = turning_machining_operation(value)
		else:
			self._its_operation = value

	@property
	def its_effect(self):
		return self._its_effect
	@its_effect.setter
	def its_effect(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,in_process_geometry):
				self._its_effect = in_process_geometry(value)
			else:
				self._its_effect = value
		else:
			self._its_effect = value

####################
 # ENTITY knurling #
####################
class knurling(turning_machining_operation):
	'''Entity knurling definition.
	'''
	def __init__( self , inherited0__its_toolpath , inherited1__its_tool_direction , inherited2__its_id , inherited3__retract_plane , inherited4__start_point , inherited5__its_tool , inherited6__its_technology , inherited7__its_machine_functions , inherited8__approach , inherited9__retract , inherited10__its_machining_strategy ,  ):
		turning_machining_operation.__init__(self , inherited0__its_toolpath , inherited1__its_tool_direction , inherited2__its_id , inherited3__retract_plane , inherited4__start_point , inherited5__its_tool , inherited6__its_technology , inherited7__its_machine_functions , inherited8__approach , inherited9__retract , inherited10__its_machining_strategy , )

####################
 # ENTITY perpendicularity_tolerance #
####################
class perpendicularity_tolerance(geometric_tolerance):
	'''Entity perpendicularity_tolerance definition.

	:param affected_plane
	:type affected_plane:axis_placement

	:param reference_datum
	:type reference_datum:SET(1,3,'datum_reference', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__applied_to , inherited2__modification , inherited3__qualifying_note , inherited4__segment_size , inherited5__significant_digits , inherited6__tolerance_value , affected_plane,reference_datum, ):
		geometric_tolerance.__init__(self , inherited0__name , inherited1__applied_to , inherited2__modification , inherited3__qualifying_note , inherited4__segment_size , inherited5__significant_digits , inherited6__tolerance_value , )
		self._affected_plane = affected_plane
		self._reference_datum = reference_datum

	@property
	def affected_plane(self):
		return self._affected_plane
	@affected_plane.setter
	def affected_plane(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,axis_placement):
				self._affected_plane = axis_placement(value)
			else:
				self._affected_plane = value
		else:
			self._affected_plane = value

	@property
	def reference_datum(self):
		return self._reference_datum
	@reference_datum.setter
	def reference_datum(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(1,3,'datum_reference', scope = schema_scope)):
			self._reference_datum = SET(value)
		else:
			self._reference_datum = value

####################
 # ENTITY target_straight_line #
####################
class target_straight_line(placed_target):
	'''Entity target_straight_line definition.

	:param target_length
	:type target_length:value_with_unit
	'''
	def __init__( self , inherited0__id , inherited1__defined_in , inherited2__parameter_reference , target_length, ):
		placed_target.__init__(self , inherited0__id , inherited1__defined_in , inherited2__parameter_reference , )
		self._target_length = target_length

	@property
	def target_length(self):
		return self._target_length
	@target_length.setter
	def target_length(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,value_with_unit):
			self._target_length = value_with_unit(value)
		else:
			self._target_length = value

####################
 # ENTITY offset_vector #
####################
class offset_vector(BaseEntityClass):
	'''Entity offset_vector definition.

	:param translate
	:type translate:LIST(3,3,'nc_variable', scope = schema_scope)

	:param rotate
	:type rotate:LIST(3,3,'nc_variable', scope = schema_scope)
	'''
	def __init__( self , translate,rotate, ):
		self._translate = translate
		self._rotate = rotate

	@property
	def translate(self):
		return self._translate
	@translate.setter
	def translate(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,LIST(3,3,'nc_variable', scope = schema_scope)):
			self._translate = LIST(value)
		else:
			self._translate = value

	@property
	def rotate(self):
		return self._rotate
	@rotate.setter
	def rotate(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,LIST(3,3,'nc_variable', scope = schema_scope)):
				self._rotate = LIST(value)
			else:
				self._rotate = value
		else:
			self._rotate = value
	def wr1(self):
		eval_wr1_wr = ((SIZEOF(None)  ==  0)  and  (( not EXISTS(self.rotate))  or  (SIZEOF(None)  ==  0)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY bullnose_endmill #
####################
class bullnose_endmill(endmill):
	'''Entity bullnose_endmill definition.
	'''
	def __init__( self , inherited0__its_id , inherited1__its_usage , inherited2__its_cutting_edges , inherited3__overall_assembly_length , inherited4__effective_cutting_diameter , inherited5__maximum_depth_of_cut , inherited6__hand_of_cut , inherited7__coolant_through_tool , inherited8__number_of_effective_teeth , inherited9__edge_radius , inherited10__tool_cutting_edge_angle ,  ):
		endmill.__init__(self , inherited0__its_id , inherited1__its_usage , inherited2__its_cutting_edges , inherited3__overall_assembly_length , inherited4__effective_cutting_diameter , inherited5__maximum_depth_of_cut , inherited6__hand_of_cut , inherited7__coolant_through_tool , inherited8__number_of_effective_teeth , inherited9__edge_radius , inherited10__tool_cutting_edge_angle , )
	def wr1(self):
		eval_wr1_wr = ((EXISTS(self.self.edge_radius)  and  EXISTS(self.self.effective_cutting_diameter))  and  (self.self.edge_radius  <  (self.self.effective_cutting_diameter / 2)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY rectangular_omit #
####################
class rectangular_omit(BaseEntityClass):
	'''Entity rectangular_omit definition.

	:param row_index
	:type row_index:INTEGER

	:param column_index
	:type column_index:INTEGER
	'''
	def __init__( self , row_index,column_index, ):
		self._row_index = row_index
		self._column_index = column_index

	@property
	def row_index(self):
		return self._row_index
	@row_index.setter
	def row_index(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,INTEGER):
			self._row_index = INTEGER(value)
		else:
			self._row_index = value

	@property
	def column_index(self):
		return self._column_index
	@column_index.setter
	def column_index(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,INTEGER):
			self._column_index = INTEGER(value)
		else:
			self._column_index = value

####################
 # ENTITY radial_size_dimension #
####################
class radial_size_dimension(size_dimension):
	'''Entity radial_size_dimension definition.

	:param radius_type
	:type radius_type:STRING
	'''
	def __init__( self , inherited0__id , inherited1__dimension_value , inherited2__notes , inherited3__applied_to , inherited4__envelope_principle , radius_type, ):
		size_dimension.__init__(self , inherited0__id , inherited1__dimension_value , inherited2__notes , inherited3__applied_to , inherited4__envelope_principle , )
		self._radius_type = radius_type

	@property
	def radius_type(self):
		return self._radius_type
	@radius_type.setter
	def radius_type(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,STRING):
				self._radius_type = STRING(value)
			else:
				self._radius_type = value
		else:
			self._radius_type = value

####################
 # ENTITY target_area #
####################
class target_area(datum_target):
	'''Entity target_area definition.
	'''
	def __init__( self , inherited0__id ,  ):
		datum_target.__init__(self , inherited0__id , )

####################
 # ENTITY straightness_tolerance #
####################
class straightness_tolerance(geometric_tolerance):
	'''Entity straightness_tolerance definition.

	:param affected_plane
	:type affected_plane:axis_placement
	'''
	def __init__( self , inherited0__name , inherited1__applied_to , inherited2__modification , inherited3__qualifying_note , inherited4__segment_size , inherited5__significant_digits , inherited6__tolerance_value , affected_plane, ):
		geometric_tolerance.__init__(self , inherited0__name , inherited1__applied_to , inherited2__modification , inherited3__qualifying_note , inherited4__segment_size , inherited5__significant_digits , inherited6__tolerance_value , )
		self._affected_plane = affected_plane

	@property
	def affected_plane(self):
		return self._affected_plane
	@affected_plane.setter
	def affected_plane(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,axis_placement):
				self._affected_plane = axis_placement(value)
			else:
				self._affected_plane = value
		else:
			self._affected_plane = value

####################
 # ENTITY chamfered_corner #
####################
class chamfered_corner(BaseEntityClass):
	'''Entity chamfered_corner definition.

	:param corner_chamfer_angle
	:type corner_chamfer_angle:plane_angle_measure

	:param corner_chamfer_length
	:type corner_chamfer_length:length_measure

	:param corner_chamfer_width
	:type corner_chamfer_width:length_measure
	'''
	def __init__( self , corner_chamfer_angle,corner_chamfer_length,corner_chamfer_width, ):
		self._corner_chamfer_angle = corner_chamfer_angle
		self._corner_chamfer_length = corner_chamfer_length
		self._corner_chamfer_width = corner_chamfer_width

	@property
	def corner_chamfer_angle(self):
		return self._corner_chamfer_angle
	@corner_chamfer_angle.setter
	def corner_chamfer_angle(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,plane_angle_measure):
			self._corner_chamfer_angle = plane_angle_measure(value)
		else:
			self._corner_chamfer_angle = value

	@property
	def corner_chamfer_length(self):
		return self._corner_chamfer_length
	@corner_chamfer_length.setter
	def corner_chamfer_length(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,length_measure):
				self._corner_chamfer_length = length_measure(value)
			else:
				self._corner_chamfer_length = value
		else:
			self._corner_chamfer_length = value

	@property
	def corner_chamfer_width(self):
		return self._corner_chamfer_width
	@corner_chamfer_width.setter
	def corner_chamfer_width(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,length_measure):
				self._corner_chamfer_width = length_measure(value)
			else:
				self._corner_chamfer_width = value
		else:
			self._corner_chamfer_width = value

####################
 # ENTITY common_datum #
####################
class common_datum(datum):
	'''Entity common_datum definition.

	:param made_up_by
	:type made_up_by:SET(2,None,'single_datum', scope = schema_scope)
	'''
	def __init__( self , made_up_by, ):
		datum.__init__(self , )
		self._made_up_by = made_up_by

	@property
	def made_up_by(self):
		return self._made_up_by
	@made_up_by.setter
	def made_up_by(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(2,None,'single_datum', scope = schema_scope)):
			self._made_up_by = SET(value)
		else:
			self._made_up_by = value

####################
 # ENTITY diameter_taper #
####################
class diameter_taper(BaseEntityClass):
	'''Entity diameter_taper definition.

	:param final_diameter
	:type final_diameter:toleranced_length_measure
	'''
	def __init__( self , final_diameter, ):
		self._final_diameter = final_diameter

	@property
	def final_diameter(self):
		return self._final_diameter
	@final_diameter.setter
	def final_diameter(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,toleranced_length_measure):
			self._final_diameter = toleranced_length_measure(value)
		else:
			self._final_diameter = value

####################
 # ENTITY binary_boolean_expression #
####################
class binary_boolean_expression(boolean_expression):
	'''Entity binary_boolean_expression definition.

	:param operand1
	:type operand1:boolean_expression

	:param operand2
	:type operand2:boolean_expression
	'''
	def __init__( self , operand1,operand2, ):
		boolean_expression.__init__(self , )
		self._operand1 = operand1
		self._operand2 = operand2

	@property
	def operand1(self):
		return self._operand1
	@operand1.setter
	def operand1(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,boolean_expression):
			self._operand1 = boolean_expression(value)
		else:
			self._operand1 = value

	@property
	def operand2(self):
		return self._operand2
	@operand2.setter
	def operand2(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,boolean_expression):
			self._operand2 = boolean_expression(value)
		else:
			self._operand2 = value

####################
 # ENTITY xor_expression #
####################
class xor_expression(binary_boolean_expression):
	'''Entity xor_expression definition.
	'''
	def __init__( self , inherited0__operand1 , inherited1__operand2 ,  ):
		binary_boolean_expression.__init__(self , inherited0__operand1 , inherited1__operand2 , )

####################
 # ENTITY cutting_in #
####################
class cutting_in(grooving):
	'''Entity cutting_in definition.
	'''
	def __init__( self , inherited0__its_toolpath , inherited1__its_tool_direction , inherited2__its_id , inherited3__retract_plane , inherited4__start_point , inherited5__its_tool , inherited6__its_technology , inherited7__its_machine_functions , inherited8__approach , inherited9__retract , inherited10__its_machining_strategy , inherited11__dwell , inherited12__allowance ,  ):
		grooving.__init__(self , inherited0__its_toolpath , inherited1__its_tool_direction , inherited2__its_id , inherited3__retract_plane , inherited4__start_point , inherited5__its_tool , inherited6__its_technology , inherited7__its_machine_functions , inherited8__approach , inherited9__retract , inherited10__its_machining_strategy , inherited11__dwell , inherited12__allowance , )
	def wr1(self):
		eval_wr1_wr = ( not EXISTS(self.self.allowance))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY limits_and_fits #
####################
class limits_and_fits(BaseEntityClass):
	'''Entity limits_and_fits definition.

	:param deviation
	:type deviation:STRING

	:param grade
	:type grade:STRING

	:param its_fitting_type
	:type its_fitting_type:STRING
	'''
	def __init__( self , deviation,grade,its_fitting_type, ):
		self._deviation = deviation
		self._grade = grade
		self._its_fitting_type = its_fitting_type

	@property
	def deviation(self):
		return self._deviation
	@deviation.setter
	def deviation(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,STRING):
			self._deviation = STRING(value)
		else:
			self._deviation = value

	@property
	def grade(self):
		return self._grade
	@grade.setter
	def grade(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,STRING):
			self._grade = STRING(value)
		else:
			self._grade = value

	@property
	def its_fitting_type(self):
		return self._its_fitting_type
	@its_fitting_type.setter
	def its_fitting_type(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,STRING):
				self._its_fitting_type = STRING(value)
			else:
				self._its_fitting_type = value
		else:
			self._its_fitting_type = value

####################
 # ENTITY partial_circular_path #
####################
class partial_circular_path(circular_path):
	'''Entity partial_circular_path definition.

	:param sweep_angle
	:type sweep_angle:plane_angle_measure
	'''
	def __init__( self , inherited0__placement , inherited1__radius , sweep_angle, ):
		circular_path.__init__(self , inherited0__placement , inherited1__radius , )
		self._sweep_angle = sweep_angle

	@property
	def sweep_angle(self):
		return self._sweep_angle
	@sweep_angle.setter
	def sweep_angle(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,plane_angle_measure):
			self._sweep_angle = plane_angle_measure(value)
		else:
			self._sweep_angle = value

####################
 # ENTITY tolerance_zone #
####################
class tolerance_zone(BaseEntityClass):
	'''Entity tolerance_zone definition.

	:param form_type
	:type form_type:STRING

	:param zone_for
	:type zone_for:SET(1,None,'geometric_tolerance', scope = schema_scope)
	'''
	def __init__( self , form_type,zone_for, ):
		self._form_type = form_type
		self._zone_for = zone_for

	@property
	def form_type(self):
		return self._form_type
	@form_type.setter
	def form_type(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,STRING):
			self._form_type = STRING(value)
		else:
			self._form_type = value

	@property
	def zone_for(self):
		return self._zone_for
	@zone_for.setter
	def zone_for(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(1,None,'geometric_tolerance', scope = schema_scope)):
			self._zone_for = SET(value)
		else:
			self._zone_for = value

####################
 # ENTITY target_circle #
####################
class target_circle(placed_target):
	'''Entity target_circle definition.

	:param diameter
	:type diameter:value_with_unit
	'''
	def __init__( self , inherited0__id , inherited1__defined_in , inherited2__parameter_reference , diameter, ):
		placed_target.__init__(self , inherited0__id , inherited1__defined_in , inherited2__parameter_reference , )
		self._diameter = diameter

	@property
	def diameter(self):
		return self._diameter
	@diameter.setter
	def diameter(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,value_with_unit):
			self._diameter = value_with_unit(value)
		else:
			self._diameter = value

####################
 # ENTITY five_axes_var_tilt_yaw #
####################
class five_axes_var_tilt_yaw(tool_direction_for_milling):
	'''Entity five_axes_var_tilt_yaw definition.
	'''
	def __init__( self ,  ):
		tool_direction_for_milling.__init__(self , )

####################
 # ENTITY plunge_helix #
####################
class plunge_helix(plunge_strategy):
	'''Entity plunge_helix definition.

	:param radius
	:type radius:length_measure

	:param angle
	:type angle:plane_angle_measure
	'''
	def __init__( self , inherited0__tool_orientation , radius,angle, ):
		plunge_strategy.__init__(self , inherited0__tool_orientation , )
		self._radius = radius
		self._angle = angle

	@property
	def radius(self):
		return self._radius
	@radius.setter
	def radius(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,length_measure):
			self._radius = length_measure(value)
		else:
			self._radius = value

	@property
	def angle(self):
		return self._angle
	@angle.setter
	def angle(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,plane_angle_measure):
			self._angle = plane_angle_measure(value)
		else:
			self._angle = value

####################
 # ENTITY closed_pocket #
####################
class closed_pocket(pocket):
	'''Entity closed_pocket definition.

	:param feature_boundary
	:type feature_boundary:closed_profile
	'''
	def __init__( self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , inherited5__depth , inherited6__its_boss , inherited7__slope , inherited8__bottom_condition , inherited9__planar_radius , inherited10__orthogonal_radius , inherited11__bottom_at_path_end , inherited12__course_of_travel , inherited13__top_fillet_radius , feature_boundary, ):
		pocket.__init__(self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , inherited5__depth , inherited6__its_boss , inherited7__slope , inherited8__bottom_condition , inherited9__planar_radius , inherited10__orthogonal_radius , inherited11__bottom_at_path_end , inherited12__course_of_travel , inherited13__top_fillet_radius , )
		self._feature_boundary = feature_boundary

	@property
	def feature_boundary(self):
		return self._feature_boundary
	@feature_boundary.setter
	def feature_boundary(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,closed_profile):
			self._feature_boundary = closed_profile(value)
		else:
			self._feature_boundary = value

####################
 # ENTITY edge_round #
####################
class edge_round(transition_feature):
	'''Entity edge_round definition.

	:param radius
	:type radius:toleranced_length_measure

	:param first_offset_amount
	:type first_offset_amount:toleranced_length_measure

	:param second_offset_amount
	:type second_offset_amount:toleranced_length_measure

	:param edge_round_face
	:type edge_round_face:SET(1,None,'STRING', scope = schema_scope)

	:param first_face_shape
	:type first_face_shape:SET(1,None,'STRING', scope = schema_scope)

	:param second_face_shape
	:type second_face_shape:SET(1,None,'STRING', scope = schema_scope)
	'''
	def __init__( self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__first_feature , inherited5__second_feature , radius,first_offset_amount,second_offset_amount,edge_round_face,first_face_shape,second_face_shape, ):
		transition_feature.__init__(self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__first_feature , inherited5__second_feature , )
		self._radius = radius
		self._first_offset_amount = first_offset_amount
		self._second_offset_amount = second_offset_amount
		self._edge_round_face = edge_round_face
		self._first_face_shape = first_face_shape
		self._second_face_shape = second_face_shape

	@property
	def radius(self):
		return self._radius
	@radius.setter
	def radius(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,toleranced_length_measure):
			self._radius = toleranced_length_measure(value)
		else:
			self._radius = value

	@property
	def first_offset_amount(self):
		return self._first_offset_amount
	@first_offset_amount.setter
	def first_offset_amount(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,toleranced_length_measure):
				self._first_offset_amount = toleranced_length_measure(value)
			else:
				self._first_offset_amount = value
		else:
			self._first_offset_amount = value

	@property
	def second_offset_amount(self):
		return self._second_offset_amount
	@second_offset_amount.setter
	def second_offset_amount(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,toleranced_length_measure):
				self._second_offset_amount = toleranced_length_measure(value)
			else:
				self._second_offset_amount = value
		else:
			self._second_offset_amount = value

	@property
	def edge_round_face(self):
		return self._edge_round_face
	@edge_round_face.setter
	def edge_round_face(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,SET(1,None,'STRING', scope = schema_scope)):
				self._edge_round_face = SET(value)
			else:
				self._edge_round_face = value
		else:
			self._edge_round_face = value

	@property
	def first_face_shape(self):
		return self._first_face_shape
	@first_face_shape.setter
	def first_face_shape(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,SET(1,None,'STRING', scope = schema_scope)):
				self._first_face_shape = SET(value)
			else:
				self._first_face_shape = value
		else:
			self._first_face_shape = value

	@property
	def second_face_shape(self):
		return self._second_face_shape
	@second_face_shape.setter
	def second_face_shape(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,SET(1,None,'STRING', scope = schema_scope)):
				self._second_face_shape = SET(value)
			else:
				self._second_face_shape = value
		else:
			self._second_face_shape = value

####################
 # ENTITY through_pocket_bottom_condition #
####################
class through_pocket_bottom_condition(pocket_bottom_condition):
	'''Entity through_pocket_bottom_condition definition.
	'''
	def __init__( self ,  ):
		pocket_bottom_condition.__init__(self , )

####################
 # ENTITY combined_drill_and_reamer #
####################
class combined_drill_and_reamer(reaming_cutting_tool):
	'''Entity combined_drill_and_reamer definition.

	:param drill_length
	:type drill_length:length_measure
	'''
	def __init__( self , inherited0__its_id , inherited1__its_usage , inherited2__its_cutting_edges , inherited3__overall_assembly_length , inherited4__effective_cutting_diameter , inherited5__maximum_depth_of_cut , inherited6__hand_of_cut , inherited7__coolant_through_tool , inherited8__taper_length , drill_length, ):
		reaming_cutting_tool.__init__(self , inherited0__its_id , inherited1__its_usage , inherited2__its_cutting_edges , inherited3__overall_assembly_length , inherited4__effective_cutting_diameter , inherited5__maximum_depth_of_cut , inherited6__hand_of_cut , inherited7__coolant_through_tool , inherited8__taper_length , )
		self._drill_length = drill_length

	@property
	def drill_length(self):
		return self._drill_length
	@drill_length.setter
	def drill_length(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,length_measure):
			self._drill_length = length_measure(value)
		else:
			self._drill_length = value

####################
 # ENTITY drilling_type_strategy #
####################
class drilling_type_strategy(BaseEntityClass):
	'''Entity drilling_type_strategy definition.

	:param reduced_cut_at_start
	:type reduced_cut_at_start:positive_ratio_measure

	:param reduced_feed_at_start
	:type reduced_feed_at_start:positive_ratio_measure

	:param depth_of_start
	:type depth_of_start:length_measure

	:param reduced_cut_at_end
	:type reduced_cut_at_end:positive_ratio_measure

	:param reduced_feed_at_end
	:type reduced_feed_at_end:positive_ratio_measure

	:param depth_of_end
	:type depth_of_end:length_measure
	'''
	def __init__( self , reduced_cut_at_start,reduced_feed_at_start,depth_of_start,reduced_cut_at_end,reduced_feed_at_end,depth_of_end, ):
		self._reduced_cut_at_start = reduced_cut_at_start
		self._reduced_feed_at_start = reduced_feed_at_start
		self._depth_of_start = depth_of_start
		self._reduced_cut_at_end = reduced_cut_at_end
		self._reduced_feed_at_end = reduced_feed_at_end
		self._depth_of_end = depth_of_end

	@property
	def reduced_cut_at_start(self):
		return self._reduced_cut_at_start
	@reduced_cut_at_start.setter
	def reduced_cut_at_start(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,positive_ratio_measure):
				self._reduced_cut_at_start = positive_ratio_measure(value)
			else:
				self._reduced_cut_at_start = value
		else:
			self._reduced_cut_at_start = value

	@property
	def reduced_feed_at_start(self):
		return self._reduced_feed_at_start
	@reduced_feed_at_start.setter
	def reduced_feed_at_start(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,positive_ratio_measure):
				self._reduced_feed_at_start = positive_ratio_measure(value)
			else:
				self._reduced_feed_at_start = value
		else:
			self._reduced_feed_at_start = value

	@property
	def depth_of_start(self):
		return self._depth_of_start
	@depth_of_start.setter
	def depth_of_start(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,length_measure):
				self._depth_of_start = length_measure(value)
			else:
				self._depth_of_start = value
		else:
			self._depth_of_start = value

	@property
	def reduced_cut_at_end(self):
		return self._reduced_cut_at_end
	@reduced_cut_at_end.setter
	def reduced_cut_at_end(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,positive_ratio_measure):
				self._reduced_cut_at_end = positive_ratio_measure(value)
			else:
				self._reduced_cut_at_end = value
		else:
			self._reduced_cut_at_end = value

	@property
	def reduced_feed_at_end(self):
		return self._reduced_feed_at_end
	@reduced_feed_at_end.setter
	def reduced_feed_at_end(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,positive_ratio_measure):
				self._reduced_feed_at_end = positive_ratio_measure(value)
			else:
				self._reduced_feed_at_end = value
		else:
			self._reduced_feed_at_end = value

	@property
	def depth_of_end(self):
		return self._depth_of_end
	@depth_of_end.setter
	def depth_of_end(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,length_measure):
				self._depth_of_end = length_measure(value)
			else:
				self._depth_of_end = value
		else:
			self._depth_of_end = value
	def wr1(self):
		eval_wr1_wr = (EXISTS(self.depth_of_start)  or  ( not (EXISTS(self.reduced_cut_at_start)  or  EXISTS(self.reduced_feed_at_start))))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (EXISTS(self.depth_of_end)  or  ( not (EXISTS(self.reduced_cut_at_end)  or  EXISTS(self.reduced_feed_at_end))))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY counterbore #
####################
class counterbore(drilling_cutting_tool):
	'''Entity counterbore definition.
	'''
	def __init__( self , inherited0__its_id , inherited1__its_usage , inherited2__its_cutting_edges , inherited3__overall_assembly_length , inherited4__effective_cutting_diameter , inherited5__maximum_depth_of_cut , inherited6__hand_of_cut , inherited7__coolant_through_tool , inherited8__point_angle ,  ):
		drilling_cutting_tool.__init__(self , inherited0__its_id , inherited1__its_usage , inherited2__its_cutting_edges , inherited3__overall_assembly_length , inherited4__effective_cutting_diameter , inherited5__maximum_depth_of_cut , inherited6__hand_of_cut , inherited7__coolant_through_tool , inherited8__point_angle , )

####################
 # ENTITY profiled_end_mill #
####################
class profiled_end_mill(endmill):
	'''Entity profiled_end_mill definition.
	'''
	def __init__( self , inherited0__its_id , inherited1__its_usage , inherited2__its_cutting_edges , inherited3__overall_assembly_length , inherited4__effective_cutting_diameter , inherited5__maximum_depth_of_cut , inherited6__hand_of_cut , inherited7__coolant_through_tool , inherited8__number_of_effective_teeth , inherited9__edge_radius , inherited10__tool_cutting_edge_angle ,  ):
		endmill.__init__(self , inherited0__its_id , inherited1__its_usage , inherited2__its_cutting_edges , inherited3__overall_assembly_length , inherited4__effective_cutting_diameter , inherited5__maximum_depth_of_cut , inherited6__hand_of_cut , inherited7__coolant_through_tool , inherited8__number_of_effective_teeth , inherited9__edge_radius , inherited10__tool_cutting_edge_angle , )

####################
 # ENTITY speed_measure #
####################
class speed_measure(value_with_tolerance):
	'''Entity speed_measure definition.
	'''
	def __init__( self , inherited0__unit , inherited1__value_component , inherited2__limitation , inherited3__significant_digits ,  ):
		value_with_tolerance.__init__(self , inherited0__unit , inherited1__value_component , inherited2__limitation , inherited3__significant_digits , )

####################
 # ENTITY touch_probe #
####################
class touch_probe(BaseEntityClass):
	'''Entity touch_probe definition.

	:param its_id
	:type its_id:identifier
	'''
	def __init__( self , its_id, ):
		self._its_id = its_id

	@property
	def its_id(self):
		return self._its_id
	@its_id.setter
	def its_id(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,identifier):
			self._its_id = identifier(value)
		else:
			self._its_id = value

####################
 # ENTITY flat_hole_bottom #
####################
class flat_hole_bottom(blind_bottom_condition):
	'''Entity flat_hole_bottom definition.
	'''
	def __init__( self ,  ):
		blind_bottom_condition.__init__(self , )

####################
 # ENTITY partial_circular_profile #
####################
class partial_circular_profile(open_profile):
	'''Entity partial_circular_profile definition.

	:param radius
	:type radius:toleranced_length_measure

	:param sweep_angle
	:type sweep_angle:plane_angle_measure
	'''
	def __init__( self , inherited0__placement , radius,sweep_angle, ):
		open_profile.__init__(self , inherited0__placement , )
		self._radius = radius
		self._sweep_angle = sweep_angle

	@property
	def radius(self):
		return self._radius
	@radius.setter
	def radius(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,toleranced_length_measure):
			self._radius = toleranced_length_measure(value)
		else:
			self._radius = value

	@property
	def sweep_angle(self):
		return self._sweep_angle
	@sweep_angle.setter
	def sweep_angle(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,plane_angle_measure):
			self._sweep_angle = plane_angle_measure(value)
		else:
			self._sweep_angle = value

####################
 # ENTITY assigned_time #
####################
class assigned_time(BaseEntityClass):
	'''Entity assigned_time definition.

	:param date_and_time_value
	:type date_and_time_value:date_and_time

	:param role
	:type role:STRING
	'''
	def __init__( self , date_and_time_value,role, ):
		self._date_and_time_value = date_and_time_value
		self._role = role

	@property
	def date_and_time_value(self):
		return self._date_and_time_value
	@date_and_time_value.setter
	def date_and_time_value(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,date_and_time):
			self._date_and_time_value = date_and_time(value)
		else:
			self._date_and_time_value = value

	@property
	def role(self):
		return self._role
	@role.setter
	def role(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,STRING):
			self._role = STRING(value)
		else:
			self._role = value

####################
 # ENTITY back_boring #
####################
class back_boring(drilling_type_operation):
	'''Entity back_boring definition.
	'''
	def __init__( self , inherited0__its_toolpath , inherited1__its_tool_direction , inherited2__its_id , inherited3__retract_plane , inherited4__start_point , inherited5__its_tool , inherited6__its_technology , inherited7__its_machine_functions , inherited8__overcut_length , inherited9__cutting_depth , inherited10__previous_diameter , inherited11__dwell_time_bottom , inherited12__feed_on_retract , inherited13__its_machining_strategy ,  ):
		drilling_type_operation.__init__(self , inherited0__its_toolpath , inherited1__its_tool_direction , inherited2__its_id , inherited3__retract_plane , inherited4__start_point , inherited5__its_tool , inherited6__its_technology , inherited7__its_machine_functions , inherited8__overcut_length , inherited9__cutting_depth , inherited10__previous_diameter , inherited11__dwell_time_bottom , inherited12__feed_on_retract , inherited13__its_machining_strategy , )
	def wr1(self):
		eval_wr1_wr = EXISTS(self.self.its_machine_functions.self.oriented_spindle_stop)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY spherical_hole_bottom #
####################
class spherical_hole_bottom(blind_bottom_condition):
	'''Entity spherical_hole_bottom definition.

	:param radius
	:type radius:toleranced_length_measure
	'''
	def __init__( self , radius, ):
		blind_bottom_condition.__init__(self , )
		self._radius = radius

	@property
	def radius(self):
		return self._radius
	@radius.setter
	def radius(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,toleranced_length_measure):
			self._radius = toleranced_length_measure(value)
		else:
			self._radius = value

####################
 # ENTITY circular_omit #
####################
class circular_omit(BaseEntityClass):
	'''Entity circular_omit definition.

	:param index
	:type index:INTEGER
	'''
	def __init__( self , index, ):
		self._index = index

	@property
	def index(self):
		return self._index
	@index.setter
	def index(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,INTEGER):
			self._index = INTEGER(value)
		else:
			self._index = value

####################
 # ENTITY user_defined_turning_tool #
####################
class user_defined_turning_tool(turning_machine_cutting_tool):
	'''Entity user_defined_turning_tool definition.

	:param identifier
	:type identifier:label
	'''
	def __init__( self , inherited0__its_id , inherited1__its_usage , inherited2__functional_length , inherited3__f_dimension , inherited4__minimum_cutting_diameter , inherited5__a_dimension_on_f , inherited6__a_dimension_on_lf , inherited7__cutting_edge , inherited8__hand_of_tool , identifier, ):
		turning_machine_cutting_tool.__init__(self , inherited0__its_id , inherited1__its_usage , inherited2__functional_length , inherited3__f_dimension , inherited4__minimum_cutting_diameter , inherited5__a_dimension_on_f , inherited6__a_dimension_on_lf , inherited7__cutting_edge , inherited8__hand_of_tool , )
		self._identifier = identifier

	@property
	def identifier(self):
		return self._identifier
	@identifier.setter
	def identifier(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,label):
			self._identifier = label(value)
		else:
			self._identifier = value

####################
 # ENTITY countersink #
####################
class countersink(drilling_cutting_tool):
	'''Entity countersink definition.

	:param minimum_cutting_diameter
	:type minimum_cutting_diameter:length_measure

	:param maximum_usable_length
	:type maximum_usable_length:length_measure
	'''
	def __init__( self , inherited0__its_id , inherited1__its_usage , inherited2__its_cutting_edges , inherited3__overall_assembly_length , inherited4__effective_cutting_diameter , inherited5__maximum_depth_of_cut , inherited6__hand_of_cut , inherited7__coolant_through_tool , inherited8__point_angle , minimum_cutting_diameter,maximum_usable_length, ):
		drilling_cutting_tool.__init__(self , inherited0__its_id , inherited1__its_usage , inherited2__its_cutting_edges , inherited3__overall_assembly_length , inherited4__effective_cutting_diameter , inherited5__maximum_depth_of_cut , inherited6__hand_of_cut , inherited7__coolant_through_tool , inherited8__point_angle , )
		self._minimum_cutting_diameter = minimum_cutting_diameter
		self._maximum_usable_length = maximum_usable_length

	@property
	def minimum_cutting_diameter(self):
		return self._minimum_cutting_diameter
	@minimum_cutting_diameter.setter
	def minimum_cutting_diameter(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,length_measure):
				self._minimum_cutting_diameter = length_measure(value)
			else:
				self._minimum_cutting_diameter = value
		else:
			self._minimum_cutting_diameter = value

	@property
	def maximum_usable_length(self):
		return self._maximum_usable_length
	@maximum_usable_length.setter
	def maximum_usable_length(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,length_measure):
			self._maximum_usable_length = length_measure(value)
		else:
			self._maximum_usable_length = value

####################
 # ENTITY nc_variable #
####################
class nc_variable(BaseEntityClass):
	'''Entity nc_variable definition.

	:param its_name
	:type its_name:label

	:param initial_value
	:type initial_value:(null)
	'''
	def __init__( self , its_name,initial_value, ):
		self._its_name = its_name
		self._initial_value = initial_value

	@property
	def its_name(self):
		return self._its_name
	@its_name.setter
	def its_name(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,label):
			self._its_name = label(value)
		else:
			self._its_name = value

	@property
	def initial_value(self):
		return self._initial_value
	@initial_value.setter
	def initial_value(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,(null)):
				self._initial_value = (null)(value)
			else:
				self._initial_value = value
		else:
			self._initial_value = value

####################
 # ENTITY turning_technology #
####################
class turning_technology(technology):
	'''Entity turning_technology definition.

	:param spindle_speed
	:type spindle_speed:speed_select

	:param feed_per_revolution
	:type feed_per_revolution:feed_per_rev_type

	:param sync_spindle_and_z_feed
	:type sync_spindle_and_z_feed:BOOLEAN

	:param inhibit_feedrate_override
	:type inhibit_feedrate_override:BOOLEAN

	:param inhibit_spindle_override
	:type inhibit_spindle_override:BOOLEAN

	:param its_adaptive_control
	:type its_adaptive_control:adaptive_control
	'''
	def __init__( self , inherited0__feedrate , inherited1__feedrate_reference , spindle_speed,feed_per_revolution,sync_spindle_and_z_feed,inhibit_feedrate_override,inhibit_spindle_override,its_adaptive_control, ):
		technology.__init__(self , inherited0__feedrate , inherited1__feedrate_reference , )
		self._spindle_speed = spindle_speed
		self._feed_per_revolution = feed_per_revolution
		self._sync_spindle_and_z_feed = sync_spindle_and_z_feed
		self._inhibit_feedrate_override = inhibit_feedrate_override
		self._inhibit_spindle_override = inhibit_spindle_override
		self._its_adaptive_control = its_adaptive_control

	@property
	def spindle_speed(self):
		return self._spindle_speed
	@spindle_speed.setter
	def spindle_speed(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,speed_select):
			self._spindle_speed = speed_select(value)
		else:
			self._spindle_speed = value

	@property
	def feed_per_revolution(self):
		return self._feed_per_revolution
	@feed_per_revolution.setter
	def feed_per_revolution(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,feed_per_rev_type):
				self._feed_per_revolution = feed_per_rev_type(value)
			else:
				self._feed_per_revolution = value
		else:
			self._feed_per_revolution = value

	@property
	def sync_spindle_and_z_feed(self):
		return self._sync_spindle_and_z_feed
	@sync_spindle_and_z_feed.setter
	def sync_spindle_and_z_feed(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,BOOLEAN):
			self._sync_spindle_and_z_feed = BOOLEAN(value)
		else:
			self._sync_spindle_and_z_feed = value

	@property
	def inhibit_feedrate_override(self):
		return self._inhibit_feedrate_override
	@inhibit_feedrate_override.setter
	def inhibit_feedrate_override(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,BOOLEAN):
			self._inhibit_feedrate_override = BOOLEAN(value)
		else:
			self._inhibit_feedrate_override = value

	@property
	def inhibit_spindle_override(self):
		return self._inhibit_spindle_override
	@inhibit_spindle_override.setter
	def inhibit_spindle_override(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,BOOLEAN):
			self._inhibit_spindle_override = BOOLEAN(value)
		else:
			self._inhibit_spindle_override = value

	@property
	def its_adaptive_control(self):
		return self._its_adaptive_control
	@its_adaptive_control.setter
	def its_adaptive_control(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,adaptive_control):
				self._its_adaptive_control = adaptive_control(value)
			else:
				self._its_adaptive_control = value
		else:
			self._its_adaptive_control = value
	def wr1(self):
		eval_wr1_wr = ((EXISTS(self.self.feedrate)  and  ( not EXISTS(self.self.feed_per_revolution)))  or  (( not EXISTS(self.self.feedrate))  and  EXISTS(self.self.feed_per_revolution)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY multistep_grooving_strategy #
####################
class multistep_grooving_strategy(grooving_strategy):
	'''Entity multistep_grooving_strategy definition.

	:param retract_distance
	:type retract_distance:length_measure
	'''
	def __init__( self , inherited0__overcut_length , inherited1__allow_multiple_passes , inherited2__cutting_depth , inherited3__variable_feedrate , inherited4__grooving_direction , inherited5__travel_distance , retract_distance, ):
		grooving_strategy.__init__(self , inherited0__overcut_length , inherited1__allow_multiple_passes , inherited2__cutting_depth , inherited3__variable_feedrate , inherited4__grooving_direction , inherited5__travel_distance , )
		self._retract_distance = retract_distance

	@property
	def retract_distance(self):
		return self._retract_distance
	@retract_distance.setter
	def retract_distance(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,length_measure):
			self._retract_distance = length_measure(value)
		else:
			self._retract_distance = value

####################
 # ENTITY tapered_drill #
####################
class tapered_drill(twist_drill):
	'''Entity tapered_drill definition.

	:param taper_angle
	:type taper_angle:plane_angle_measure
	'''
	def __init__( self , inherited0__its_id , inherited1__its_usage , inherited2__its_cutting_edges , inherited3__overall_assembly_length , inherited4__effective_cutting_diameter , inherited5__maximum_depth_of_cut , inherited6__hand_of_cut , inherited7__coolant_through_tool , inherited8__point_angle , taper_angle, ):
		twist_drill.__init__(self , inherited0__its_id , inherited1__its_usage , inherited2__its_cutting_edges , inherited3__overall_assembly_length , inherited4__effective_cutting_diameter , inherited5__maximum_depth_of_cut , inherited6__hand_of_cut , inherited7__coolant_through_tool , inherited8__point_angle , )
		self._taper_angle = taper_angle

	@property
	def taper_angle(self):
		return self._taper_angle
	@taper_angle.setter
	def taper_angle(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,plane_angle_measure):
			self._taper_angle = plane_angle_measure(value)
		else:
			self._taper_angle = value

####################
 # ENTITY general_profile #
####################
class general_profile(open_profile):
	'''Entity general_profile definition.

	:param its_profile
	:type its_profile:path_shape_item
	'''
	def __init__( self , inherited0__placement , its_profile, ):
		open_profile.__init__(self , inherited0__placement , )
		self._its_profile = its_profile

	@property
	def its_profile(self):
		return self._its_profile
	@its_profile.setter
	def its_profile(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,path_shape_item):
			self._its_profile = path_shape_item(value)
		else:
			self._its_profile = value

####################
 # ENTITY planar_profile_floor #
####################
class planar_profile_floor(profile_floor):
	'''Entity planar_profile_floor definition.

	:param floor
	:type floor:plane
	'''
	def __init__( self , inherited0__floor_radius , inherited1__start_or_end , floor, ):
		profile_floor.__init__(self , inherited0__floor_radius , inherited1__start_or_end , )
		self._floor = floor

	@property
	def floor(self):
		return self._floor
	@floor.setter
	def floor(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,plane):
			self._floor = plane(value)
		else:
			self._floor = value

####################
 # ENTITY length_size_dimension #
####################
class length_size_dimension(size_dimension):
	'''Entity length_size_dimension definition.

	:param used_path
	:type used_path:measurement_path
	'''
	def __init__( self , inherited0__id , inherited1__dimension_value , inherited2__notes , inherited3__applied_to , inherited4__envelope_principle , used_path, ):
		size_dimension.__init__(self , inherited0__id , inherited1__dimension_value , inherited2__notes , inherited3__applied_to , inherited4__envelope_principle , )
		self._used_path = used_path

	@property
	def used_path(self):
		return self._used_path
	@used_path.setter
	def used_path(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,measurement_path):
				self._used_path = measurement_path(value)
			else:
				self._used_path = value
		else:
			self._used_path = value

####################
 # ENTITY defined_thread #
####################
class defined_thread(thread):
	'''Entity defined_thread definition.

	:param pitch_diameter
	:type pitch_diameter:length_measure

	:param minor_diameter
	:type minor_diameter:length_measure

	:param crest
	:type crest:length_measure
	'''
	def __init__( self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , inherited5__depth , inherited6__partial_profile , inherited7__applied_shape , inherited8__inner_or_outer_thread , inherited9__qualifier , inherited10__fit_class , inherited11__form , inherited12__major_diameter , inherited13__number_of_threads , inherited14__thread_hand , pitch_diameter,minor_diameter,crest, ):
		thread.__init__(self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , inherited5__depth , inherited6__partial_profile , inherited7__applied_shape , inherited8__inner_or_outer_thread , inherited9__qualifier , inherited10__fit_class , inherited11__form , inherited12__major_diameter , inherited13__number_of_threads , inherited14__thread_hand , )
		self._pitch_diameter = pitch_diameter
		self._minor_diameter = minor_diameter
		self._crest = crest

	@property
	def pitch_diameter(self):
		return self._pitch_diameter
	@pitch_diameter.setter
	def pitch_diameter(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,length_measure):
			self._pitch_diameter = length_measure(value)
		else:
			self._pitch_diameter = value

	@property
	def minor_diameter(self):
		return self._minor_diameter
	@minor_diameter.setter
	def minor_diameter(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,length_measure):
				self._minor_diameter = length_measure(value)
			else:
				self._minor_diameter = value
		else:
			self._minor_diameter = value

	@property
	def crest(self):
		return self._crest
	@crest.setter
	def crest(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,length_measure):
				self._crest = length_measure(value)
			else:
				self._crest = value
		else:
			self._crest = value

####################
 # ENTITY facing_rough #
####################
class facing_rough(facing):
	'''Entity facing_rough definition.
	'''
	def __init__( self , inherited0__its_toolpath , inherited1__its_tool_direction , inherited2__its_id , inherited3__retract_plane , inherited4__start_point , inherited5__its_tool , inherited6__its_technology , inherited7__its_machine_functions , inherited8__approach , inherited9__retract , inherited10__its_machining_strategy , inherited11__allowance ,  ):
		facing.__init__(self , inherited0__its_toolpath , inherited1__its_tool_direction , inherited2__its_id , inherited3__retract_plane , inherited4__start_point , inherited5__its_tool , inherited6__its_technology , inherited7__its_machine_functions , inherited8__approach , inherited9__retract , inherited10__its_machining_strategy , inherited11__allowance , )
	def wr1(self):
		eval_wr1_wr = (EXISTS(self.self.allowance)  and  (self.self.allowance  >=  0))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY surface_texture_parameter #
####################
class surface_texture_parameter(BaseEntityClass):
	'''Entity surface_texture_parameter definition.

	:param its_value
	:type its_value:parameter_value

	:param parameter_name
	:type parameter_name:label

	:param measuring_method
	:type measuring_method:identifier

	:param parameter_index
	:type parameter_index:identifier

	:param applied_surfaces
	:type applied_surfaces:SET(1,None,'machined_surface', scope = schema_scope)
	'''
	def __init__( self , its_value,parameter_name,measuring_method,parameter_index,applied_surfaces, ):
		self._its_value = its_value
		self._parameter_name = parameter_name
		self._measuring_method = measuring_method
		self._parameter_index = parameter_index
		self._applied_surfaces = applied_surfaces

	@property
	def its_value(self):
		return self._its_value
	@its_value.setter
	def its_value(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,parameter_value):
			self._its_value = parameter_value(value)
		else:
			self._its_value = value

	@property
	def parameter_name(self):
		return self._parameter_name
	@parameter_name.setter
	def parameter_name(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,label):
			self._parameter_name = label(value)
		else:
			self._parameter_name = value

	@property
	def measuring_method(self):
		return self._measuring_method
	@measuring_method.setter
	def measuring_method(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,identifier):
			self._measuring_method = identifier(value)
		else:
			self._measuring_method = value

	@property
	def parameter_index(self):
		return self._parameter_index
	@parameter_index.setter
	def parameter_index(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,identifier):
				self._parameter_index = identifier(value)
			else:
				self._parameter_index = value
		else:
			self._parameter_index = value

	@property
	def applied_surfaces(self):
		return self._applied_surfaces
	@applied_surfaces.setter
	def applied_surfaces(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(1,None,'machined_surface', scope = schema_scope)):
			self._applied_surfaces = SET(value)
		else:
			self._applied_surfaces = value

####################
 # ENTITY shouldermill #
####################
class shouldermill(milling_cutting_tool):
	'''Entity shouldermill definition.
	'''
	def __init__( self , inherited0__its_id , inherited1__its_usage , inherited2__its_cutting_edges , inherited3__overall_assembly_length , inherited4__effective_cutting_diameter , inherited5__maximum_depth_of_cut , inherited6__hand_of_cut , inherited7__coolant_through_tool , inherited8__number_of_effective_teeth , inherited9__edge_radius ,  ):
		milling_cutting_tool.__init__(self , inherited0__its_id , inherited1__its_usage , inherited2__its_cutting_edges , inherited3__overall_assembly_length , inherited4__effective_cutting_diameter , inherited5__maximum_depth_of_cut , inherited6__hand_of_cut , inherited7__coolant_through_tool , inherited8__number_of_effective_teeth , inherited9__edge_radius , )

####################
 # ENTITY process_model #
####################
class process_model(BaseEntityClass):
	'''Entity process_model definition.

	:param ini_data_file
	:type ini_data_file:label

	:param its_type
	:type its_type:label
	'''
	def __init__( self , ini_data_file,its_type, ):
		self._ini_data_file = ini_data_file
		self._its_type = its_type

	@property
	def ini_data_file(self):
		return self._ini_data_file
	@ini_data_file.setter
	def ini_data_file(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,label):
			self._ini_data_file = label(value)
		else:
			self._ini_data_file = value

	@property
	def its_type(self):
		return self._its_type
	@its_type.setter
	def its_type(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,label):
			self._its_type = label(value)
		else:
			self._its_type = value

####################
 # ENTITY general_closed_profile #
####################
class general_closed_profile(closed_profile):
	'''Entity general_closed_profile definition.

	:param closed_profile_shape
	:type closed_profile_shape:path_shape_item
	'''
	def __init__( self , inherited0__placement , closed_profile_shape, ):
		closed_profile.__init__(self , inherited0__placement , )
		self._closed_profile_shape = closed_profile_shape

	@property
	def closed_profile_shape(self):
		return self._closed_profile_shape
	@closed_profile_shape.setter
	def closed_profile_shape(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,path_shape_item):
			self._closed_profile_shape = path_shape_item(value)
		else:
			self._closed_profile_shape = value

####################
 # ENTITY project #
####################
class project(BaseEntityClass):
	'''Entity project definition.

	:param its_id
	:type its_id:identifier

	:param main_workplan
	:type main_workplan:workplan

	:param its_workpieces
	:type its_workpieces:SET(0,None,'workpiece', scope = schema_scope)

	:param its_owner
	:type its_owner:person_and_address

	:param its_release
	:type its_release:date_and_time

	:param its_status
	:type its_status:approval
	'''
	def __init__( self , its_id,main_workplan,its_workpieces,its_owner,its_release,its_status, ):
		self._its_id = its_id
		self._main_workplan = main_workplan
		self._its_workpieces = its_workpieces
		self._its_owner = its_owner
		self._its_release = its_release
		self._its_status = its_status

	@property
	def its_id(self):
		return self._its_id
	@its_id.setter
	def its_id(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,identifier):
			self._its_id = identifier(value)
		else:
			self._its_id = value

	@property
	def main_workplan(self):
		return self._main_workplan
	@main_workplan.setter
	def main_workplan(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,workplan):
			self._main_workplan = workplan(value)
		else:
			self._main_workplan = value

	@property
	def its_workpieces(self):
		return self._its_workpieces
	@its_workpieces.setter
	def its_workpieces(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(0,None,'workpiece', scope = schema_scope)):
			self._its_workpieces = SET(value)
		else:
			self._its_workpieces = value

	@property
	def its_owner(self):
		return self._its_owner
	@its_owner.setter
	def its_owner(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,person_and_address):
				self._its_owner = person_and_address(value)
			else:
				self._its_owner = value
		else:
			self._its_owner = value

	@property
	def its_release(self):
		return self._its_release
	@its_release.setter
	def its_release(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,date_and_time):
				self._its_release = date_and_time(value)
			else:
				self._its_release = value
		else:
			self._its_release = value

	@property
	def its_status(self):
		return self._its_status
	@its_status.setter
	def its_status(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,approval):
				self._its_status = approval(value)
			else:
				self._its_status = value
		else:
			self._its_status = value

####################
 # ENTITY while_statement #
####################
class while_statement(program_structure):
	'''Entity while_statement definition.

	:param condition
	:type condition:boolean_expression

	:param body
	:type body:executable
	'''
	def __init__( self , inherited0__its_id , condition,body, ):
		program_structure.__init__(self , inherited0__its_id , )
		self._condition = condition
		self._body = body

	@property
	def condition(self):
		return self._condition
	@condition.setter
	def condition(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,boolean_expression):
			self._condition = boolean_expression(value)
		else:
			self._condition = value

	@property
	def body(self):
		return self._body
	@body.setter
	def body(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,executable):
			self._body = executable(value)
		else:
			self._body = value

####################
 # ENTITY rounded_corner #
####################
class rounded_corner(BaseEntityClass):
	'''Entity rounded_corner definition.

	:param corner_radius
	:type corner_radius:length_measure
	'''
	def __init__( self , corner_radius, ):
		self._corner_radius = corner_radius

	@property
	def corner_radius(self):
		return self._corner_radius
	@corner_radius.setter
	def corner_radius(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,length_measure):
			self._corner_radius = length_measure(value)
		else:
			self._corner_radius = value

####################
 # ENTITY const_cutting_speed #
####################
class const_cutting_speed(BaseEntityClass):
	'''Entity const_cutting_speed definition.

	:param speed
	:type speed:speed_measure

	:param max_speed
	:type max_speed:rot_speed_measure
	'''
	def __init__( self , speed,max_speed, ):
		self._speed = speed
		self._max_speed = max_speed

	@property
	def speed(self):
		return self._speed
	@speed.setter
	def speed(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,speed_measure):
			self._speed = speed_measure(value)
		else:
			self._speed = value

	@property
	def max_speed(self):
		return self._max_speed
	@max_speed.setter
	def max_speed(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,rot_speed_measure):
				self._max_speed = rot_speed_measure(value)
			else:
				self._max_speed = value
		else:
			self._max_speed = value

####################
 # ENTITY workplan #
####################
class workplan(program_structure):
	'''Entity workplan definition.

	:param its_elements
	:type its_elements:LIST(0,None,'executable', scope = schema_scope)

	:param its_channel
	:type its_channel:channel

	:param its_setup
	:type its_setup:setup

	:param its_effect
	:type its_effect:in_process_geometry

	:param its_minimum_machine_params
	:type its_minimum_machine_params:machine_parameters
	'''
	def __init__( self , inherited0__its_id , its_elements,its_channel,its_setup,its_effect,its_minimum_machine_params, ):
		program_structure.__init__(self , inherited0__its_id , )
		self._its_elements = its_elements
		self._its_channel = its_channel
		self._its_setup = its_setup
		self._its_effect = its_effect
		self._its_minimum_machine_params = its_minimum_machine_params

	@property
	def its_elements(self):
		return self._its_elements
	@its_elements.setter
	def its_elements(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,LIST(0,None,'executable', scope = schema_scope)):
			self._its_elements = LIST(value)
		else:
			self._its_elements = value

	@property
	def its_channel(self):
		return self._its_channel
	@its_channel.setter
	def its_channel(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,channel):
				self._its_channel = channel(value)
			else:
				self._its_channel = value
		else:
			self._its_channel = value

	@property
	def its_setup(self):
		return self._its_setup
	@its_setup.setter
	def its_setup(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,setup):
				self._its_setup = setup(value)
			else:
				self._its_setup = value
		else:
			self._its_setup = value

	@property
	def its_effect(self):
		return self._its_effect
	@its_effect.setter
	def its_effect(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,in_process_geometry):
				self._its_effect = in_process_geometry(value)
			else:
				self._its_effect = value
		else:
			self._its_effect = value

	@property
	def its_minimum_machine_params(self):
		return self._its_minimum_machine_params
	@its_minimum_machine_params.setter
	def its_minimum_machine_params(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,machine_parameters):
				self._its_minimum_machine_params = machine_parameters(value)
			else:
				self._its_minimum_machine_params = value
		else:
			self._its_minimum_machine_params = value
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY loop_slot_end_type #
####################
class loop_slot_end_type(slot_end_type):
	'''Entity loop_slot_end_type definition.
	'''
	def __init__( self ,  ):
		slot_end_type.__init__(self , )

####################
 # ENTITY setup #
####################
class setup(BaseEntityClass):
	'''Entity setup definition.

	:param its_id
	:type its_id:identifier

	:param its_origin
	:type its_origin:axis2_placement_3d

	:param its_secplane
	:type its_secplane:elementary_surface

	:param its_workpiece_setup
	:type its_workpiece_setup:LIST(0,None,'workpiece_setup', scope = schema_scope)
	'''
	def __init__( self , its_id,its_origin,its_secplane,its_workpiece_setup, ):
		self._its_id = its_id
		self._its_origin = its_origin
		self._its_secplane = its_secplane
		self._its_workpiece_setup = its_workpiece_setup

	@property
	def its_id(self):
		return self._its_id
	@its_id.setter
	def its_id(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,identifier):
			self._its_id = identifier(value)
		else:
			self._its_id = value

	@property
	def its_origin(self):
		return self._its_origin
	@its_origin.setter
	def its_origin(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,axis2_placement_3d):
				self._its_origin = axis2_placement_3d(value)
			else:
				self._its_origin = value
		else:
			self._its_origin = value

	@property
	def its_secplane(self):
		return self._its_secplane
	@its_secplane.setter
	def its_secplane(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,elementary_surface):
			self._its_secplane = elementary_surface(value)
		else:
			self._its_secplane = value

	@property
	def its_workpiece_setup(self):
		return self._its_workpiece_setup
	@its_workpiece_setup.setter
	def its_workpiece_setup(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,LIST(0,None,'workpiece_setup', scope = schema_scope)):
			self._its_workpiece_setup = LIST(value)
		else:
			self._its_workpiece_setup = value

####################
 # ENTITY tolerances #
####################
class tolerances(BaseEntityClass):
	'''Entity tolerances definition.

	:param chordal_tolerance
	:type chordal_tolerance:length_measure

	:param scallop_height
	:type scallop_height:length_measure
	'''
	def __init__( self , chordal_tolerance,scallop_height, ):
		self._chordal_tolerance = chordal_tolerance
		self._scallop_height = scallop_height

	@property
	def chordal_tolerance(self):
		return self._chordal_tolerance
	@chordal_tolerance.setter
	def chordal_tolerance(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,length_measure):
			self._chordal_tolerance = length_measure(value)
		else:
			self._chordal_tolerance = value

	@property
	def scallop_height(self):
		return self._scallop_height
	@scallop_height.setter
	def scallop_height(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,length_measure):
			self._scallop_height = length_measure(value)
		else:
			self._scallop_height = value

####################
 # ENTITY approving_person_organization #
####################
class approving_person_organization(BaseEntityClass):
	'''Entity approving_person_organization definition.

	:param person_organization
	:type person_organization:person_and_organization

	:param approval_date
	:type approval_date:STRING

	:param authorized_approval
	:type authorized_approval:approval

	:param role
	:type role:STRING
	'''
	def __init__( self , person_organization,approval_date,authorized_approval,role, ):
		self._person_organization = person_organization
		self._approval_date = approval_date
		self._authorized_approval = authorized_approval
		self._role = role

	@property
	def person_organization(self):
		return self._person_organization
	@person_organization.setter
	def person_organization(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,person_and_organization):
			self._person_organization = person_and_organization(value)
		else:
			self._person_organization = value

	@property
	def approval_date(self):
		return self._approval_date
	@approval_date.setter
	def approval_date(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,STRING):
				self._approval_date = STRING(value)
			else:
				self._approval_date = value
		else:
			self._approval_date = value

	@property
	def authorized_approval(self):
		return self._authorized_approval
	@authorized_approval.setter
	def authorized_approval(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,approval):
			self._authorized_approval = approval(value)
		else:
			self._authorized_approval = value

	@property
	def role(self):
		return self._role
	@role.setter
	def role(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,STRING):
				self._role = STRING(value)
			else:
				self._role = value
		else:
			self._role = value

####################
 # ENTITY plane_rough_milling #
####################
class plane_rough_milling(plane_milling):
	'''Entity plane_rough_milling definition.
	'''
	def __init__( self , inherited0__its_toolpath , inherited1__its_tool_direction , inherited2__its_id , inherited3__retract_plane , inherited4__start_point , inherited5__its_tool , inherited6__its_technology , inherited7__its_machine_functions , inherited8__overcut_length , inherited9__approach , inherited10__retract , inherited11__its_machining_strategy , inherited12__axial_cutting_depth , inherited13__allowance_bottom ,  ):
		plane_milling.__init__(self , inherited0__its_toolpath , inherited1__its_tool_direction , inherited2__its_id , inherited3__retract_plane , inherited4__start_point , inherited5__its_tool , inherited6__its_technology , inherited7__its_machine_functions , inherited8__overcut_length , inherited9__approach , inherited10__retract , inherited11__its_machining_strategy , inherited12__axial_cutting_depth , inherited13__allowance_bottom , )
	def wr1(self):
		eval_wr1_wr = (EXISTS(self.self.allowance_bottom)  and  (self.self.allowance_bottom  >=  0))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY general_turning_tool #
####################
class general_turning_tool(turning_machine_cutting_tool):
	'''Entity general_turning_tool definition.
	'''
	def __init__( self , inherited0__its_id , inherited1__its_usage , inherited2__functional_length , inherited3__f_dimension , inherited4__minimum_cutting_diameter , inherited5__a_dimension_on_f , inherited6__a_dimension_on_lf , inherited7__cutting_edge , inherited8__hand_of_tool ,  ):
		turning_machine_cutting_tool.__init__(self , inherited0__its_id , inherited1__its_usage , inherited2__functional_length , inherited3__f_dimension , inherited4__minimum_cutting_diameter , inherited5__a_dimension_on_f , inherited6__a_dimension_on_lf , inherited7__cutting_edge , inherited8__hand_of_tool , )

####################
 # ENTITY unidirectional #
####################
class unidirectional(two5d_milling_strategy):
	'''Entity unidirectional definition.

	:param feed_direction
	:type feed_direction:direction

	:param cutmode
	:type cutmode:cutmode_type
	'''
	def __init__( self , inherited0__overlap , inherited1__allow_multiple_passes , feed_direction,cutmode, ):
		two5d_milling_strategy.__init__(self , inherited0__overlap , inherited1__allow_multiple_passes , )
		self._feed_direction = feed_direction
		self._cutmode = cutmode

	@property
	def feed_direction(self):
		return self._feed_direction
	@feed_direction.setter
	def feed_direction(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,direction):
				self._feed_direction = direction(value)
			else:
				self._feed_direction = value
		else:
			self._feed_direction = value

	@property
	def cutmode(self):
		return self._cutmode
	@cutmode.setter
	def cutmode(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,cutmode_type):
				self._cutmode = cutmode_type(value)
			else:
				self._cutmode = value
		else:
			self._cutmode = value

####################
 # ENTITY bidirectional #
####################
class bidirectional(two5d_milling_strategy):
	'''Entity bidirectional definition.

	:param feed_direction
	:type feed_direction:direction

	:param stepover_direction
	:type stepover_direction:left_or_right

	:param its_stroke_connection_strategy
	:type its_stroke_connection_strategy:stroke_connection_strategy
	'''
	def __init__( self , inherited0__overlap , inherited1__allow_multiple_passes , feed_direction,stepover_direction,its_stroke_connection_strategy, ):
		two5d_milling_strategy.__init__(self , inherited0__overlap , inherited1__allow_multiple_passes , )
		self._feed_direction = feed_direction
		self._stepover_direction = stepover_direction
		self._its_stroke_connection_strategy = its_stroke_connection_strategy

	@property
	def feed_direction(self):
		return self._feed_direction
	@feed_direction.setter
	def feed_direction(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,direction):
				self._feed_direction = direction(value)
			else:
				self._feed_direction = value
		else:
			self._feed_direction = value

	@property
	def stepover_direction(self):
		return self._stepover_direction
	@stepover_direction.setter
	def stepover_direction(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,left_or_right):
				self._stepover_direction = left_or_right(value)
			else:
				self._stepover_direction = value
		else:
			self._stepover_direction = value

	@property
	def its_stroke_connection_strategy(self):
		return self._its_stroke_connection_strategy
	@its_stroke_connection_strategy.setter
	def its_stroke_connection_strategy(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,stroke_connection_strategy):
				self._its_stroke_connection_strategy = stroke_connection_strategy(value)
			else:
				self._its_stroke_connection_strategy = value
		else:
			self._its_stroke_connection_strategy = value

####################
 # ENTITY facing_finish #
####################
class facing_finish(facing):
	'''Entity facing_finish definition.
	'''
	def __init__( self , inherited0__its_toolpath , inherited1__its_tool_direction , inherited2__its_id , inherited3__retract_plane , inherited4__start_point , inherited5__its_tool , inherited6__its_technology , inherited7__its_machine_functions , inherited8__approach , inherited9__retract , inherited10__its_machining_strategy , inherited11__allowance ,  ):
		facing.__init__(self , inherited0__its_toolpath , inherited1__its_tool_direction , inherited2__its_id , inherited3__retract_plane , inherited4__start_point , inherited5__its_tool , inherited6__its_technology , inherited7__its_machine_functions , inherited8__approach , inherited9__retract , inherited10__its_machining_strategy , inherited11__allowance , )

####################
 # ENTITY through_bottom_condition #
####################
class through_bottom_condition(hole_bottom_condition):
	'''Entity through_bottom_condition definition.
	'''
	def __init__( self ,  ):
		hole_bottom_condition.__init__(self , )

####################
 # ENTITY circular_offset #
####################
class circular_offset(BaseEntityClass):
	'''Entity circular_offset definition.

	:param angular_offset
	:type angular_offset:plane_angle_measure

	:param index
	:type index:INTEGER
	'''
	def __init__( self , angular_offset,index, ):
		self._angular_offset = angular_offset
		self._index = index

	@property
	def angular_offset(self):
		return self._angular_offset
	@angular_offset.setter
	def angular_offset(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,plane_angle_measure):
			self._angular_offset = plane_angle_measure(value)
		else:
			self._angular_offset = value

	@property
	def index(self):
		return self._index
	@index.setter
	def index(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,INTEGER):
			self._index = INTEGER(value)
		else:
			self._index = value

####################
 # ENTITY feedstop #
####################
class feedstop(toolpath):
	'''Entity feedstop definition.

	:param dwell
	:type dwell:time_measure
	'''
	def __init__( self , inherited0__its_priority , inherited1__its_type , inherited2__its_speed , inherited3__its_technology , inherited4__its_machine_functions , inherited5__its_id , dwell, ):
		toolpath.__init__(self , inherited0__its_priority , inherited1__its_type , inherited2__its_speed , inherited3__its_technology , inherited4__its_machine_functions , inherited5__its_id , )
		self._dwell = dwell

	@property
	def dwell(self):
		return self._dwell
	@dwell.setter
	def dwell(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,time_measure):
			self._dwell = time_measure(value)
		else:
			self._dwell = value

####################
 # ENTITY unload_tool #
####################
class unload_tool(nc_function):
	'''Entity unload_tool definition.

	:param its_tool
	:type its_tool:machining_tool
	'''
	def __init__( self , inherited0__its_id , its_tool, ):
		nc_function.__init__(self , inherited0__its_id , )
		self._its_tool = its_tool

	@property
	def its_tool(self):
		return self._its_tool
	@its_tool.setter
	def its_tool(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,machining_tool):
				self._its_tool = machining_tool(value)
			else:
				self._its_tool = value
		else:
			self._its_tool = value

####################
 # ENTITY contour_spiral #
####################
class contour_spiral(two5d_milling_strategy):
	'''Entity contour_spiral definition.

	:param rotation_direction
	:type rotation_direction:rot_direction

	:param cutmode
	:type cutmode:cutmode_type
	'''
	def __init__( self , inherited0__overlap , inherited1__allow_multiple_passes , rotation_direction,cutmode, ):
		two5d_milling_strategy.__init__(self , inherited0__overlap , inherited1__allow_multiple_passes , )
		self._rotation_direction = rotation_direction
		self._cutmode = cutmode

	@property
	def rotation_direction(self):
		return self._rotation_direction
	@rotation_direction.setter
	def rotation_direction(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,rot_direction):
				self._rotation_direction = rot_direction(value)
			else:
				self._rotation_direction = value
		else:
			self._rotation_direction = value

	@property
	def cutmode(self):
		return self._cutmode
	@cutmode.setter
	def cutmode(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,cutmode_type):
				self._cutmode = cutmode_type(value)
			else:
				self._cutmode = value
		else:
			self._cutmode = value

####################
 # ENTITY thread_strategy #
####################
class thread_strategy(turning_machining_strategy):
	'''Entity thread_strategy definition.

	:param cut_in_amount_function
	:type cut_in_amount_function:thread_cut_depth_type

	:param threading_direction
	:type threading_direction:threading_direction_type

	:param path_return_angle
	:type path_return_angle:plane_angle_measure

	:param lift_height
	:type lift_height:length_measure
	'''
	def __init__( self , inherited0__overcut_length , inherited1__allow_multiple_passes , inherited2__cutting_depth , inherited3__variable_feedrate , cut_in_amount_function,threading_direction,path_return_angle,lift_height, ):
		turning_machining_strategy.__init__(self , inherited0__overcut_length , inherited1__allow_multiple_passes , inherited2__cutting_depth , inherited3__variable_feedrate , )
		self._cut_in_amount_function = cut_in_amount_function
		self._threading_direction = threading_direction
		self._path_return_angle = path_return_angle
		self._lift_height = lift_height

	@property
	def cut_in_amount_function(self):
		return self._cut_in_amount_function
	@cut_in_amount_function.setter
	def cut_in_amount_function(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,thread_cut_depth_type):
			self._cut_in_amount_function = thread_cut_depth_type(value)
		else:
			self._cut_in_amount_function = value

	@property
	def threading_direction(self):
		return self._threading_direction
	@threading_direction.setter
	def threading_direction(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,threading_direction_type):
			self._threading_direction = threading_direction_type(value)
		else:
			self._threading_direction = value

	@property
	def path_return_angle(self):
		return self._path_return_angle
	@path_return_angle.setter
	def path_return_angle(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,plane_angle_measure):
				self._path_return_angle = plane_angle_measure(value)
			else:
				self._path_return_angle = value
		else:
			self._path_return_angle = value

	@property
	def lift_height(self):
		return self._lift_height
	@lift_height.setter
	def lift_height(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,length_measure):
				self._lift_height = length_measure(value)
			else:
				self._lift_height = value
		else:
			self._lift_height = value

####################
 # ENTITY measurement_path #
####################
class measurement_path(BaseEntityClass):
	'''Entity measurement_path definition.

	:param defined_by
	:type defined_by:curve

	:param defined_in
	:type defined_in:representation_context
	'''
	def __init__( self , defined_by,defined_in, ):
		self._defined_by = defined_by
		self._defined_in = defined_in

	@property
	def defined_by(self):
		return self._defined_by
	@defined_by.setter
	def defined_by(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,curve):
			self._defined_by = curve(value)
		else:
			self._defined_by = value

	@property
	def defined_in(self):
		return self._defined_in
	@defined_in.setter
	def defined_in(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,representation_context):
			self._defined_in = representation_context(value)
		else:
			self._defined_in = value

####################
 # ENTITY approval_status #
####################
class approval_status(BaseEntityClass):
	'''Entity approval_status definition.

	:param status_name
	:type status_name:STRING
	'''
	def __init__( self , status_name, ):
		self._status_name = status_name

	@property
	def status_name(self):
		return self._status_name
	@status_name.setter
	def status_name(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,STRING):
			self._status_name = STRING(value)
		else:
			self._status_name = value

####################
 # ENTITY class_bsu #
####################
class class_bsu(bsu):
	'''Entity class_bsu definition.

	:param defined_by
	:type defined_by:supplier_bsu

	:param version
	:type version:label
	'''
	def __init__( self , inherited0__code , defined_by,version, ):
		bsu.__init__(self , inherited0__code , )
		self._defined_by = defined_by
		self._version = version

	@property
	def defined_by(self):
		return self._defined_by
	@defined_by.setter
	def defined_by(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,supplier_bsu):
			self._defined_by = supplier_bsu(value)
		else:
			self._defined_by = value

	@property
	def version(self):
		return self._version
	@version.setter
	def version(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,label):
			self._version = label(value)
		else:
			self._version = value

####################
 # ENTITY combined_drill_and_tap #
####################
class combined_drill_and_tap(tapping_cutting_tool):
	'''Entity combined_drill_and_tap definition.

	:param drill_length
	:type drill_length:length_measure
	'''
	def __init__( self , inherited0__its_id , inherited1__its_usage , inherited2__its_cutting_edges , inherited3__overall_assembly_length , inherited4__effective_cutting_diameter , inherited5__maximum_depth_of_cut , inherited6__hand_of_cut , inherited7__coolant_through_tool , inherited8__thread_form_type , inherited9__thread_size , inherited10__thread_pitch , inherited11__taper_thread_count , drill_length, ):
		tapping_cutting_tool.__init__(self , inherited0__its_id , inherited1__its_usage , inherited2__its_cutting_edges , inherited3__overall_assembly_length , inherited4__effective_cutting_diameter , inherited5__maximum_depth_of_cut , inherited6__hand_of_cut , inherited7__coolant_through_tool , inherited8__thread_form_type , inherited9__thread_size , inherited10__thread_pitch , inherited11__taper_thread_count , )
		self._drill_length = drill_length

	@property
	def drill_length(self):
		return self._drill_length
	@drill_length.setter
	def drill_length(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,length_measure):
				self._drill_length = length_measure(value)
			else:
				self._drill_length = value
		else:
			self._drill_length = value

####################
 # ENTITY target_rectangle #
####################
class target_rectangle(placed_target):
	'''Entity target_rectangle definition.

	:param target_length
	:type target_length:value_with_unit

	:param target_width
	:type target_width:value_with_unit
	'''
	def __init__( self , inherited0__id , inherited1__defined_in , inherited2__parameter_reference , target_length,target_width, ):
		placed_target.__init__(self , inherited0__id , inherited1__defined_in , inherited2__parameter_reference , )
		self._target_length = target_length
		self._target_width = target_width

	@property
	def target_length(self):
		return self._target_length
	@target_length.setter
	def target_length(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,value_with_unit):
			self._target_length = value_with_unit(value)
		else:
			self._target_length = value

	@property
	def target_width(self):
		return self._target_width
	@target_width.setter
	def target_width(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,value_with_unit):
			self._target_width = value_with_unit(value)
		else:
			self._target_width = value

####################
 # ENTITY counterbore_hole #
####################
class counterbore_hole(compound_feature):
	'''Entity counterbore_hole definition.
	'''
	def __init__( self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , inherited5__elements , inherited6__feature_description , inherited7__feature_name ,  ):
		compound_feature.__init__(self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , inherited5__elements , inherited6__feature_description , inherited7__feature_name , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(self.elements)  ==  2)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  2)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (self.self.elements[1].self.diameter.self.theoretical_size  !=  self.self.elements[2].self.diameter.self.theoretical_size)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr


####################
 # ENTITY program_stop #
####################
class program_stop(nc_function):
	'''Entity program_stop definition.
	'''
	def __init__( self , inherited0__its_id ,  ):
		nc_function.__init__(self , inherited0__its_id , )

####################
 # ENTITY straight_knurl #
####################
class straight_knurl(knurl):
	'''Entity straight_knurl definition.
	'''
	def __init__( self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , inherited5__base_feature , inherited6__partial_profile , inherited7__tooth_depth , inherited8__diametral_pitch , inherited9__root_fillet , inherited10__number_of_teeth , inherited11__major_diameter , inherited12__nominal_diameter ,  ):
		knurl.__init__(self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , inherited5__base_feature , inherited6__partial_profile , inherited7__tooth_depth , inherited8__diametral_pitch , inherited9__root_fillet , inherited10__number_of_teeth , inherited11__major_diameter , inherited12__nominal_diameter , )

####################
 # ENTITY turning_machine_functions #
####################
class turning_machine_functions(machine_functions):
	'''Entity turning_machine_functions definition.

	:param coolant
	:type coolant:BOOLEAN

	:param coolant_type
	:type coolant_type:coolant_select

	:param coolant_pressure
	:type coolant_pressure:pressure_measure

	:param axis_clamping
	:type axis_clamping:LIST(0,None,'STRING', scope = schema_scope)

	:param chip_removal
	:type chip_removal:BOOLEAN

	:param oriented_spindle_stop
	:type oriented_spindle_stop:direction

	:param its_process_model
	:type its_process_model:process_model_list

	:param other_functions
	:type other_functions:SET(0,None,'property_parameter', scope = schema_scope)

	:param tail_stock
	:type tail_stock:BOOLEAN

	:param steady_rest
	:type steady_rest:BOOLEAN

	:param follow_rest
	:type follow_rest:BOOLEAN
	'''
	def __init__( self , coolant,coolant_type,coolant_pressure,axis_clamping,chip_removal,oriented_spindle_stop,its_process_model,other_functions,tail_stock,steady_rest,follow_rest, ):
		machine_functions.__init__(self , )
		self._coolant = coolant
		self._coolant_type = coolant_type
		self._coolant_pressure = coolant_pressure
		self._axis_clamping = axis_clamping
		self._chip_removal = chip_removal
		self._oriented_spindle_stop = oriented_spindle_stop
		self._its_process_model = its_process_model
		self._other_functions = other_functions
		self._tail_stock = tail_stock
		self._steady_rest = steady_rest
		self._follow_rest = follow_rest

	@property
	def coolant(self):
		return self._coolant
	@coolant.setter
	def coolant(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,BOOLEAN):
			self._coolant = BOOLEAN(value)
		else:
			self._coolant = value

	@property
	def coolant_type(self):
		return self._coolant_type
	@coolant_type.setter
	def coolant_type(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,coolant_select):
				self._coolant_type = coolant_select(value)
			else:
				self._coolant_type = value
		else:
			self._coolant_type = value

	@property
	def coolant_pressure(self):
		return self._coolant_pressure
	@coolant_pressure.setter
	def coolant_pressure(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,pressure_measure):
				self._coolant_pressure = pressure_measure(value)
			else:
				self._coolant_pressure = value
		else:
			self._coolant_pressure = value

	@property
	def axis_clamping(self):
		return self._axis_clamping
	@axis_clamping.setter
	def axis_clamping(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,LIST(0,None,'STRING', scope = schema_scope)):
			self._axis_clamping = LIST(value)
		else:
			self._axis_clamping = value

	@property
	def chip_removal(self):
		return self._chip_removal
	@chip_removal.setter
	def chip_removal(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,BOOLEAN):
				self._chip_removal = BOOLEAN(value)
			else:
				self._chip_removal = value
		else:
			self._chip_removal = value

	@property
	def oriented_spindle_stop(self):
		return self._oriented_spindle_stop
	@oriented_spindle_stop.setter
	def oriented_spindle_stop(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,direction):
				self._oriented_spindle_stop = direction(value)
			else:
				self._oriented_spindle_stop = value
		else:
			self._oriented_spindle_stop = value

	@property
	def its_process_model(self):
		return self._its_process_model
	@its_process_model.setter
	def its_process_model(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,process_model_list):
				self._its_process_model = process_model_list(value)
			else:
				self._its_process_model = value
		else:
			self._its_process_model = value

	@property
	def other_functions(self):
		return self._other_functions
	@other_functions.setter
	def other_functions(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(0,None,'property_parameter', scope = schema_scope)):
			self._other_functions = SET(value)
		else:
			self._other_functions = value

	@property
	def tail_stock(self):
		return self._tail_stock
	@tail_stock.setter
	def tail_stock(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,BOOLEAN):
				self._tail_stock = BOOLEAN(value)
			else:
				self._tail_stock = value
		else:
			self._tail_stock = value

	@property
	def steady_rest(self):
		return self._steady_rest
	@steady_rest.setter
	def steady_rest(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,BOOLEAN):
				self._steady_rest = BOOLEAN(value)
			else:
				self._steady_rest = value
		else:
			self._steady_rest = value

	@property
	def follow_rest(self):
		return self._follow_rest
	@follow_rest.setter
	def follow_rest(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,BOOLEAN):
				self._follow_rest = BOOLEAN(value)
			else:
				self._follow_rest = value
		else:
			self._follow_rest = value

####################
 # ENTITY planar_face #
####################
class planar_face(machining_feature):
	'''Entity planar_face definition.

	:param course_of_travel
	:type course_of_travel:linear_path

	:param removal_boundary
	:type removal_boundary:linear_profile

	:param face_boundary
	:type face_boundary:closed_profile

	:param its_boss
	:type its_boss:SET(0,None,'boss', scope = schema_scope)

	:param removal_depth
	:type removal_depth:length_measure

	:param removal_direction
	:type removal_direction:direction
	'''
	def __init__( self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , inherited5__depth , course_of_travel,removal_boundary,face_boundary,its_boss,removal_depth,removal_direction, ):
		machining_feature.__init__(self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , inherited5__depth , )
		self._course_of_travel = course_of_travel
		self._removal_boundary = removal_boundary
		self._face_boundary = face_boundary
		self._its_boss = its_boss
		self._removal_depth = removal_depth
		self._removal_direction = removal_direction

	@property
	def course_of_travel(self):
		return self._course_of_travel
	@course_of_travel.setter
	def course_of_travel(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,linear_path):
			self._course_of_travel = linear_path(value)
		else:
			self._course_of_travel = value

	@property
	def removal_boundary(self):
		return self._removal_boundary
	@removal_boundary.setter
	def removal_boundary(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,linear_profile):
			self._removal_boundary = linear_profile(value)
		else:
			self._removal_boundary = value

	@property
	def face_boundary(self):
		return self._face_boundary
	@face_boundary.setter
	def face_boundary(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,closed_profile):
				self._face_boundary = closed_profile(value)
			else:
				self._face_boundary = value
		else:
			self._face_boundary = value

	@property
	def its_boss(self):
		return self._its_boss
	@its_boss.setter
	def its_boss(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(0,None,'boss', scope = schema_scope)):
			self._its_boss = SET(value)
		else:
			self._its_boss = value

	@property
	def removal_depth(self):
		return self._removal_depth
	@removal_depth.setter
	def removal_depth(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,length_measure):
			self._removal_depth = length_measure(value)
		else:
			self._removal_depth = value

	@property
	def removal_direction(self):
		return self._removal_direction
	@removal_direction.setter
	def removal_direction(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,direction):
			self._removal_direction = direction(value)
		else:
			self._removal_direction = value

####################
 # ENTITY circular_runout_tolerance #
####################
class circular_runout_tolerance(geometric_tolerance):
	'''Entity circular_runout_tolerance definition.

	:param angle
	:type angle:REAL

	:param reference_datum
	:type reference_datum:SET(1,2,'datum_reference', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__applied_to , inherited2__modification , inherited3__qualifying_note , inherited4__segment_size , inherited5__significant_digits , inherited6__tolerance_value , angle,reference_datum, ):
		geometric_tolerance.__init__(self , inherited0__name , inherited1__applied_to , inherited2__modification , inherited3__qualifying_note , inherited4__segment_size , inherited5__significant_digits , inherited6__tolerance_value , )
		self._angle = angle
		self._reference_datum = reference_datum

	@property
	def angle(self):
		return self._angle
	@angle.setter
	def angle(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,REAL):
			self._angle = REAL(value)
		else:
			self._angle = value

	@property
	def reference_datum(self):
		return self._reference_datum
	@reference_datum.setter
	def reference_datum(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(1,2,'datum_reference', scope = schema_scope)):
			self._reference_datum = SET(value)
		else:
			self._reference_datum = value

####################
 # ENTITY workpiece_assembly_component #
####################
class workpiece_assembly_component(BaseEntityClass):
	'''Entity workpiece_assembly_component definition.

	:param component
	:type component:workpiece

	:param originating_orientation
	:type originating_orientation:axis2_placement_3d

	:param resulting_orientation
	:type resulting_orientation:axis2_placement_3d

	:param reference_designator
	:type reference_designator:STRING
	'''
	def __init__( self , component,originating_orientation,resulting_orientation,reference_designator, ):
		self._component = component
		self._originating_orientation = originating_orientation
		self._resulting_orientation = resulting_orientation
		self._reference_designator = reference_designator

	@property
	def component(self):
		return self._component
	@component.setter
	def component(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,workpiece):
			self._component = workpiece(value)
		else:
			self._component = value

	@property
	def originating_orientation(self):
		return self._originating_orientation
	@originating_orientation.setter
	def originating_orientation(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,axis2_placement_3d):
			self._originating_orientation = axis2_placement_3d(value)
		else:
			self._originating_orientation = value

	@property
	def resulting_orientation(self):
		return self._resulting_orientation
	@resulting_orientation.setter
	def resulting_orientation(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,axis2_placement_3d):
			self._resulting_orientation = axis2_placement_3d(value)
		else:
			self._resulting_orientation = value

	@property
	def reference_designator(self):
		return self._reference_designator
	@reference_designator.setter
	def reference_designator(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,STRING):
			self._reference_designator = STRING(value)
		else:
			self._reference_designator = value

####################
 # ENTITY rectangular_closed_shape_profile #
####################
class rectangular_closed_shape_profile(shape_profile):
	'''Entity rectangular_closed_shape_profile definition.

	:param closed_boundary
	:type closed_boundary:rectangular_closed_profile
	'''
	def __init__( self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , inherited5__depth , inherited6__profile_swept_shape , inherited7__floor_condition , inherited8__removal_direction , closed_boundary, ):
		shape_profile.__init__(self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , inherited5__depth , inherited6__profile_swept_shape , inherited7__floor_condition , inherited8__removal_direction , )
		self._closed_boundary = closed_boundary

	@property
	def closed_boundary(self):
		return self._closed_boundary
	@closed_boundary.setter
	def closed_boundary(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,rectangular_closed_profile):
			self._closed_boundary = rectangular_closed_profile(value)
		else:
			self._closed_boundary = value

####################
 # ENTITY setup_instruction #
####################
class setup_instruction(BaseEntityClass):
	'''Entity setup_instruction definition.

	:param description
	:type description:text

	:param external_document
	:type external_document:identifier
	'''
	def __init__( self , description,external_document, ):
		self._description = description
		self._external_document = external_document

	@property
	def description(self):
		return self._description
	@description.setter
	def description(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,text):
				self._description = text(value)
			else:
				self._description = value
		else:
			self._description = value

	@property
	def external_document(self):
		return self._external_document
	@external_document.setter
	def external_document(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,identifier):
				self._external_document = identifier(value)
			else:
				self._external_document = value
		else:
			self._external_document = value
	def wr1(self):
		eval_wr1_wr = (EXISTS(self.description)  or  EXISTS(self.external_document))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY planar_pocket_bottom_condition #
####################
class planar_pocket_bottom_condition(pocket_bottom_condition):
	'''Entity planar_pocket_bottom_condition definition.
	'''
	def __init__( self ,  ):
		pocket_bottom_condition.__init__(self , )

####################
 # ENTITY pressure_measure #
####################
class pressure_measure(value_with_tolerance):
	'''Entity pressure_measure definition.
	'''
	def __init__( self , inherited0__unit , inherited1__value_component , inherited2__limitation , inherited3__significant_digits ,  ):
		value_with_tolerance.__init__(self , inherited0__unit , inherited1__value_component , inherited2__limitation , inherited3__significant_digits , )

####################
 # ENTITY index_pallet #
####################
class index_pallet(nc_function):
	'''Entity index_pallet definition.

	:param its_index
	:type its_index:INTEGER
	'''
	def __init__( self , inherited0__its_id , its_index, ):
		nc_function.__init__(self , inherited0__its_id , )
		self._its_index = its_index

	@property
	def its_index(self):
		return self._its_index
	@its_index.setter
	def its_index(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,INTEGER):
			self._its_index = INTEGER(value)
		else:
			self._its_index = value

####################
 # ENTITY process_model_list #
####################
class process_model_list(BaseEntityClass):
	'''Entity process_model_list definition.

	:param its_list
	:type its_list:LIST(1,None,'process_model', scope = schema_scope)
	'''
	def __init__( self , its_list, ):
		self._its_list = its_list

	@property
	def its_list(self):
		return self._its_list
	@its_list.setter
	def its_list(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,LIST(1,None,'process_model', scope = schema_scope)):
			self._its_list = LIST(value)
		else:
			self._its_list = value

####################
 # ENTITY supplier_bsu #
####################
class supplier_bsu(bsu):
	'''Entity supplier_bsu definition.
	'''
	def __init__( self , inherited0__code ,  ):
		bsu.__init__(self , inherited0__code , )

####################
 # ENTITY contour_parallel #
####################
class contour_parallel(two5d_milling_strategy):
	'''Entity contour_parallel definition.

	:param rotation_direction
	:type rotation_direction:rot_direction

	:param cutmode
	:type cutmode:cutmode_type
	'''
	def __init__( self , inherited0__overlap , inherited1__allow_multiple_passes , rotation_direction,cutmode, ):
		two5d_milling_strategy.__init__(self , inherited0__overlap , inherited1__allow_multiple_passes , )
		self._rotation_direction = rotation_direction
		self._cutmode = cutmode

	@property
	def rotation_direction(self):
		return self._rotation_direction
	@rotation_direction.setter
	def rotation_direction(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,rot_direction):
				self._rotation_direction = rot_direction(value)
			else:
				self._rotation_direction = value
		else:
			self._rotation_direction = value

	@property
	def cutmode(self):
		return self._cutmode
	@cutmode.setter
	def cutmode(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,cutmode_type):
				self._cutmode = cutmode_type(value)
			else:
				self._cutmode = value
		else:
			self._cutmode = value

####################
 # ENTITY angular_location_dimension #
####################
class angular_location_dimension(location_dimension):
	'''Entity angular_location_dimension definition.

	:param orientation
	:type orientation:axis_placement
	'''
	def __init__( self , inherited0__id , inherited1__dimension_value , inherited2__notes , inherited3__description , inherited4__directed , inherited5__origin , inherited6__target , orientation, ):
		location_dimension.__init__(self , inherited0__id , inherited1__dimension_value , inherited2__notes , inherited3__description , inherited4__directed , inherited5__origin , inherited6__target , )
		self._orientation = orientation

	@property
	def orientation(self):
		return self._orientation
	@orientation.setter
	def orientation(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,axis_placement):
				self._orientation = axis_placement(value)
			else:
				self._orientation = value
		else:
			self._orientation = value

####################
 # ENTITY security_classification #
####################
class security_classification(BaseEntityClass):
	'''Entity security_classification definition.

	:param classification_level
	:type classification_level:STRING

	:param description
	:type description:STRING
	'''
	def __init__( self , classification_level,description, ):
		self._classification_level = classification_level
		self._description = description

	@property
	def classification_level(self):
		return self._classification_level
	@classification_level.setter
	def classification_level(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,STRING):
			self._classification_level = STRING(value)
		else:
			self._classification_level = value

	@property
	def description(self):
		return self._description
	@description.setter
	def description(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,STRING):
			self._description = STRING(value)
		else:
			self._description = value

####################
 # ENTITY diagonal_knurl #
####################
class diagonal_knurl(knurl):
	'''Entity diagonal_knurl definition.

	:param helix_angle
	:type helix_angle:plane_angle_measure
	'''
	def __init__( self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , inherited5__base_feature , inherited6__partial_profile , inherited7__tooth_depth , inherited8__diametral_pitch , inherited9__root_fillet , inherited10__number_of_teeth , inherited11__major_diameter , inherited12__nominal_diameter , helix_angle, ):
		knurl.__init__(self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , inherited5__base_feature , inherited6__partial_profile , inherited7__tooth_depth , inherited8__diametral_pitch , inherited9__root_fillet , inherited10__number_of_teeth , inherited11__major_diameter , inherited12__nominal_diameter , )
		self._helix_angle = helix_angle

	@property
	def helix_angle(self):
		return self._helix_angle
	@helix_angle.setter
	def helix_angle(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,plane_angle_measure):
			self._helix_angle = plane_angle_measure(value)
		else:
			self._helix_angle = value

####################
 # ENTITY bidirectional_turning #
####################
class bidirectional_turning(turning_machining_strategy):
	'''Entity bidirectional_turning definition.

	:param feed_direction
	:type feed_direction:direction

	:param stepover_direction
	:type stepover_direction:direction

	:param stepover_feed
	:type stepover_feed:feed_select
	'''
	def __init__( self , inherited0__overcut_length , inherited1__allow_multiple_passes , inherited2__cutting_depth , inherited3__variable_feedrate , feed_direction,stepover_direction,stepover_feed, ):
		turning_machining_strategy.__init__(self , inherited0__overcut_length , inherited1__allow_multiple_passes , inherited2__cutting_depth , inherited3__variable_feedrate , )
		self._feed_direction = feed_direction
		self._stepover_direction = stepover_direction
		self._stepover_feed = stepover_feed

	@property
	def feed_direction(self):
		return self._feed_direction
	@feed_direction.setter
	def feed_direction(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,direction):
				self._feed_direction = direction(value)
			else:
				self._feed_direction = value
		else:
			self._feed_direction = value

	@property
	def stepover_direction(self):
		return self._stepover_direction
	@stepover_direction.setter
	def stepover_direction(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,direction):
				self._stepover_direction = direction(value)
			else:
				self._stepover_direction = value
		else:
			self._stepover_direction = value

	@property
	def stepover_feed(self):
		return self._stepover_feed
	@stepover_feed.setter
	def stepover_feed(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,feed_select):
				self._stepover_feed = feed_select(value)
			else:
				self._stepover_feed = value
		else:
			self._stepover_feed = value

####################
 # ENTITY extended_nc_function #
####################
class extended_nc_function(nc_function):
	'''Entity extended_nc_function definition.

	:param description
	:type description:text
	'''
	def __init__( self , inherited0__its_id , description, ):
		nc_function.__init__(self , inherited0__its_id , )
		self._description = description

	@property
	def description(self):
		return self._description
	@description.setter
	def description(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,text):
			self._description = text(value)
		else:
			self._description = value

####################
 # ENTITY position_tolerance #
####################
class position_tolerance(geometric_tolerance):
	'''Entity position_tolerance definition.

	:param affected_plane
	:type affected_plane:axis_placement

	:param reference_datum
	:type reference_datum:SET(0,3,'datum_reference', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__applied_to , inherited2__modification , inherited3__qualifying_note , inherited4__segment_size , inherited5__significant_digits , inherited6__tolerance_value , affected_plane,reference_datum, ):
		geometric_tolerance.__init__(self , inherited0__name , inherited1__applied_to , inherited2__modification , inherited3__qualifying_note , inherited4__segment_size , inherited5__significant_digits , inherited6__tolerance_value , )
		self._affected_plane = affected_plane
		self._reference_datum = reference_datum

	@property
	def affected_plane(self):
		return self._affected_plane
	@affected_plane.setter
	def affected_plane(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,axis_placement):
				self._affected_plane = axis_placement(value)
			else:
				self._affected_plane = value
		else:
			self._affected_plane = value

	@property
	def reference_datum(self):
		return self._reference_datum
	@reference_datum.setter
	def reference_datum(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(0,3,'datum_reference', scope = schema_scope)):
			self._reference_datum = SET(value)
		else:
			self._reference_datum = value

####################
 # ENTITY tool_knurl #
####################
class tool_knurl(knurl):
	'''Entity tool_knurl definition.
	'''
	def __init__( self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , inherited5__base_feature , inherited6__partial_profile , inherited7__tooth_depth , inherited8__diametral_pitch , inherited9__root_fillet , inherited10__number_of_teeth , inherited11__major_diameter , inherited12__nominal_diameter ,  ):
		knurl.__init__(self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , inherited5__base_feature , inherited6__partial_profile , inherited7__tooth_depth , inherited8__diametral_pitch , inherited9__root_fillet , inherited10__number_of_teeth , inherited11__major_diameter , inherited12__nominal_diameter , )

####################
 # ENTITY machining_workingstep #
####################
class machining_workingstep(workingstep):
	'''Entity machining_workingstep definition.

	:param its_feature
	:type its_feature:manufacturing_feature

	:param its_operation
	:type its_operation:machining_operation

	:param its_effect
	:type its_effect:in_process_geometry

	:param final_features
	:type final_features:SET(0,None,'manufacturing_feature', scope = schema_scope)

	:param toolpath_orientation
	:type toolpath_orientation:axis2_placement_3d
	'''
	def __init__( self , inherited0__its_id , inherited1__its_secplane , its_feature,its_operation,its_effect,final_features,toolpath_orientation, ):
		workingstep.__init__(self , inherited0__its_id , inherited1__its_secplane , )
		self._its_feature = its_feature
		self._its_operation = its_operation
		self._its_effect = its_effect
		self._final_features = final_features
		self._toolpath_orientation = toolpath_orientation

	@property
	def its_feature(self):
		return self._its_feature
	@its_feature.setter
	def its_feature(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,manufacturing_feature):
			self._its_feature = manufacturing_feature(value)
		else:
			self._its_feature = value

	@property
	def its_operation(self):
		return self._its_operation
	@its_operation.setter
	def its_operation(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,machining_operation):
			self._its_operation = machining_operation(value)
		else:
			self._its_operation = value

	@property
	def its_effect(self):
		return self._its_effect
	@its_effect.setter
	def its_effect(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,in_process_geometry):
				self._its_effect = in_process_geometry(value)
			else:
				self._its_effect = value
		else:
			self._its_effect = value

	@property
	def final_features(self):
		return self._final_features
	@final_features.setter
	def final_features(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,SET(0,None,'manufacturing_feature', scope = schema_scope)):
				self._final_features = SET(value)
			else:
				self._final_features = value
		else:
			self._final_features = value

	@property
	def toolpath_orientation(self):
		return self._toolpath_orientation
	@toolpath_orientation.setter
	def toolpath_orientation(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,axis2_placement_3d):
				self._toolpath_orientation = axis2_placement_3d(value)
			else:
				self._toolpath_orientation = value
		else:
			self._toolpath_orientation = value

####################
 # ENTITY comparison_equal #
####################
class comparison_equal(comparison_expression):
	'''Entity comparison_equal definition.
	'''
	def __init__( self , inherited0__operand1 , inherited1__operand2 ,  ):
		comparison_expression.__init__(self , inherited0__operand1 , inherited1__operand2 , )

####################
 # ENTITY line_profile_tolerance #
####################
class line_profile_tolerance(geometric_tolerance):
	'''Entity line_profile_tolerance definition.

	:param affected_plane
	:type affected_plane:axis_placement

	:param reference_datum
	:type reference_datum:SET(0,3,'datum_reference', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__applied_to , inherited2__modification , inherited3__qualifying_note , inherited4__segment_size , inherited5__significant_digits , inherited6__tolerance_value , affected_plane,reference_datum, ):
		geometric_tolerance.__init__(self , inherited0__name , inherited1__applied_to , inherited2__modification , inherited3__qualifying_note , inherited4__segment_size , inherited5__significant_digits , inherited6__tolerance_value , )
		self._affected_plane = affected_plane
		self._reference_datum = reference_datum

	@property
	def affected_plane(self):
		return self._affected_plane
	@affected_plane.setter
	def affected_plane(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,axis_placement):
				self._affected_plane = axis_placement(value)
			else:
				self._affected_plane = value
		else:
			self._affected_plane = value

	@property
	def reference_datum(self):
		return self._reference_datum
	@reference_datum.setter
	def reference_datum(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(0,3,'datum_reference', scope = schema_scope)):
			self._reference_datum = SET(value)
		else:
			self._reference_datum = value

####################
 # ENTITY last_modified_timestamp #
####################
class last_modified_timestamp(BaseEntityClass):
	'''Entity last_modified_timestamp definition.

	:param date_and_time_value
	:type date_and_time_value:date_and_time

	:param items
	:type items:SET(1,None,'last_modified_timestamp_item', scope = schema_scope)
	'''
	def __init__( self , date_and_time_value,items, ):
		self._date_and_time_value = date_and_time_value
		self._items = items

	@property
	def date_and_time_value(self):
		return self._date_and_time_value
	@date_and_time_value.setter
	def date_and_time_value(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,date_and_time):
			self._date_and_time_value = date_and_time(value)
		else:
			self._date_and_time_value = value

	@property
	def items(self):
		return self._items
	@items.setter
	def items(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(1,None,'last_modified_timestamp_item', scope = schema_scope)):
			self._items = SET(value)
		else:
			self._items = value

####################
 # ENTITY side_finish_milling #
####################
class side_finish_milling(side_milling):
	'''Entity side_finish_milling definition.
	'''
	def __init__( self , inherited0__its_toolpath , inherited1__its_tool_direction , inherited2__its_id , inherited3__retract_plane , inherited4__start_point , inherited5__its_tool , inherited6__its_technology , inherited7__its_machine_functions , inherited8__overcut_length , inherited9__approach , inherited10__retract , inherited11__its_machining_strategy , inherited12__axial_cutting_depth , inherited13__radial_cutting_depth , inherited14__allowance_side ,  ):
		side_milling.__init__(self , inherited0__its_toolpath , inherited1__its_tool_direction , inherited2__its_id , inherited3__retract_plane , inherited4__start_point , inherited5__its_tool , inherited6__its_technology , inherited7__its_machine_functions , inherited8__overcut_length , inherited9__approach , inherited10__retract , inherited11__its_machining_strategy , inherited12__axial_cutting_depth , inherited13__radial_cutting_depth , inherited14__allowance_side , )

####################
 # ENTITY surface_property #
####################
class surface_property(general_property):
	'''Entity surface_property definition.

	:param is_surface_finish
	:type is_surface_finish:BOOLEAN

	:param surface_characteristics
	:type surface_characteristics:SET(0,None,'property_parameter', scope = schema_scope)
	'''
	def __init__( self , inherited0__description , inherited1__owner , inherited2__related_properties , inherited3__specifications , is_surface_finish,surface_characteristics, ):
		general_property.__init__(self , inherited0__description , inherited1__owner , inherited2__related_properties , inherited3__specifications , )
		self._is_surface_finish = is_surface_finish
		self._surface_characteristics = surface_characteristics

	@property
	def is_surface_finish(self):
		return self._is_surface_finish
	@is_surface_finish.setter
	def is_surface_finish(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,BOOLEAN):
			self._is_surface_finish = BOOLEAN(value)
		else:
			self._is_surface_finish = value

	@property
	def surface_characteristics(self):
		return self._surface_characteristics
	@surface_characteristics.setter
	def surface_characteristics(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(0,None,'property_parameter', scope = schema_scope)):
			self._surface_characteristics = SET(value)
		else:
			self._surface_characteristics = value

####################
 # ENTITY time_measure #
####################
class time_measure(value_with_tolerance):
	'''Entity time_measure definition.
	'''
	def __init__( self , inherited0__unit , inherited1__value_component , inherited2__limitation , inherited3__significant_digits ,  ):
		value_with_tolerance.__init__(self , inherited0__unit , inherited1__value_component , inherited2__limitation , inherited3__significant_digits , )

####################
 # ENTITY material #
####################
class material(BaseEntityClass):
	'''Entity material definition.

	:param standard_identifier
	:type standard_identifier:label

	:param material_identifier
	:type material_identifier:label

	:param material_property
	:type material_property:SET(0,None,'property_parameter', scope = schema_scope)
	'''
	def __init__( self , standard_identifier,material_identifier,material_property, ):
		self._standard_identifier = standard_identifier
		self._material_identifier = material_identifier
		self._material_property = material_property

	@property
	def standard_identifier(self):
		return self._standard_identifier
	@standard_identifier.setter
	def standard_identifier(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,label):
			self._standard_identifier = label(value)
		else:
			self._standard_identifier = value

	@property
	def material_identifier(self):
		return self._material_identifier
	@material_identifier.setter
	def material_identifier(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,label):
			self._material_identifier = label(value)
		else:
			self._material_identifier = value

	@property
	def material_property(self):
		return self._material_property
	@material_property.setter
	def material_property(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(0,None,'property_parameter', scope = schema_scope)):
			self._material_property = SET(value)
		else:
			self._material_property = value

####################
 # ENTITY radiused_slot_end_type #
####################
class radiused_slot_end_type(slot_end_type):
	'''Entity radiused_slot_end_type definition.
	'''
	def __init__( self ,  ):
		slot_end_type.__init__(self , )

####################
 # ENTITY spade_drill #
####################
class spade_drill(drilling_cutting_tool):
	'''Entity spade_drill definition.
	'''
	def __init__( self , inherited0__its_id , inherited1__its_usage , inherited2__its_cutting_edges , inherited3__overall_assembly_length , inherited4__effective_cutting_diameter , inherited5__maximum_depth_of_cut , inherited6__hand_of_cut , inherited7__coolant_through_tool , inherited8__point_angle ,  ):
		drilling_cutting_tool.__init__(self , inherited0__its_id , inherited1__its_usage , inherited2__its_cutting_edges , inherited3__overall_assembly_length , inherited4__effective_cutting_diameter , inherited5__maximum_depth_of_cut , inherited6__hand_of_cut , inherited7__coolant_through_tool , inherited8__point_angle , )

####################
 # ENTITY flat_with_radius_hole_bottom #
####################
class flat_with_radius_hole_bottom(blind_bottom_condition):
	'''Entity flat_with_radius_hole_bottom definition.

	:param corner_radius
	:type corner_radius:toleranced_length_measure
	'''
	def __init__( self , corner_radius, ):
		blind_bottom_condition.__init__(self , )
		self._corner_radius = corner_radius

	@property
	def corner_radius(self):
		return self._corner_radius
	@corner_radius.setter
	def corner_radius(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,toleranced_length_measure):
			self._corner_radius = toleranced_length_measure(value)
		else:
			self._corner_radius = value

####################
 # ENTITY chamfer #
####################
class chamfer(transition_feature):
	'''Entity chamfer definition.

	:param angle_to_plane
	:type angle_to_plane:plane_angle_measure

	:param first_offset_amount
	:type first_offset_amount:toleranced_length_measure

	:param chamfer_face
	:type chamfer_face:SET(1,None,'STRING', scope = schema_scope)

	:param first_face_shape
	:type first_face_shape:SET(1,None,'STRING', scope = schema_scope)

	:param second_face_shape
	:type second_face_shape:SET(1,None,'STRING', scope = schema_scope)
	'''
	def __init__( self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__first_feature , inherited5__second_feature , angle_to_plane,first_offset_amount,chamfer_face,first_face_shape,second_face_shape, ):
		transition_feature.__init__(self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__first_feature , inherited5__second_feature , )
		self._angle_to_plane = angle_to_plane
		self._first_offset_amount = first_offset_amount
		self._chamfer_face = chamfer_face
		self._first_face_shape = first_face_shape
		self._second_face_shape = second_face_shape

	@property
	def angle_to_plane(self):
		return self._angle_to_plane
	@angle_to_plane.setter
	def angle_to_plane(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,plane_angle_measure):
			self._angle_to_plane = plane_angle_measure(value)
		else:
			self._angle_to_plane = value

	@property
	def first_offset_amount(self):
		return self._first_offset_amount
	@first_offset_amount.setter
	def first_offset_amount(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,toleranced_length_measure):
			self._first_offset_amount = toleranced_length_measure(value)
		else:
			self._first_offset_amount = value

	@property
	def chamfer_face(self):
		return self._chamfer_face
	@chamfer_face.setter
	def chamfer_face(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,SET(1,None,'STRING', scope = schema_scope)):
				self._chamfer_face = SET(value)
			else:
				self._chamfer_face = value
		else:
			self._chamfer_face = value

	@property
	def first_face_shape(self):
		return self._first_face_shape
	@first_face_shape.setter
	def first_face_shape(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,SET(1,None,'STRING', scope = schema_scope)):
				self._first_face_shape = SET(value)
			else:
				self._first_face_shape = value
		else:
			self._first_face_shape = value

	@property
	def second_face_shape(self):
		return self._second_face_shape
	@second_face_shape.setter
	def second_face_shape(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,SET(1,None,'STRING', scope = schema_scope)):
				self._second_face_shape = SET(value)
			else:
				self._second_face_shape = value
		else:
			self._second_face_shape = value

####################
 # ENTITY comparison_less #
####################
class comparison_less(comparison_expression):
	'''Entity comparison_less definition.
	'''
	def __init__( self , inherited0__operand1 , inherited1__operand2 ,  ):
		comparison_expression.__init__(self , inherited0__operand1 , inherited1__operand2 , )

####################
 # ENTITY geometric_tolerance_relationship #
####################
class geometric_tolerance_relationship(BaseEntityClass):
	'''Entity geometric_tolerance_relationship definition.

	:param relation_type
	:type relation_type:STRING

	:param relating
	:type relating:geometric_tolerance

	:param related
	:type related:geometric_tolerance
	'''
	def __init__( self , relation_type,relating,related, ):
		self._relation_type = relation_type
		self._relating = relating
		self._related = related

	@property
	def relation_type(self):
		return self._relation_type
	@relation_type.setter
	def relation_type(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,STRING):
			self._relation_type = STRING(value)
		else:
			self._relation_type = value

	@property
	def relating(self):
		return self._relating
	@relating.setter
	def relating(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,geometric_tolerance):
			self._relating = geometric_tolerance(value)
		else:
			self._relating = value

	@property
	def related(self):
		return self._related
	@related.setter
	def related(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,geometric_tolerance):
			self._related = geometric_tolerance(value)
		else:
			self._related = value

####################
 # ENTITY if_statement #
####################
class if_statement(program_structure):
	'''Entity if_statement definition.

	:param condition
	:type condition:boolean_expression

	:param true_branch
	:type true_branch:executable

	:param false_branch
	:type false_branch:executable
	'''
	def __init__( self , inherited0__its_id , condition,true_branch,false_branch, ):
		program_structure.__init__(self , inherited0__its_id , )
		self._condition = condition
		self._true_branch = true_branch
		self._false_branch = false_branch

	@property
	def condition(self):
		return self._condition
	@condition.setter
	def condition(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,boolean_expression):
			self._condition = boolean_expression(value)
		else:
			self._condition = value

	@property
	def true_branch(self):
		return self._true_branch
	@true_branch.setter
	def true_branch(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,executable):
			self._true_branch = executable(value)
		else:
			self._true_branch = value

	@property
	def false_branch(self):
		return self._false_branch
	@false_branch.setter
	def false_branch(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,executable):
				self._false_branch = executable(value)
			else:
				self._false_branch = value
		else:
			self._false_branch = value

####################
 # ENTITY linear_distance_dimension #
####################
class linear_distance_dimension(location_dimension):
	'''Entity linear_distance_dimension definition.

	:param orientation
	:type orientation:axis_placement
	'''
	def __init__( self , inherited0__id , inherited1__dimension_value , inherited2__notes , inherited3__description , inherited4__directed , inherited5__origin , inherited6__target , orientation, ):
		location_dimension.__init__(self , inherited0__id , inherited1__dimension_value , inherited2__notes , inherited3__description , inherited4__directed , inherited5__origin , inherited6__target , )
		self._orientation = orientation

	@property
	def orientation(self):
		return self._orientation
	@orientation.setter
	def orientation(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,axis_placement):
				self._orientation = axis_placement(value)
			else:
				self._orientation = value
		else:
			self._orientation = value

####################
 # ENTITY person_and_address #
####################
class person_and_address(BaseEntityClass):
	'''Entity person_and_address definition.

	:param its_person
	:type its_person:person

	:param its_address
	:type its_address:address
	'''
	def __init__( self , its_person,its_address, ):
		self._its_person = its_person
		self._its_address = its_address

	@property
	def its_person(self):
		return self._its_person
	@its_person.setter
	def its_person(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,person):
			self._its_person = person(value)
		else:
			self._its_person = value

	@property
	def its_address(self):
		return self._its_address
	@its_address.setter
	def its_address(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,address):
				self._its_address = address(value)
			else:
				self._its_address = value
		else:
			self._its_address = value

####################
 # ENTITY ap_lift_path_tangent #
####################
class ap_lift_path_tangent(approach_lift_path):
	'''Entity ap_lift_path_tangent definition.

	:param radius
	:type radius:length_measure
	'''
	def __init__( self , inherited0__its_priority , inherited1__its_type , inherited2__its_speed , inherited3__its_technology , inherited4__its_machine_functions , inherited5__its_id , inherited6__fix_point , inherited7__fix_point_dir , radius, ):
		approach_lift_path.__init__(self , inherited0__its_priority , inherited1__its_type , inherited2__its_speed , inherited3__its_technology , inherited4__its_machine_functions , inherited5__its_id , inherited6__fix_point , inherited7__fix_point_dir , )
		self._radius = radius

	@property
	def radius(self):
		return self._radius
	@radius.setter
	def radius(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,length_measure):
			self._radius = length_measure(value)
		else:
			self._radius = value

####################
 # ENTITY return_home #
####################
class return_home(rapid_movement):
	'''Entity return_home definition.
	'''
	def __init__( self , inherited0__its_id , inherited1__its_secplane , inherited2__its_toolpath , inherited3__its_tool_direction ,  ):
		rapid_movement.__init__(self , inherited0__its_id , inherited1__its_secplane , inherited2__its_toolpath , inherited3__its_tool_direction , )

####################
 # ENTITY assigned_person #
####################
class assigned_person(BaseEntityClass):
	'''Entity assigned_person definition.

	:param person_and_organization_value
	:type person_and_organization_value:person_and_organization

	:param role
	:type role:STRING
	'''
	def __init__( self , person_and_organization_value,role, ):
		self._person_and_organization_value = person_and_organization_value
		self._role = role

	@property
	def person_and_organization_value(self):
		return self._person_and_organization_value
	@person_and_organization_value.setter
	def person_and_organization_value(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,person_and_organization):
			self._person_and_organization_value = person_and_organization(value)
		else:
			self._person_and_organization_value = value

	@property
	def role(self):
		return self._role
	@role.setter
	def role(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,STRING):
			self._role = STRING(value)
		else:
			self._role = value

####################
 # ENTITY through_profile_floor #
####################
class through_profile_floor(BaseEntityClass):
	'''Entity through_profile_floor definition.
	'''
	# This class does not define any attribute.
	pass

####################
 # ENTITY region_projection #
####################
class region_projection(region):
	'''Entity region_projection definition.

	:param proj_curve
	:type proj_curve:bounded_curve

	:param proj_dir
	:type proj_dir:direction

	:param depth
	:type depth:toleranced_length_measure
	'''
	def __init__( self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , proj_curve,proj_dir,depth, ):
		region.__init__(self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , )
		self._proj_curve = proj_curve
		self._proj_dir = proj_dir
		self._depth = depth

	@property
	def proj_curve(self):
		return self._proj_curve
	@proj_curve.setter
	def proj_curve(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,bounded_curve):
			self._proj_curve = bounded_curve(value)
		else:
			self._proj_curve = value

	@property
	def proj_dir(self):
		return self._proj_dir
	@proj_dir.setter
	def proj_dir(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,direction):
			self._proj_dir = direction(value)
		else:
			self._proj_dir = value

	@property
	def depth(self):
		return self._depth
	@depth.setter
	def depth(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,toleranced_length_measure):
			self._depth = toleranced_length_measure(value)
		else:
			self._depth = value

####################
 # ENTITY multistep_drilling #
####################
class multistep_drilling(drilling_operation):
	'''Entity multistep_drilling definition.

	:param retract_distance
	:type retract_distance:length_measure

	:param first_depth
	:type first_depth:length_measure

	:param depth_of_step
	:type depth_of_step:length_measure

	:param dwell_time_step
	:type dwell_time_step:time_measure
	'''
	def __init__( self , inherited0__its_toolpath , inherited1__its_tool_direction , inherited2__its_id , inherited3__retract_plane , inherited4__start_point , inherited5__its_tool , inherited6__its_technology , inherited7__its_machine_functions , inherited8__overcut_length , inherited9__cutting_depth , inherited10__previous_diameter , inherited11__dwell_time_bottom , inherited12__feed_on_retract , inherited13__its_machining_strategy , retract_distance,first_depth,depth_of_step,dwell_time_step, ):
		drilling_operation.__init__(self , inherited0__its_toolpath , inherited1__its_tool_direction , inherited2__its_id , inherited3__retract_plane , inherited4__start_point , inherited5__its_tool , inherited6__its_technology , inherited7__its_machine_functions , inherited8__overcut_length , inherited9__cutting_depth , inherited10__previous_diameter , inherited11__dwell_time_bottom , inherited12__feed_on_retract , inherited13__its_machining_strategy , )
		self._retract_distance = retract_distance
		self._first_depth = first_depth
		self._depth_of_step = depth_of_step
		self._dwell_time_step = dwell_time_step

	@property
	def retract_distance(self):
		return self._retract_distance
	@retract_distance.setter
	def retract_distance(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,length_measure):
			self._retract_distance = length_measure(value)
		else:
			self._retract_distance = value

	@property
	def first_depth(self):
		return self._first_depth
	@first_depth.setter
	def first_depth(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,length_measure):
			self._first_depth = length_measure(value)
		else:
			self._first_depth = value

	@property
	def depth_of_step(self):
		return self._depth_of_step
	@depth_of_step.setter
	def depth_of_step(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,length_measure):
			self._depth_of_step = length_measure(value)
		else:
			self._depth_of_step = value

	@property
	def dwell_time_step(self):
		return self._dwell_time_step
	@dwell_time_step.setter
	def dwell_time_step(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,time_measure):
				self._dwell_time_step = time_measure(value)
			else:
				self._dwell_time_step = value
		else:
			self._dwell_time_step = value

####################
 # ENTITY round_hole #
####################
class round_hole(machining_feature):
	'''Entity round_hole definition.

	:param diameter
	:type diameter:toleranced_length_measure

	:param change_in_diameter
	:type change_in_diameter:taper_select

	:param bottom_condition
	:type bottom_condition:hole_bottom_condition

	:param bottom_at_path_end
	:type bottom_at_path_end:BOOLEAN

	:param course_of_travel
	:type course_of_travel:linear_path
	'''
	def __init__( self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , inherited5__depth , diameter,change_in_diameter,bottom_condition,bottom_at_path_end,course_of_travel, ):
		machining_feature.__init__(self , inherited0__its_id , inherited1__its_workpiece , inherited2__its_operations , inherited3__explicit_representation , inherited4__feature_placement , inherited5__depth , )
		self._diameter = diameter
		self._change_in_diameter = change_in_diameter
		self._bottom_condition = bottom_condition
		self._bottom_at_path_end = bottom_at_path_end
		self._course_of_travel = course_of_travel

	@property
	def diameter(self):
		return self._diameter
	@diameter.setter
	def diameter(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,toleranced_length_measure):
			self._diameter = toleranced_length_measure(value)
		else:
			self._diameter = value

	@property
	def change_in_diameter(self):
		return self._change_in_diameter
	@change_in_diameter.setter
	def change_in_diameter(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,taper_select):
				self._change_in_diameter = taper_select(value)
			else:
				self._change_in_diameter = value
		else:
			self._change_in_diameter = value

	@property
	def bottom_condition(self):
		return self._bottom_condition
	@bottom_condition.setter
	def bottom_condition(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,hole_bottom_condition):
			self._bottom_condition = hole_bottom_condition(value)
		else:
			self._bottom_condition = value

	@property
	def bottom_at_path_end(self):
		return self._bottom_at_path_end
	@bottom_at_path_end.setter
	def bottom_at_path_end(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,BOOLEAN):
				self._bottom_at_path_end = BOOLEAN(value)
			else:
				self._bottom_at_path_end = value
		else:
			self._bottom_at_path_end = value

	@property
	def course_of_travel(self):
		return self._course_of_travel
	@course_of_travel.setter
	def course_of_travel(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,linear_path):
			self._course_of_travel = linear_path(value)
		else:
			self._course_of_travel = value
	def wr1(self):
		eval_wr1_wr = (EXISTS(self.bottom_at_path_end)  or  ( not ('AP238_ARM_SCHEMA.BLIND_BOTTOM_CONDITION'  ==  TYPEOF(self.bottom_condition))))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY wait_for_mark #
####################
class wait_for_mark(nc_function):
	'''Entity wait_for_mark definition.

	:param its_channel
	:type its_channel:channel
	'''
	def __init__( self , inherited0__its_id , its_channel, ):
		nc_function.__init__(self , inherited0__its_id , )
		self._its_channel = its_channel

	@property
	def its_channel(self):
		return self._its_channel
	@its_channel.setter
	def its_channel(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,channel):
			self._its_channel = channel(value)
		else:
			self._its_channel = value

####################
 # ENTITY profiled_corner #
####################
class profiled_corner(BaseEntityClass):
	'''Entity profiled_corner definition.

	:param transition_profile
	:type transition_profile:open_profile
	'''
	def __init__( self , transition_profile, ):
		self._transition_profile = transition_profile

	@property
	def transition_profile(self):
		return self._transition_profile
	@transition_profile.setter
	def transition_profile(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,open_profile):
			self._transition_profile = open_profile(value)
		else:
			self._transition_profile = value

####################
 # ENTITY angular_size_dimension #
####################
class angular_size_dimension(size_dimension):
	'''Entity angular_size_dimension definition.

	:param full
	:type full:BOOLEAN

	:param major_angle
	:type major_angle:BOOLEAN
	'''
	def __init__( self , inherited0__id , inherited1__dimension_value , inherited2__notes , inherited3__applied_to , inherited4__envelope_principle , full,major_angle, ):
		size_dimension.__init__(self , inherited0__id , inherited1__dimension_value , inherited2__notes , inherited3__applied_to , inherited4__envelope_principle , )
		self._full = full
		self._major_angle = major_angle

	@property
	def full(self):
		return self._full
	@full.setter
	def full(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,BOOLEAN):
			self._full = BOOLEAN(value)
		else:
			self._full = value

	@property
	def major_angle(self):
		return self._major_angle
	@major_angle.setter
	def major_angle(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,BOOLEAN):
			self._major_angle = BOOLEAN(value)
		else:
			self._major_angle = value

####################
 # ENTITY parallelism_tolerance #
####################
class parallelism_tolerance(geometric_tolerance):
	'''Entity parallelism_tolerance definition.

	:param affected_plane
	:type affected_plane:axis_placement

	:param reference_datum
	:type reference_datum:SET(1,2,'datum_reference', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__applied_to , inherited2__modification , inherited3__qualifying_note , inherited4__segment_size , inherited5__significant_digits , inherited6__tolerance_value , affected_plane,reference_datum, ):
		geometric_tolerance.__init__(self , inherited0__name , inherited1__applied_to , inherited2__modification , inherited3__qualifying_note , inherited4__segment_size , inherited5__significant_digits , inherited6__tolerance_value , )
		self._affected_plane = affected_plane
		self._reference_datum = reference_datum

	@property
	def affected_plane(self):
		return self._affected_plane
	@affected_plane.setter
	def affected_plane(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,axis_placement):
				self._affected_plane = axis_placement(value)
			else:
				self._affected_plane = value
		else:
			self._affected_plane = value

	@property
	def reference_datum(self):
		return self._reference_datum
	@reference_datum.setter
	def reference_datum(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(1,2,'datum_reference', scope = schema_scope)):
			self._reference_datum = SET(value)
		else:
			self._reference_datum = value

####################
 # ENTITY total_runout_tolerance #
####################
class total_runout_tolerance(geometric_tolerance):
	'''Entity total_runout_tolerance definition.

	:param angle
	:type angle:REAL

	:param reference_datum
	:type reference_datum:SET(1,2,'datum_reference', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__applied_to , inherited2__modification , inherited3__qualifying_note , inherited4__segment_size , inherited5__significant_digits , inherited6__tolerance_value , angle,reference_datum, ):
		geometric_tolerance.__init__(self , inherited0__name , inherited1__applied_to , inherited2__modification , inherited3__qualifying_note , inherited4__segment_size , inherited5__significant_digits , inherited6__tolerance_value , )
		self._angle = angle
		self._reference_datum = reference_datum

	@property
	def angle(self):
		return self._angle
	@angle.setter
	def angle(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,REAL):
			self._angle = REAL(value)
		else:
			self._angle = value

	@property
	def reference_datum(self):
		return self._reference_datum
	@reference_datum.setter
	def reference_datum(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(1,2,'datum_reference', scope = schema_scope)):
			self._reference_datum = SET(value)
		else:
			self._reference_datum = value

####################
 # ENTITY tapered_reamer #
####################
class tapered_reamer(reaming_cutting_tool):
	'''Entity tapered_reamer definition.

	:param taper_angle
	:type taper_angle:plane_angle_measure
	'''
	def __init__( self , inherited0__its_id , inherited1__its_usage , inherited2__its_cutting_edges , inherited3__overall_assembly_length , inherited4__effective_cutting_diameter , inherited5__maximum_depth_of_cut , inherited6__hand_of_cut , inherited7__coolant_through_tool , inherited8__taper_length , taper_angle, ):
		reaming_cutting_tool.__init__(self , inherited0__its_id , inherited1__its_usage , inherited2__its_cutting_edges , inherited3__overall_assembly_length , inherited4__effective_cutting_diameter , inherited5__maximum_depth_of_cut , inherited6__hand_of_cut , inherited7__coolant_through_tool , inherited8__taper_length , )
		self._taper_angle = taper_angle

	@property
	def taper_angle(self):
		return self._taper_angle
	@taper_angle.setter
	def taper_angle(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,plane_angle_measure):
			self._taper_angle = plane_angle_measure(value)
		else:
			self._taper_angle = value

####################
 # ENTITY assigned_organization #
####################
class assigned_organization(BaseEntityClass):
	'''Entity assigned_organization definition.

	:param organization_value
	:type organization_value:organization

	:param role
	:type role:STRING
	'''
	def __init__( self , organization_value,role, ):
		self._organization_value = organization_value
		self._role = role

	@property
	def organization_value(self):
		return self._organization_value
	@organization_value.setter
	def organization_value(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,organization):
			self._organization_value = organization(value)
		else:
			self._organization_value = value

	@property
	def role(self):
		return self._role
	@role.setter
	def role(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,STRING):
			self._role = STRING(value)
		else:
			self._role = value

####################
 # ENTITY angle_taper #
####################
class angle_taper(BaseEntityClass):
	'''Entity angle_taper definition.

	:param angle
	:type angle:plane_angle_measure
	'''
	def __init__( self , angle, ):
		self._angle = angle

	@property
	def angle(self):
		return self._angle
	@angle.setter
	def angle(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,plane_angle_measure):
			self._angle = plane_angle_measure(value)
		else:
			self._angle = value
