# This file was generated by exp2python.  You probably don't want to edit
# it since your modifications will be lost if exp2python is used to
# regenerate it.
import sys

from SCL.SCLBase import *
from SCL.SimpleDataTypes import *
from SCL.ConstructedDataTypes import *
from SCL.AggregationDataTypes import *
from SCL.TypeChecker import check_type
from SCL.Builtin import *
from SCL.Rules import *

schema_name = 'config_control_design'

schema_scope = sys.modules[__name__]

# Defined datatype text
class text(STRING):
	def __init__(self,*kargs):
		pass

# Defined datatype dimension_count
class dimension_count(INTEGER):
	def __init__(self,*kargs):
		pass
		self.wr1()

	def wr1(self):
		eval_wr1_wr = (self  >  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

# Defined datatype volume_measure
class volume_measure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype year_number
class year_number(INTEGER):
	def __init__(self,*kargs):
		pass

# Defined datatype week_in_year_number
class week_in_year_number(INTEGER):
	def __init__(self,*kargs):
		pass
		self.wr1()

	def wr1(self):
		eval_wr1_wr = ((1  <=  self)  and  (self  <=  53))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

# Defined datatype area_measure
class area_measure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype hour_in_day
class hour_in_day(INTEGER):
	def __init__(self,*kargs):
		pass
		self.wr1()

	def wr1(self):
		eval_wr1_wr = ((0  <=  self)  and  (self  <  24))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

# Defined datatype month_in_year_number
class month_in_year_number(INTEGER):
	def __init__(self,*kargs):
		pass
		self.wr1()

	def wr1(self):
		eval_wr1_wr = ((1  <=  self)  and  (self  <=  12))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

# Defined datatype length_measure
class length_measure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype count_measure
class count_measure(NUMBER):
	def __init__(self,*kargs):
		pass

# Defined datatype descriptive_measure
class descriptive_measure(STRING):
	def __init__(self,*kargs):
		pass

# Defined datatype plane_angle_measure
class plane_angle_measure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype day_in_month_number
class day_in_month_number(INTEGER):
	def __init__(self,*kargs):
		pass

# Defined datatype identifier
class identifier(STRING):
	def __init__(self,*kargs):
		pass

# Defined datatype parameter_value
class parameter_value(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype mass_measure
class mass_measure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype day_in_week_number
class day_in_week_number(INTEGER):
	def __init__(self,*kargs):
		pass
		self.wr1()

	def wr1(self):
		eval_wr1_wr = ((1  <=  self)  and  (self  <=  7))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

# Defined datatype minute_in_hour
class minute_in_hour(INTEGER):
	def __init__(self,*kargs):
		pass
		self.wr1()

	def wr1(self):
		eval_wr1_wr = ((0  <=  self)  and  (self  <=  59))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

# Defined datatype context_dependent_measure
class context_dependent_measure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype solid_angle_measure
class solid_angle_measure(REAL):
	def __init__(self,*kargs):
		pass

# Defined datatype second_in_minute
class second_in_minute(REAL):
	def __init__(self,*kargs):
		pass
		self.wr1()

	def wr1(self):
		eval_wr1_wr = ((0  <=  self)  and  (self  <  60))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

# Defined datatype label
class label(STRING):
	def __init__(self,*kargs):
		pass

# Defined datatype day_in_year_number
class day_in_year_number(INTEGER):
	def __init__(self,*kargs):
		pass

# Defined datatype positive_length_measure
class positive_length_measure(length_measure):
	def __init__(self,*kargs):
		pass
		self.wr1()

	def wr1(self):
		eval_wr1_wr = (self  >  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

# Defined datatype positive_plane_angle_measure
class positive_plane_angle_measure(plane_angle_measure):
	def __init__(self,*kargs):
		pass
		self.wr1()

	def wr1(self):
		eval_wr1_wr = (self  >  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

# SELECT TYPE founded_item_select
founded_item_select = SELECT(
	'founded_item',
	'representation_item',
	scope = schema_scope)
# Defined datatype ahead_or_behind
class ahead_or_behind(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE pcurve_or_surface
pcurve_or_surface = SELECT(
	'pcurve',
	'surface',
	scope = schema_scope)
# SELECT TYPE contracted_item
contracted_item = SELECT(
	'product_definition_formation',
	scope = schema_scope)
# SELECT TYPE work_item
work_item = SELECT(
	'product_definition_formation',
	scope = schema_scope)
# SELECT TYPE surface_model
surface_model = SELECT(
	'shell_based_surface_model',
	scope = schema_scope)
# SELECT TYPE vector_or_direction
vector_or_direction = SELECT(
	'vector',
	'direction',
	scope = schema_scope)
list_of_reversible_topology_item = LIST(0,None,'reversible_topology_item', scope = schema_scope)
# SELECT TYPE date_time_select
date_time_select = SELECT(
	'date',
	'local_time',
	'date_and_time',
	scope = schema_scope)
# SELECT TYPE person_organization_select
person_organization_select = SELECT(
	'person',
	'organization',
	'person_and_organization',
	scope = schema_scope)
# Defined datatype trimming_preference
class trimming_preference(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE curve_on_surface
curve_on_surface = SELECT(
	'pcurve',
	'surface_curve',
	'composite_curve_on_surface',
	scope = schema_scope)
# Defined datatype preferred_surface_curve_representation
class preferred_surface_curve_representation(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype transition_code
class transition_code(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE geometric_set_select
geometric_set_select = SELECT(
	'point',
	'curve',
	'surface',
	scope = schema_scope)
# SELECT TYPE shape_definition
shape_definition = SELECT(
	'product_definition_shape',
	'shape_aspect',
	'shape_aspect_relationship',
	scope = schema_scope)
# Defined datatype si_prefix
class si_prefix(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE classified_item
classified_item = SELECT(
	'product_definition_formation',
	'assembly_component_usage',
	scope = schema_scope)
set_of_reversible_topology_item = SET(0,None,'reversible_topology_item', scope = schema_scope)
# SELECT TYPE transformation
transformation = SELECT(
	'item_defined_transformation',
	'functionally_defined_transformation',
	scope = schema_scope)
# SELECT TYPE characterized_product_definition
characterized_product_definition = SELECT(
	'product_definition',
	'product_definition_relationship',
	scope = schema_scope)
# SELECT TYPE shell
shell = SELECT(
	'vertex_shell',
	'wire_shell',
	'open_shell',
	'closed_shell',
	scope = schema_scope)
# SELECT TYPE measure_value
measure_value = SELECT(
	'length_measure',
	'mass_measure',
	'plane_angle_measure',
	'solid_angle_measure',
	'area_measure',
	'volume_measure',
	'parameter_value',
	'context_dependent_measure',
	'descriptive_measure',
	'positive_length_measure',
	'positive_plane_angle_measure',
	'count_measure',
	scope = schema_scope)
# Defined datatype si_unit_name
class si_unit_name(ENUMERATION):
	def __init__(self,*kargs):
		pass

# Defined datatype b_spline_curve_form
class b_spline_curve_form(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE change_request_item
change_request_item = SELECT(
	'product_definition_formation',
	scope = schema_scope)
# SELECT TYPE characterized_definition
characterized_definition = SELECT(
	'characterized_product_definition',
	'shape_definition',
	scope = schema_scope)
# Defined datatype b_spline_surface_form
class b_spline_surface_form(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE boolean_operand
boolean_operand = SELECT(
	'solid_model',
	scope = schema_scope)
# SELECT TYPE start_request_item
start_request_item = SELECT(
	'product_definition_formation',
	scope = schema_scope)
# SELECT TYPE specified_item
specified_item = SELECT(
	'product_definition',
	'shape_aspect',
	scope = schema_scope)
# SELECT TYPE person_organization_item
person_organization_item = SELECT(
	'change',
	'start_work',
	'change_request',
	'start_request',
	'configuration_item',
	'product',
	'product_definition_formation',
	'product_definition',
	'contract',
	'security_classification',
	scope = schema_scope)
# SELECT TYPE certified_item
certified_item = SELECT(
	'supplied_part_relationship',
	scope = schema_scope)
# Defined datatype source
class source(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE unit
unit = SELECT(
	'named_unit',
	scope = schema_scope)
# SELECT TYPE reversible_topology
reversible_topology = SELECT(
	'reversible_topology_item',
	'list_of_reversible_topology_item',
	'set_of_reversible_topology_item',
	scope = schema_scope)
# SELECT TYPE axis2_placement
axis2_placement = SELECT(
	'axis2_placement_2d',
	'axis2_placement_3d',
	scope = schema_scope)
# SELECT TYPE trimming_select
trimming_select = SELECT(
	'cartesian_point',
	'parameter_value',
	scope = schema_scope)
# SELECT TYPE approved_item
approved_item = SELECT(
	'product_definition_formation',
	'product_definition',
	'configuration_effectivity',
	'configuration_item',
	'security_classification',
	'change_request',
	'change',
	'start_request',
	'start_work',
	'certification',
	'contract',
	scope = schema_scope)
# SELECT TYPE reversible_topology_item
reversible_topology_item = SELECT(
	'edge',
	'path',
	'face',
	'face_bound',
	'closed_shell',
	'open_shell',
	scope = schema_scope)
# SELECT TYPE supported_item
supported_item = SELECT(
	'action_directive',
	'action',
	'action_method',
	scope = schema_scope)
# SELECT TYPE date_time_item
date_time_item = SELECT(
	'product_definition',
	'change_request',
	'start_request',
	'change',
	'start_work',
	'approval_person_organization',
	'contract',
	'security_classification',
	'certification',
	scope = schema_scope)
# Defined datatype knot_type
class knot_type(ENUMERATION):
	def __init__(self,*kargs):
		pass

# SELECT TYPE wireframe_model
wireframe_model = SELECT(
	'shell_based_wireframe_model',
	'edge_based_wireframe_model',
	scope = schema_scope)

####################
 # ENTITY document_usage_constraint #
####################
class document_usage_constraint(BaseEntityClass):
	'''Entity document_usage_constraint definition.

	:param source
	:type source:document

	:param subject_element
	:type subject_element:label

	:param subject_element_value
	:type subject_element_value:text
	'''
	def __init__( self , source,subject_element,subject_element_value, ):
		self._source = source
		self._subject_element = subject_element
		self._subject_element_value = subject_element_value

	@property
	def source(self):
		return self._source
	@source.setter
	def source(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,document):
			self._source = document(value)
		else:
			self._source = value

	@property
	def subject_element(self):
		return self._subject_element
	@subject_element.setter
	def subject_element(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,label):
			self._subject_element = label(value)
		else:
			self._subject_element = value

	@property
	def subject_element_value(self):
		return self._subject_element_value
	@subject_element_value.setter
	def subject_element_value(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,text):
			self._subject_element_value = text(value)
		else:
			self._subject_element_value = value

####################
 # ENTITY representation #
####################
class representation(BaseEntityClass):
	'''Entity representation definition.

	:param name
	:type name:label

	:param items
	:type items:SET(1,None,'representation_item', scope = schema_scope)

	:param context_of_items
	:type context_of_items:representation_context
	'''
	def __init__( self , name,items,context_of_items, ):
		self._name = name
		self._items = items
		self._context_of_items = context_of_items

	@property
	def name(self):
		return self._name
	@name.setter
	def name(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,label):
			self._name = label(value)
		else:
			self._name = value

	@property
	def items(self):
		return self._items
	@items.setter
	def items(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(1,None,'representation_item', scope = schema_scope)):
			self._items = SET(value)
		else:
			self._items = value

	@property
	def context_of_items(self):
		return self._context_of_items
	@context_of_items.setter
	def context_of_items(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,representation_context):
			self._context_of_items = representation_context(value)
		else:
			self._context_of_items = value

####################
 # ENTITY shape_representation #
####################
class shape_representation(representation):
	'''Entity shape_representation definition.
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items ,  ):
		representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )

####################
 # ENTITY faceted_brep_shape_representation #
####################
class faceted_brep_shape_representation(shape_representation):
	'''Entity faceted_brep_shape_representation definition.
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items ,  ):
		shape_representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  >  0)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  0)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(None)  ==  0)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = (SIZEOF(None)  ==  0)
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr

	def wr6(self):
		eval_wr6_wr = (SIZEOF(None)  ==  0)
		if not eval_wr6_wr:
			raise AssertionError('Rule wr6 violated')
		else:
			return eval_wr6_wr

	def wr7(self):
		eval_wr7_wr = (SIZEOF(None)  ==  0)
		if not eval_wr7_wr:
			raise AssertionError('Rule wr7 violated')
		else:
			return eval_wr7_wr


####################
 # ENTITY founded_item #
####################
class founded_item(BaseEntityClass):
	'''Entity founded_item definition.
	'''
	# This class does not define any attribute.
	pass

####################
 # ENTITY composite_curve_segment #
####################
class composite_curve_segment(founded_item):
	'''Entity composite_curve_segment definition.

	:param transition
	:type transition:transition_code

	:param same_sense
	:type same_sense:BOOLEAN

	:param parent_curve
	:type parent_curve:curve

	:param using_curves
	:type using_curves:BAG(1,None,'composite_curve', scope = schema_scope)
	'''
	def __init__( self , transition,same_sense,parent_curve, ):
		founded_item.__init__(self , )
		self._transition = transition
		self._same_sense = same_sense
		self._parent_curve = parent_curve

	@property
	def transition(self):
		return self._transition
	@transition.setter
	def transition(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,transition_code):
			self._transition = transition_code(value)
		else:
			self._transition = value

	@property
	def same_sense(self):
		return self._same_sense
	@same_sense.setter
	def same_sense(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,BOOLEAN):
			self._same_sense = BOOLEAN(value)
		else:
			self._same_sense = value

	@property
	def parent_curve(self):
		return self._parent_curve
	@parent_curve.setter
	def parent_curve(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,curve):
			self._parent_curve = curve(value)
		else:
			self._parent_curve = value

	@property
	def using_curves(self):
		return self._using_curves
	@using_curves.setter
	def using_curves(self, value):
	# INVERSE argument
		raise AssertionError('Argument using_curves is INVERSE. It is computed and can not be set to any value')
	def wr1(self):
		eval_wr1_wr = ('CONFIG_CONTROL_DESIGN.BOUNDED_CURVE'  ==  TYPEOF(self.parent_curve))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY reparametrised_composite_curve_segment #
####################
class reparametrised_composite_curve_segment(composite_curve_segment):
	'''Entity reparametrised_composite_curve_segment definition.

	:param param_length
	:type param_length:parameter_value
	'''
	def __init__( self , inherited0__transition , inherited1__same_sense , inherited2__parent_curve , param_length, ):
		composite_curve_segment.__init__(self , inherited0__transition , inherited1__same_sense , inherited2__parent_curve , )
		self._param_length = param_length

	@property
	def param_length(self):
		return self._param_length
	@param_length.setter
	def param_length(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,parameter_value):
			self._param_length = parameter_value(value)
		else:
			self._param_length = value
	def wr1(self):
		eval_wr1_wr = (self.param_length  >  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY representation_item #
####################
class representation_item(BaseEntityClass):
	'''Entity representation_item definition.

	:param name
	:type name:label
	'''
	def __init__( self , name, ):
		self._name = name

	@property
	def name(self):
		return self._name
	@name.setter
	def name(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,label):
			self._name = label(value)
		else:
			self._name = value
	def wr1(self):
		eval_wr1_wr = (SIZEOF(using_representations(self))  >  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY geometric_representation_item #
####################
class geometric_representation_item(representation_item):
	'''Entity geometric_representation_item definition.

	:param dim
	:type dim:dimension_count
	'''
	def __init__( self , inherited0__name ,  ):
		representation_item.__init__(self , inherited0__name , )

	@property
	def dim(self):
		attribute_eval = dimension_of(self)
		return attribute_eval
	@dim.setter
	def dim(self, value):
	# DERIVED argument
		raise AssertionError('Argument dim is DERIVED. It is computed and can not be set to any value')
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY placement #
####################
class placement(geometric_representation_item):
	'''Entity placement definition.

	:param location
	:type location:cartesian_point
	'''
	def __init__( self , inherited0__name , location, ):
		geometric_representation_item.__init__(self , inherited0__name , )
		self._location = location

	@property
	def location(self):
		return self._location
	@location.setter
	def location(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,cartesian_point):
			self._location = cartesian_point(value)
		else:
			self._location = value

####################
 # ENTITY axis1_placement #
####################
class axis1_placement(placement):
	'''Entity axis1_placement definition.

	:param axis
	:type axis:direction

	:param z
	:type z:direction
	'''
	def __init__( self , inherited0__name , inherited1__location , axis, ):
		placement.__init__(self , inherited0__name , inherited1__location , )
		self._axis = axis

	def printer(self):
		print '        '+self.location.stepLine
		print '        '+self.axis.stepLine

	@property
	def axis(self):
		return self._axis
	@axis.setter
	def axis(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,direction):
				self._axis = direction(value)
			else:
				self._axis = value
		else:
			self._axis = value

	@property
	def z(self):
		attribute_eval = NVL(normalise(self.axis),self.dummy_gri  ==  direction([0,0,1]))
		return attribute_eval
	@z.setter
	def z(self, value):
	# DERIVED argument
		raise AssertionError('Argument z is DERIVED. It is computed and can not be set to any value')
	def wr1(self):
		eval_wr1_wr = (self.self.geometric_representation_item.self.dim  ==  3)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY curve #
####################
class curve(geometric_representation_item):
	'''Entity curve definition.
	'''
	def __init__( self , inherited0__name ,  ):
		geometric_representation_item.__init__(self , inherited0__name , )

####################
 # ENTITY bounded_curve #
####################
class bounded_curve(curve):
	'''Entity bounded_curve definition.
	'''
	def __init__( self , inherited0__name ,  ):
		curve.__init__(self , inherited0__name , )

####################
 # ENTITY b_spline_curve #
####################
class b_spline_curve(bounded_curve):
	'''Entity b_spline_curve definition.

	:param degree
	:type degree:INTEGER

	:param control_points_list
	:type control_points_list:LIST(2,None,'cartesian_point', scope = schema_scope)

	:param curve_form
	:type curve_form:b_spline_curve_form

	:param closed_curve
	:type closed_curve:LOGICAL

	:param self_intersect
	:type self_intersect:LOGICAL

	:param upper_index_on_control_points
	:type upper_index_on_control_points:INTEGER

	:param control_points
	:type control_points:ARRAY(0,upper_index_on_control_points,'cartesian_point', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , degree,control_points_list,curve_form,closed_curve,self_intersect, ):
		bounded_curve.__init__(self , inherited0__name , )
		self._degree = degree
		self._control_points_list = control_points_list
		self._curve_form = curve_form
		self._closed_curve = closed_curve
		self._self_intersect = self_intersect

	@property
	def degree(self):
		return self._degree
	@degree.setter
	def degree(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,INTEGER):
			self._degree = INTEGER(value)
		else:
			self._degree = value

	@property
	def control_points_list(self):
		return self._control_points_list
	@control_points_list.setter
	def control_points_list(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,LIST(2,None,'cartesian_point', scope = schema_scope)):
			self._control_points_list = LIST(value)
		else:
			self._control_points_list = value

	@property
	def curve_form(self):
		return self._curve_form
	@curve_form.setter
	def curve_form(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,b_spline_curve_form):
			self._curve_form = b_spline_curve_form(value)
		else:
			self._curve_form = value

	@property
	def closed_curve(self):
		return self._closed_curve
	@closed_curve.setter
	def closed_curve(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,LOGICAL):
			self._closed_curve = LOGICAL(value)
		else:
			self._closed_curve = value

	@property
	def self_intersect(self):
		return self._self_intersect
	@self_intersect.setter
	def self_intersect(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,LOGICAL):
			self._self_intersect = LOGICAL(value)
		else:
			self._self_intersect = value

	@property
	def upper_index_on_control_points(self):
		attribute_eval = (SIZEOF(self.control_points_list) - 1)
		return attribute_eval
	@upper_index_on_control_points.setter
	def upper_index_on_control_points(self, value):
	# DERIVED argument
		raise AssertionError('Argument upper_index_on_control_points is DERIVED. It is computed and can not be set to any value')

	@property
	def control_points(self):
		attribute_eval = list_to_array(self.control_points_list,0,self.upper_index_on_control_points)
		return attribute_eval
	@control_points.setter
	def control_points(self, value):
	# DERIVED argument
		raise AssertionError('Argument control_points is DERIVED. It is computed and can not be set to any value')
	def wr1(self):
		eval_wr1_wr = (((('CONFIG_CONTROL_DESIGN.UNIFORM_CURVE'  ==  TYPEOF(self))  or  ('CONFIG_CONTROL_DESIGN.QUASI_UNIFORM_CURVE'  ==  TYPEOF(self)))  or  ('CONFIG_CONTROL_DESIGN.BEZIER_CURVE'  ==  TYPEOF(self)))  or  ('CONFIG_CONTROL_DESIGN.B_SPLINE_CURVE_WITH_KNOTS'  ==  TYPEOF(self)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY bezier_curve #
####################
class bezier_curve(b_spline_curve):
	'''Entity bezier_curve definition.
	'''
	def __init__( self , inherited0__name , inherited1__degree , inherited2__control_points_list , inherited3__curve_form , inherited4__closed_curve , inherited5__self_intersect ,  ):
		b_spline_curve.__init__(self , inherited0__name , inherited1__degree , inherited2__control_points_list , inherited3__curve_form , inherited4__closed_curve , inherited5__self_intersect , )

####################
 # ENTITY representation_relationship #
####################
class representation_relationship(BaseEntityClass):
	'''Entity representation_relationship definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param rep_1
	:type rep_1:representation

	:param rep_2
	:type rep_2:representation
	'''
	def __init__( self , name,description,rep_1,rep_2, ):
		self._name = name
		self._description = description
		self._rep_1 = rep_1
		self._rep_2 = rep_2

	@property
	def name(self):
		return self._name
	@name.setter
	def name(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,label):
			self._name = label(value)
		else:
			self._name = value

	@property
	def description(self):
		return self._description
	@description.setter
	def description(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,text):
			self._description = text(value)
		else:
			self._description = value

	@property
	def rep_1(self):
		return self._rep_1
	@rep_1.setter
	def rep_1(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,representation):
			self._rep_1 = representation(value)
		else:
			self._rep_1 = value

	@property
	def rep_2(self):
		return self._rep_2
	@rep_2.setter
	def rep_2(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,representation):
			self._rep_2 = representation(value)
		else:
			self._rep_2 = value

####################
 # ENTITY shape_representation_relationship #
####################
class shape_representation_relationship(representation_relationship):
	'''Entity shape_representation_relationship definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__rep_1 , inherited3__rep_2 ,  ):
		representation_relationship.__init__(self , inherited0__name , inherited1__description , inherited2__rep_1 , inherited3__rep_2 , )
	def wr1(self):
		eval_wr1_wr = ('CONFIG_CONTROL_DESIGN.SHAPE_REPRESENTATION'  ==  (TYPEOF(self.self.representation_relationship.self.rep_1)  +  TYPEOF(self.self.representation_relationship.self.rep_2)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY date_and_time #
####################
class date_and_time(BaseEntityClass):
	'''Entity date_and_time definition.

	:param date_component
	:type date_component:date

	:param time_component
	:type time_component:local_time
	'''
	def __init__( self , date_component,time_component, ):
		self._date_component = date_component
		self._time_component = time_component

	@property
	def date_component(self):
		return self._date_component
	@date_component.setter
	def date_component(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,date):
			self._date_component = date(value)
		else:
			self._date_component = value

	@property
	def time_component(self):
		return self._time_component
	@time_component.setter
	def time_component(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,local_time):
			self._time_component = local_time(value)
		else:
			self._time_component = value

####################
 # ENTITY product_definition_formation #
####################
class product_definition_formation(BaseEntityClass):
	'''Entity product_definition_formation definition.

	:param id
	:type id:identifier

	:param description
	:type description:text

	:param of_product
	:type of_product:product
	'''
	def __init__( self , id,description,of_product, ):
		self._id = id
		self._description = description
		self._of_product = of_product

	@property
	def id(self):
		return self._id
	@id.setter
	def id(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,identifier):
			self._id = identifier(value)
		else:
			self._id = value

	@property
	def description(self):
		return self._description
	@description.setter
	def description(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,text):
			self._description = text(value)
		else:
			self._description = value

	@property
	def of_product(self):
		return self._of_product
	@of_product.setter
	def of_product(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,product):
			self._of_product = product(value)
		else:
			self._of_product = value

####################
 # ENTITY product_definition_formation_with_specified_source #
####################
class product_definition_formation_with_specified_source(product_definition_formation):
	'''Entity product_definition_formation_with_specified_source definition.

	:param make_or_buy
	:type make_or_buy:source
	'''
	def __init__( self , inherited0__id , inherited1__description , inherited2__of_product , make_or_buy, ):
		product_definition_formation.__init__(self , inherited0__id , inherited1__description , inherited2__of_product , )
		self._make_or_buy = make_or_buy

	@property
	def make_or_buy(self):
		return self._make_or_buy
	@make_or_buy.setter
	def make_or_buy(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,source):
			self._make_or_buy = source(value)
		else:
			self._make_or_buy = value

####################
 # ENTITY surface #
####################
class surface(geometric_representation_item):
	'''Entity surface definition.
	'''
	def __init__( self , inherited0__name ,  ):
		geometric_representation_item.__init__(self , inherited0__name , )

####################
 # ENTITY surface_replica #
####################
class surface_replica(surface):
	'''Entity surface_replica definition.

	:param parent_surface
	:type parent_surface:surface

	:param transformation
	:type transformation:cartesian_transformation_operator_3d
	'''
	def __init__( self , inherited0__name , parent_surface,transformation, ):
		surface.__init__(self , inherited0__name , )
		self._parent_surface = parent_surface
		self._transformation = transformation

	@property
	def parent_surface(self):
		return self._parent_surface
	@parent_surface.setter
	def parent_surface(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,surface):
			self._parent_surface = surface(value)
		else:
			self._parent_surface = value

	@property
	def transformation(self):
		return self._transformation
	@transformation.setter
	def transformation(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,cartesian_transformation_operator_3d):
			self._transformation = cartesian_transformation_operator_3d(value)
		else:
			self._transformation = value
	def wr1(self):
		eval_wr1_wr = acyclic_surface_replica(self,self.parent_surface)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY document #
####################
class document(BaseEntityClass):
	'''Entity document definition.

	:param id
	:type id:identifier

	:param name
	:type name:label

	:param description
	:type description:text

	:param kind
	:type kind:document_type
	'''
	def __init__( self , id,name,description,kind, ):
		self._id = id
		self._name = name
		self._description = description
		self._kind = kind

	@property
	def id(self):
		return self._id
	@id.setter
	def id(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,identifier):
			self._id = identifier(value)
		else:
			self._id = value

	@property
	def name(self):
		return self._name
	@name.setter
	def name(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,label):
			self._name = label(value)
		else:
			self._name = value

	@property
	def description(self):
		return self._description
	@description.setter
	def description(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,text):
			self._description = text(value)
		else:
			self._description = value

	@property
	def kind(self):
		return self._kind
	@kind.setter
	def kind(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,document_type):
			self._kind = document_type(value)
		else:
			self._kind = value

####################
 # ENTITY document_with_class #
####################
class document_with_class(document):
	'''Entity document_with_class definition.

	:param class_
	:type class_:identifier
	'''
	def __init__( self , inherited0__id , inherited1__name , inherited2__description , inherited3__kind , class_, ):
		document.__init__(self , inherited0__id , inherited1__name , inherited2__description , inherited3__kind , )
		self._class_ = class_

	@property
	def class_(self):
		return self._class_
	@class_.setter
	def class_(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,identifier):
			self._class_ = identifier(value)
		else:
			self._class_ = value

####################
 # ENTITY assembly_component_usage_substitute #
####################
class assembly_component_usage_substitute(BaseEntityClass):
	'''Entity assembly_component_usage_substitute definition.

	:param name
	:type name:label

	:param definition
	:type definition:text

	:param base
	:type base:assembly_component_usage

	:param substitute
	:type substitute:assembly_component_usage
	'''
	def __init__( self , name,definition,base,substitute, ):
		self._name = name
		self._definition = definition
		self._base = base
		self._substitute = substitute

	@property
	def name(self):
		return self._name
	@name.setter
	def name(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,label):
			self._name = label(value)
		else:
			self._name = value

	@property
	def definition(self):
		return self._definition
	@definition.setter
	def definition(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,text):
			self._definition = text(value)
		else:
			self._definition = value

	@property
	def base(self):
		return self._base
	@base.setter
	def base(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,assembly_component_usage):
			self._base = assembly_component_usage(value)
		else:
			self._base = value

	@property
	def substitute(self):
		return self._substitute
	@substitute.setter
	def substitute(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,assembly_component_usage):
			self._substitute = assembly_component_usage(value)
		else:
			self._substitute = value
	def wr1(self):
		eval_wr1_wr = (self.base.self.relating_product_definition  ==  self.substitute.self.relating_product_definition)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (self.base  !=  self.substitute)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY item_defined_transformation #
####################
class item_defined_transformation(BaseEntityClass):
	'''Entity item_defined_transformation definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param transform_item_1
	:type transform_item_1:representation_item

	:param transform_item_2
	:type transform_item_2:representation_item
	'''
	def __init__( self , name,description,transform_item_1,transform_item_2, ):
		self._name = name
		self._description = description
		self._transform_item_1 = transform_item_1
		self._transform_item_2 = transform_item_2

	@property
	def name(self):
		return self._name
	@name.setter
	def name(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,label):
			self._name = label(value)
		else:
			self._name = value

	@property
	def description(self):
		return self._description
	@description.setter
	def description(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,text):
			self._description = text(value)
		else:
			self._description = value

	@property
	def transform_item_1(self):
		return self._transform_item_1
	@transform_item_1.setter
	def transform_item_1(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,representation_item):
			self._transform_item_1 = representation_item(value)
		else:
			self._transform_item_1 = value

	@property
	def transform_item_2(self):
		return self._transform_item_2
	@transform_item_2.setter
	def transform_item_2(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,representation_item):
			self._transform_item_2 = representation_item(value)
		else:
			self._transform_item_2 = value

####################
 # ENTITY solid_model #
####################
class solid_model(geometric_representation_item):
	'''Entity solid_model definition.
	'''
	def __init__( self , inherited0__name ,  ):
		geometric_representation_item.__init__(self , inherited0__name , )

####################
 # ENTITY manifold_solid_brep #
####################
class manifold_solid_brep(solid_model):
	'''Entity manifold_solid_brep definition.

	:param outer
	:type outer:closed_shell
	'''
	def __init__( self , inherited0__name , outer, ):
		solid_model.__init__(self , inherited0__name , )
		self._outer = outer

	@property
	def outer(self):
		return self._outer
	@outer.setter
	def outer(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,closed_shell):
			self._outer = closed_shell(value)
		else:
			self._outer = value

####################
 # ENTITY faceted_brep #
####################
class faceted_brep(manifold_solid_brep):
	'''Entity faceted_brep definition.
	'''
	def __init__( self , inherited0__name , inherited1__outer ,  ):
		manifold_solid_brep.__init__(self , inherited0__name , inherited1__outer , )

####################
 # ENTITY named_unit #
####################
class named_unit(BaseEntityClass):
	'''Entity named_unit definition.

	:param dimensions
	:type dimensions:dimensional_exponents
	'''
	def __init__( self , dimensions, ):
		self._dimensions = dimensions

	@property
	def dimensions(self):
		return self._dimensions
	@dimensions.setter
	def dimensions(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,dimensional_exponents):
			self._dimensions = dimensional_exponents(value)
		else:
			self._dimensions = value

####################
 # ENTITY mass_unit #
####################
class mass_unit(named_unit):
	'''Entity mass_unit definition.
	'''
	def __init__( self , inherited0__dimensions ,  ):
		named_unit.__init__(self , inherited0__dimensions , )
	def wr1(self):
		eval_wr1_wr = (((((((self.self.named_unit.self.dimensions.self.length_exponent  ==  0)  and  (self.self.named_unit.self.dimensions.self.mass_exponent  ==  1))  and  (self.self.named_unit.self.dimensions.self.time_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.electric_current_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.thermodynamic_temperature_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.amount_of_substance_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.luminous_intensity_exponent  ==  0))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY solid_angle_unit #
####################
class solid_angle_unit(named_unit):
	'''Entity solid_angle_unit definition.
	'''
	def __init__( self , inherited0__dimensions ,  ):
		named_unit.__init__(self , inherited0__dimensions , )
	def wr1(self):
		eval_wr1_wr = (((((((self.self.named_unit.self.dimensions.self.length_exponent  ==  0)  and  (self.self.named_unit.self.dimensions.self.mass_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.time_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.electric_current_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.thermodynamic_temperature_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.amount_of_substance_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.luminous_intensity_exponent  ==  0))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY bounded_surface #
####################
class bounded_surface(surface):
	'''Entity bounded_surface definition.
	'''
	def __init__( self , inherited0__name ,  ):
		surface.__init__(self , inherited0__name , )

####################
 # ENTITY rectangular_composite_surface #
####################
class rectangular_composite_surface(bounded_surface):
	'''Entity rectangular_composite_surface definition.

	:param segments
	:type segments:LIST(1,None,LIST(1,None,'surface_patch', scope = schema_scope))

	:param n_u
	:type n_u:INTEGER

	:param n_v
	:type n_v:INTEGER
	'''
	def __init__( self , inherited0__name , segments, ):
		bounded_surface.__init__(self , inherited0__name , )
		self._segments = segments

	@property
	def segments(self):
		return self._segments
	@segments.setter
	def segments(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,LIST(1,None,LIST(1,None,'surface_patch', scope = schema_scope))):
			self._segments = LIST(value)
		else:
			self._segments = value

	@property
	def n_u(self):
		attribute_eval = SIZEOF(self.segments)
		return attribute_eval
	@n_u.setter
	def n_u(self, value):
	# DERIVED argument
		raise AssertionError('Argument n_u is DERIVED. It is computed and can not be set to any value')

	@property
	def n_v(self):
		attribute_eval = SIZEOF(self.segments[1])
		return attribute_eval
	@n_v.setter
	def n_v(self, value):
	# DERIVED argument
		raise AssertionError('Argument n_v is DERIVED. It is computed and can not be set to any value')
	def wr1(self):
		eval_wr1_wr = ([]  ==  None)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = constraints_rectangular_composite_surface(self)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY person_and_organization_role #
####################
class person_and_organization_role(BaseEntityClass):
	'''Entity person_and_organization_role definition.

	:param name
	:type name:label
	'''
	def __init__( self , name, ):
		self._name = name

	@property
	def name(self):
		return self._name
	@name.setter
	def name(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,label):
			self._name = label(value)
		else:
			self._name = value

####################
 # ENTITY elementary_surface #
####################
class elementary_surface(surface):
	'''Entity elementary_surface definition.

	:param position
	:type position:axis2_placement_3d
	'''
	def __init__( self , inherited0__name , position, ):
		surface.__init__(self , inherited0__name , )
		self._position = position

	@property
	def position(self):
		return self._position
	@position.setter
	def position(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,axis2_placement_3d):
			self._position = axis2_placement_3d(value)
		else:
			self._position = value

####################
 # ENTITY toroidal_surface #
####################
class toroidal_surface(elementary_surface):
	'''Entity toroidal_surface definition.

	:param major_radius
	:type major_radius:positive_length_measure

	:param minor_radius
	:type minor_radius:positive_length_measure
	'''
	def __init__( self , inherited0__name , inherited1__position , major_radius,minor_radius, ):
		elementary_surface.__init__(self , inherited0__name , inherited1__position , )
		self._major_radius = major_radius
		self._minor_radius = minor_radius

	def printer(self):
		print '    '+self.stepLine
		print '      '+self.position.stepLine
		self.position.printer()

	@property
	def major_radius(self):
		return self._major_radius
	@major_radius.setter
	def major_radius(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,positive_length_measure):
			self._major_radius = positive_length_measure(value)
		else:
			self._major_radius = value

	@property
	def minor_radius(self):
		return self._minor_radius
	@minor_radius.setter
	def minor_radius(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,positive_length_measure):
			self._minor_radius = positive_length_measure(value)
		else:
			self._minor_radius = value

####################
 # ENTITY action_status #
####################
class action_status(BaseEntityClass):
	'''Entity action_status definition.

	:param status
	:type status:label

	:param assigned_action
	:type assigned_action:executed_action
	'''
	def __init__( self , status,assigned_action, ):
		self._status = status
		self._assigned_action = assigned_action

	@property
	def status(self):
		return self._status
	@status.setter
	def status(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,label):
			self._status = label(value)
		else:
			self._status = value

	@property
	def assigned_action(self):
		return self._assigned_action
	@assigned_action.setter
	def assigned_action(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,executed_action):
			self._assigned_action = executed_action(value)
		else:
			self._assigned_action = value

####################
 # ENTITY approval_role #
####################
class approval_role(BaseEntityClass):
	'''Entity approval_role definition.

	:param role
	:type role:label
	'''
	def __init__( self , role, ):
		self._role = role

	@property
	def role(self):
		return self._role
	@role.setter
	def role(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,label):
			self._role = label(value)
		else:
			self._role = value

####################
 # ENTITY organization_relationship #
####################
class organization_relationship(BaseEntityClass):
	'''Entity organization_relationship definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param relating_organization
	:type relating_organization:organization

	:param related_organization
	:type related_organization:organization
	'''
	def __init__( self , name,description,relating_organization,related_organization, ):
		self._name = name
		self._description = description
		self._relating_organization = relating_organization
		self._related_organization = related_organization

	@property
	def name(self):
		return self._name
	@name.setter
	def name(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,label):
			self._name = label(value)
		else:
			self._name = value

	@property
	def description(self):
		return self._description
	@description.setter
	def description(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,text):
			self._description = text(value)
		else:
			self._description = value

	@property
	def relating_organization(self):
		return self._relating_organization
	@relating_organization.setter
	def relating_organization(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,organization):
			self._relating_organization = organization(value)
		else:
			self._relating_organization = value

	@property
	def related_organization(self):
		return self._related_organization
	@related_organization.setter
	def related_organization(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,organization):
			self._related_organization = organization(value)
		else:
			self._related_organization = value

####################
 # ENTITY composite_curve #
####################
class composite_curve(bounded_curve):
	'''Entity composite_curve definition.

	:param segments
	:type segments:LIST(1,None,'composite_curve_segment', scope = schema_scope)

	:param self_intersect
	:type self_intersect:LOGICAL

	:param n_segments
	:type n_segments:INTEGER

	:param closed_curve
	:type closed_curve:LOGICAL
	'''
	def __init__( self , inherited0__name , segments,self_intersect, ):
		bounded_curve.__init__(self , inherited0__name , )
		self._segments = segments
		self._self_intersect = self_intersect

	@property
	def segments(self):
		return self._segments
	@segments.setter
	def segments(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,LIST(1,None,'composite_curve_segment', scope = schema_scope)):
			self._segments = LIST(value)
		else:
			self._segments = value

	@property
	def self_intersect(self):
		return self._self_intersect
	@self_intersect.setter
	def self_intersect(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,LOGICAL):
			self._self_intersect = LOGICAL(value)
		else:
			self._self_intersect = value

	@property
	def n_segments(self):
		attribute_eval = SIZEOF(self.segments)
		return attribute_eval
	@n_segments.setter
	def n_segments(self, value):
	# DERIVED argument
		raise AssertionError('Argument n_segments is DERIVED. It is computed and can not be set to any value')

	@property
	def closed_curve(self):
		attribute_eval = (self.segments[self.n_segments].self.transition  !=  discontinuous)
		return attribute_eval
	@closed_curve.setter
	def closed_curve(self, value):
	# DERIVED argument
		raise AssertionError('Argument closed_curve is DERIVED. It is computed and can not be set to any value')
	def wr1(self):
		eval_wr1_wr = ((( not self.closed_curve)  and  (SIZEOF(None)  ==  1))  or  (self.closed_curve  and  (SIZEOF(None)  ==  0)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY b_spline_curve_with_knots #
####################
class b_spline_curve_with_knots(b_spline_curve):
	'''Entity b_spline_curve_with_knots definition.

	:param knot_multiplicities
	:type knot_multiplicities:LIST(2,None,'INTEGER', scope = schema_scope)

	:param knots
	:type knots:LIST(2,None,'REAL', scope = schema_scope)

	:param knot_spec
	:type knot_spec:knot_type

	:param upper_index_on_knots
	:type upper_index_on_knots:INTEGER
	'''
	def __init__( self , inherited0__name , inherited1__degree , inherited2__control_points_list , inherited3__curve_form , inherited4__closed_curve , inherited5__self_intersect , knot_multiplicities,knots,knot_spec, ):
		b_spline_curve.__init__(self , inherited0__name , inherited1__degree , inherited2__control_points_list , inherited3__curve_form , inherited4__closed_curve , inherited5__self_intersect , )
		self._knot_multiplicities = knot_multiplicities
		self._knots = knots
		self._knot_spec = knot_spec

	def printer(self):
		print self.stepLine

	@property
	def knot_multiplicities(self):
		return self._knot_multiplicities
	@knot_multiplicities.setter
	def knot_multiplicities(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,LIST(2,None,'INTEGER', scope = schema_scope)):
			self._knot_multiplicities = LIST(value)
		else:
			self._knot_multiplicities = value

	@property
	def knots(self):
		return self._knots
	@knots.setter
	def knots(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,LIST(2,None,'REAL', scope = schema_scope)):
			self._knots = LIST(value)
		else:
			self._knots = value

	@property
	def knot_spec(self):
		return self._knot_spec
	@knot_spec.setter
	def knot_spec(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,knot_type):
			self._knot_spec = knot_type(value)
		else:
			self._knot_spec = value

	@property
	def upper_index_on_knots(self):
		attribute_eval = SIZEOF(self.knots)
		return attribute_eval
	@upper_index_on_knots.setter
	def upper_index_on_knots(self, value):
	# DERIVED argument
		raise AssertionError('Argument upper_index_on_knots is DERIVED. It is computed and can not be set to any value')
	def wr1(self):
		eval_wr1_wr = constraints_param_b_spline(self.degree,self.upper_index_on_knots,self.upper_index_on_control_points,self.knot_multiplicities,self.knots)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(self.knot_multiplicities)  ==  self.upper_index_on_knots)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY representation_context #
####################
class representation_context(BaseEntityClass):
	'''Entity representation_context definition.

	:param context_identifier
	:type context_identifier:identifier

	:param context_type
	:type context_type:text

	:param representations_in_context
	:type representations_in_context:SET(1,None,'representation', scope = schema_scope)
	'''
	def __init__( self , context_identifier,context_type, ):
		self._context_identifier = context_identifier
		self._context_type = context_type

	@property
	def context_identifier(self):
		return self._context_identifier
	@context_identifier.setter
	def context_identifier(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,identifier):
			self._context_identifier = identifier(value)
		else:
			self._context_identifier = value

	@property
	def context_type(self):
		return self._context_type
	@context_type.setter
	def context_type(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,text):
			self._context_type = text(value)
		else:
			self._context_type = value

	@property
	def representations_in_context(self):
		return self._representations_in_context
	@representations_in_context.setter
	def representations_in_context(self, value):
	# INVERSE argument
		raise AssertionError('Argument representations_in_context is INVERSE. It is computed and can not be set to any value')

####################
 # ENTITY global_unit_assigned_context #
####################
class global_unit_assigned_context(representation_context):
	'''Entity global_unit_assigned_context definition.

	:param units
	:type units:SET(1,None,'unit', scope = schema_scope)
	'''
	def __init__( self , inherited0__context_identifier , inherited1__context_type , units, ):
		representation_context.__init__(self , inherited0__context_identifier , inherited1__context_type , )
		self._units = units

	@property
	def units(self):
		return self._units
	@units.setter
	def units(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(1,None,'unit', scope = schema_scope)):
			self._units = SET(value)
		else:
			self._units = value

####################
 # ENTITY address #
####################
class address(BaseEntityClass):
	'''Entity address definition.

	:param internal_location
	:type internal_location:label

	:param street_number
	:type street_number:label

	:param street
	:type street:label

	:param postal_box
	:type postal_box:label

	:param town
	:type town:label

	:param region
	:type region:label

	:param postal_code
	:type postal_code:label

	:param country
	:type country:label

	:param facsimile_number
	:type facsimile_number:label

	:param telephone_number
	:type telephone_number:label

	:param electronic_mail_address
	:type electronic_mail_address:label

	:param telex_number
	:type telex_number:label
	'''
	def __init__( self , internal_location,street_number,street,postal_box,town,region,postal_code,country,facsimile_number,telephone_number,electronic_mail_address,telex_number, ):
		self._internal_location = internal_location
		self._street_number = street_number
		self._street = street
		self._postal_box = postal_box
		self._town = town
		self._region = region
		self._postal_code = postal_code
		self._country = country
		self._facsimile_number = facsimile_number
		self._telephone_number = telephone_number
		self._electronic_mail_address = electronic_mail_address
		self._telex_number = telex_number

	@property
	def internal_location(self):
		return self._internal_location
	@internal_location.setter
	def internal_location(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,label):
				self._internal_location = label(value)
			else:
				self._internal_location = value
		else:
			self._internal_location = value

	@property
	def street_number(self):
		return self._street_number
	@street_number.setter
	def street_number(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,label):
				self._street_number = label(value)
			else:
				self._street_number = value
		else:
			self._street_number = value

	@property
	def street(self):
		return self._street
	@street.setter
	def street(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,label):
				self._street = label(value)
			else:
				self._street = value
		else:
			self._street = value

	@property
	def postal_box(self):
		return self._postal_box
	@postal_box.setter
	def postal_box(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,label):
				self._postal_box = label(value)
			else:
				self._postal_box = value
		else:
			self._postal_box = value

	@property
	def town(self):
		return self._town
	@town.setter
	def town(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,label):
				self._town = label(value)
			else:
				self._town = value
		else:
			self._town = value

	@property
	def region(self):
		return self._region
	@region.setter
	def region(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,label):
				self._region = label(value)
			else:
				self._region = value
		else:
			self._region = value

	@property
	def postal_code(self):
		return self._postal_code
	@postal_code.setter
	def postal_code(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,label):
				self._postal_code = label(value)
			else:
				self._postal_code = value
		else:
			self._postal_code = value

	@property
	def country(self):
		return self._country
	@country.setter
	def country(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,label):
				self._country = label(value)
			else:
				self._country = value
		else:
			self._country = value

	@property
	def facsimile_number(self):
		return self._facsimile_number
	@facsimile_number.setter
	def facsimile_number(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,label):
				self._facsimile_number = label(value)
			else:
				self._facsimile_number = value
		else:
			self._facsimile_number = value

	@property
	def telephone_number(self):
		return self._telephone_number
	@telephone_number.setter
	def telephone_number(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,label):
				self._telephone_number = label(value)
			else:
				self._telephone_number = value
		else:
			self._telephone_number = value

	@property
	def electronic_mail_address(self):
		return self._electronic_mail_address
	@electronic_mail_address.setter
	def electronic_mail_address(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,label):
				self._electronic_mail_address = label(value)
			else:
				self._electronic_mail_address = value
		else:
			self._electronic_mail_address = value

	@property
	def telex_number(self):
		return self._telex_number
	@telex_number.setter
	def telex_number(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,label):
				self._telex_number = label(value)
			else:
				self._telex_number = value
		else:
			self._telex_number = value
	def wr1(self):
		eval_wr1_wr = (((((((((((EXISTS(self.internal_location)  or  EXISTS(self.street_number))  or  EXISTS(self.street))  or  EXISTS(self.postal_box))  or  EXISTS(self.town))  or  EXISTS(self.region))  or  EXISTS(self.postal_code))  or  EXISTS(self.country))  or  EXISTS(self.facsimile_number))  or  EXISTS(self.telephone_number))  or  EXISTS(self.electronic_mail_address))  or  EXISTS(self.telex_number))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY organizational_address #
####################
class organizational_address(address):
	'''Entity organizational_address definition.

	:param organizations
	:type organizations:SET(1,None,'organization', scope = schema_scope)

	:param description
	:type description:text
	'''
	def __init__( self , inherited0__internal_location , inherited1__street_number , inherited2__street , inherited3__postal_box , inherited4__town , inherited5__region , inherited6__postal_code , inherited7__country , inherited8__facsimile_number , inherited9__telephone_number , inherited10__electronic_mail_address , inherited11__telex_number , organizations,description, ):
		address.__init__(self , inherited0__internal_location , inherited1__street_number , inherited2__street , inherited3__postal_box , inherited4__town , inherited5__region , inherited6__postal_code , inherited7__country , inherited8__facsimile_number , inherited9__telephone_number , inherited10__electronic_mail_address , inherited11__telex_number , )
		self._organizations = organizations
		self._description = description

	@property
	def organizations(self):
		return self._organizations
	@organizations.setter
	def organizations(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(1,None,'organization', scope = schema_scope)):
			self._organizations = SET(value)
		else:
			self._organizations = value

	@property
	def description(self):
		return self._description
	@description.setter
	def description(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,text):
			self._description = text(value)
		else:
			self._description = value

####################
 # ENTITY personal_address #
####################
class personal_address(address):
	'''Entity personal_address definition.

	:param people
	:type people:SET(1,None,'person', scope = schema_scope)

	:param description
	:type description:text
	'''
	def __init__( self , inherited0__internal_location , inherited1__street_number , inherited2__street , inherited3__postal_box , inherited4__town , inherited5__region , inherited6__postal_code , inherited7__country , inherited8__facsimile_number , inherited9__telephone_number , inherited10__electronic_mail_address , inherited11__telex_number , people,description, ):
		address.__init__(self , inherited0__internal_location , inherited1__street_number , inherited2__street , inherited3__postal_box , inherited4__town , inherited5__region , inherited6__postal_code , inherited7__country , inherited8__facsimile_number , inherited9__telephone_number , inherited10__electronic_mail_address , inherited11__telex_number , )
		self._people = people
		self._description = description

	@property
	def people(self):
		return self._people
	@people.setter
	def people(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(1,None,'person', scope = schema_scope)):
			self._people = SET(value)
		else:
			self._people = value

	@property
	def description(self):
		return self._description
	@description.setter
	def description(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,text):
			self._description = text(value)
		else:
			self._description = value

####################
 # ENTITY shape_aspect_relationship #
####################
class shape_aspect_relationship(BaseEntityClass):
	'''Entity shape_aspect_relationship definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param relating_shape_aspect
	:type relating_shape_aspect:shape_aspect

	:param related_shape_aspect
	:type related_shape_aspect:shape_aspect
	'''
	def __init__( self , name,description,relating_shape_aspect,related_shape_aspect, ):
		self._name = name
		self._description = description
		self._relating_shape_aspect = relating_shape_aspect
		self._related_shape_aspect = related_shape_aspect

	@property
	def name(self):
		return self._name
	@name.setter
	def name(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,label):
			self._name = label(value)
		else:
			self._name = value

	@property
	def description(self):
		return self._description
	@description.setter
	def description(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,text):
			self._description = text(value)
		else:
			self._description = value

	@property
	def relating_shape_aspect(self):
		return self._relating_shape_aspect
	@relating_shape_aspect.setter
	def relating_shape_aspect(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,shape_aspect):
			self._relating_shape_aspect = shape_aspect(value)
		else:
			self._relating_shape_aspect = value

	@property
	def related_shape_aspect(self):
		return self._related_shape_aspect
	@related_shape_aspect.setter
	def related_shape_aspect(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,shape_aspect):
			self._related_shape_aspect = shape_aspect(value)
		else:
			self._related_shape_aspect = value

####################
 # ENTITY advanced_brep_shape_representation #
####################
class advanced_brep_shape_representation(shape_representation):
	'''Entity advanced_brep_shape_representation definition.
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items ,  ):
		shape_representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  >  0)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  0)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(None)  ==  0)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = (SIZEOF(None)  ==  0)
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr

	def wr6(self):
		eval_wr6_wr = (SIZEOF(None)  ==  0)
		if not eval_wr6_wr:
			raise AssertionError('Rule wr6 violated')
		else:
			return eval_wr6_wr


####################
 # ENTITY topological_representation_item #
####################
class topological_representation_item(representation_item):
	'''Entity topological_representation_item definition.
	'''
	def __init__( self , inherited0__name ,  ):
		representation_item.__init__(self , inherited0__name , )

####################
 # ENTITY face #
####################
class face(topological_representation_item):
	'''Entity face definition.

	:param bounds
	:type bounds:SET(1,None,'face_bound', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , bounds, ):
		topological_representation_item.__init__(self , inherited0__name , )
		self._bounds = bounds

	@property
	def bounds(self):
		return self._bounds
	@bounds.setter
	def bounds(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(1,None,'face_bound', scope = schema_scope)):
			self._bounds = SET(value)
		else:
			self._bounds = value
	def wr1(self):
		eval_wr1_wr = ( not mixed_loop_type_set(list_to_set(list_face_loops(self))))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  <=  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY face_surface #
####################
class face_surface(face,geometric_representation_item):
	'''Entity face_surface definition.

	:param face_geometry
	:type face_geometry:surface

	:param same_sense
	:type same_sense:BOOLEAN
	'''
	def __init__( self , inherited0__name , inherited1__bounds , inherited2__name , face_geometry,same_sense, ):
		face.__init__(self , inherited0__name , inherited1__bounds , )
		geometric_representation_item.__init__(self , inherited2__name , )
		self._face_geometry = face_geometry
		self._same_sense = same_sense

	@property
	def face_geometry(self):
		return self._face_geometry
	@face_geometry.setter
	def face_geometry(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,surface):
			self._face_geometry = surface(value)
		else:
			self._face_geometry = value

	@property
	def same_sense(self):
		return self._same_sense
	@same_sense.setter
	def same_sense(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,BOOLEAN):
			self._same_sense = BOOLEAN(value)
		else:
			self._same_sense = value

####################
 # ENTITY property_definition_representation #
####################
class property_definition_representation(BaseEntityClass):
	'''Entity property_definition_representation definition.

	:param definition
	:type definition:property_definition

	:param used_representation
	:type used_representation:representation
	'''
	def __init__( self , definition,used_representation, ):
		self._definition = definition
		self._used_representation = used_representation

	@property
	def definition(self):
		return self._definition
	@definition.setter
	def definition(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,property_definition):
			self._definition = property_definition(value)
		else:
			self._definition = value

	@property
	def used_representation(self):
		return self._used_representation
	@used_representation.setter
	def used_representation(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,representation):
			self._used_representation = representation(value)
		else:
			self._used_representation = value

####################
 # ENTITY security_classification_level #
####################
class security_classification_level(BaseEntityClass):
	'''Entity security_classification_level definition.

	:param name
	:type name:label
	'''
	def __init__( self , name, ):
		self._name = name

	@property
	def name(self):
		return self._name
	@name.setter
	def name(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,label):
			self._name = label(value)
		else:
			self._name = value

####################
 # ENTITY b_spline_surface #
####################
class b_spline_surface(bounded_surface):
	'''Entity b_spline_surface definition.

	:param u_degree
	:type u_degree:INTEGER

	:param v_degree
	:type v_degree:INTEGER

	:param control_points_list
	:type control_points_list:LIST(2,None,LIST(2,None,'cartesian_point', scope = schema_scope))

	:param surface_form
	:type surface_form:b_spline_surface_form

	:param u_closed
	:type u_closed:LOGICAL

	:param v_closed
	:type v_closed:LOGICAL

	:param self_intersect
	:type self_intersect:LOGICAL

	:param u_upper
	:type u_upper:INTEGER

	:param v_upper
	:type v_upper:INTEGER

	:param control_points
	:type control_points:ARRAY(0,u_upper,ARRAY(0,v_upper,'cartesian_point', scope = schema_scope))
	'''
	def __init__( self , inherited0__name , u_degree,v_degree,control_points_list,surface_form,u_closed,v_closed,self_intersect, ):
		bounded_surface.__init__(self , inherited0__name , )
		self._u_degree = u_degree
		self._v_degree = v_degree
		self._control_points_list = control_points_list
		self._surface_form = surface_form
		self._u_closed = u_closed
		self._v_closed = v_closed
		self._self_intersect = self_intersect

	@property
	def u_degree(self):
		return self._u_degree
	@u_degree.setter
	def u_degree(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,INTEGER):
			self._u_degree = INTEGER(value)
		else:
			self._u_degree = value

	@property
	def v_degree(self):
		return self._v_degree
	@v_degree.setter
	def v_degree(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,INTEGER):
			self._v_degree = INTEGER(value)
		else:
			self._v_degree = value

	@property
	def control_points_list(self):
		return self._control_points_list
	@control_points_list.setter
	def control_points_list(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,LIST(2,None,LIST(2,None,'cartesian_point', scope = schema_scope))):
			self._control_points_list = LIST(value)
		else:
			self._control_points_list = value

	@property
	def surface_form(self):
		return self._surface_form
	@surface_form.setter
	def surface_form(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,b_spline_surface_form):
			self._surface_form = b_spline_surface_form(value)
		else:
			self._surface_form = value

	@property
	def u_closed(self):
		return self._u_closed
	@u_closed.setter
	def u_closed(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,LOGICAL):
			self._u_closed = LOGICAL(value)
		else:
			self._u_closed = value

	@property
	def v_closed(self):
		return self._v_closed
	@v_closed.setter
	def v_closed(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,LOGICAL):
			self._v_closed = LOGICAL(value)
		else:
			self._v_closed = value

	@property
	def self_intersect(self):
		return self._self_intersect
	@self_intersect.setter
	def self_intersect(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,LOGICAL):
			self._self_intersect = LOGICAL(value)
		else:
			self._self_intersect = value

	@property
	def u_upper(self):
		attribute_eval = (SIZEOF(self.control_points_list) - 1)
		return attribute_eval
	@u_upper.setter
	def u_upper(self, value):
	# DERIVED argument
		raise AssertionError('Argument u_upper is DERIVED. It is computed and can not be set to any value')

	@property
	def v_upper(self):
		attribute_eval = (SIZEOF(self.control_points_list[1]) - 1)
		return attribute_eval
	@v_upper.setter
	def v_upper(self, value):
	# DERIVED argument
		raise AssertionError('Argument v_upper is DERIVED. It is computed and can not be set to any value')

	@property
	def control_points(self):
		attribute_eval = make_array_of_array(self.control_points_list,0,self.u_upper,0,self.v_upper)
		return attribute_eval
	@control_points.setter
	def control_points(self, value):
	# DERIVED argument
		raise AssertionError('Argument control_points is DERIVED. It is computed and can not be set to any value')
	def wr1(self):
		eval_wr1_wr = (((('CONFIG_CONTROL_DESIGN.UNIFORM_SURFACE'  ==  TYPEOF(self))  or  ('CONFIG_CONTROL_DESIGN.QUASI_UNIFORM_SURFACE'  ==  TYPEOF(self)))  or  ('CONFIG_CONTROL_DESIGN.BEZIER_SURFACE'  ==  TYPEOF(self)))  or  ('CONFIG_CONTROL_DESIGN.B_SPLINE_SURFACE_WITH_KNOTS'  ==  TYPEOF(self)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY b_spline_surface_with_knots #
####################
class b_spline_surface_with_knots(b_spline_surface):
	'''Entity b_spline_surface_with_knots definition.

	:param u_multiplicities
	:type u_multiplicities:LIST(2,None,'INTEGER', scope = schema_scope)

	:param v_multiplicities
	:type v_multiplicities:LIST(2,None,'INTEGER', scope = schema_scope)

	:param u_knots
	:type u_knots:LIST(2,None,'REAL', scope = schema_scope)

	:param v_knots
	:type v_knots:LIST(2,None,'REAL', scope = schema_scope)

	:param knot_spec
	:type knot_spec:knot_type

	:param knot_u_upper
	:type knot_u_upper:INTEGER

	:param knot_v_upper
	:type knot_v_upper:INTEGER
	'''
	def __init__( self , inherited0__name , inherited1__u_degree , inherited2__v_degree , inherited3__control_points_list , inherited4__surface_form , inherited5__u_closed , inherited6__v_closed , inherited7__self_intersect , u_multiplicities,v_multiplicities,u_knots,v_knots,knot_spec, ):
		b_spline_surface.__init__(self , inherited0__name , inherited1__u_degree , inherited2__v_degree , inherited3__control_points_list , inherited4__surface_form , inherited5__u_closed , inherited6__v_closed , inherited7__self_intersect , )
		self._u_multiplicities = u_multiplicities
		self._v_multiplicities = v_multiplicities
		self._u_knots = u_knots
		self._v_knots = v_knots
		self._knot_spec = knot_spec

	@property
	def u_multiplicities(self):
		return self._u_multiplicities
	@u_multiplicities.setter
	def u_multiplicities(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,LIST(2,None,'INTEGER', scope = schema_scope)):
			self._u_multiplicities = LIST(value)
		else:
			self._u_multiplicities = value

	@property
	def v_multiplicities(self):
		return self._v_multiplicities
	@v_multiplicities.setter
	def v_multiplicities(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,LIST(2,None,'INTEGER', scope = schema_scope)):
			self._v_multiplicities = LIST(value)
		else:
			self._v_multiplicities = value

	@property
	def u_knots(self):
		return self._u_knots
	@u_knots.setter
	def u_knots(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,LIST(2,None,'REAL', scope = schema_scope)):
			self._u_knots = LIST(value)
		else:
			self._u_knots = value

	@property
	def v_knots(self):
		return self._v_knots
	@v_knots.setter
	def v_knots(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,LIST(2,None,'REAL', scope = schema_scope)):
			self._v_knots = LIST(value)
		else:
			self._v_knots = value

	@property
	def knot_spec(self):
		return self._knot_spec
	@knot_spec.setter
	def knot_spec(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,knot_type):
			self._knot_spec = knot_type(value)
		else:
			self._knot_spec = value

	@property
	def knot_u_upper(self):
		attribute_eval = SIZEOF(self.u_knots)
		return attribute_eval
	@knot_u_upper.setter
	def knot_u_upper(self, value):
	# DERIVED argument
		raise AssertionError('Argument knot_u_upper is DERIVED. It is computed and can not be set to any value')

	@property
	def knot_v_upper(self):
		attribute_eval = SIZEOF(self.v_knots)
		return attribute_eval
	@knot_v_upper.setter
	def knot_v_upper(self, value):
	# DERIVED argument
		raise AssertionError('Argument knot_v_upper is DERIVED. It is computed and can not be set to any value')
	def wr1(self):
		eval_wr1_wr = constraints_param_b_spline(self.self.b_spline_surface.self.u_degree,self.knot_u_upper,self.self.b_spline_surface.self.u_upper,self.u_multiplicities,self.u_knots)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = constraints_param_b_spline(self.self.b_spline_surface.self.v_degree,self.knot_v_upper,self.self.b_spline_surface.self.v_upper,self.v_multiplicities,self.v_knots)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(self.u_multiplicities)  ==  self.knot_u_upper)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(self.v_multiplicities)  ==  self.knot_v_upper)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr


####################
 # ENTITY composite_curve_on_surface #
####################
class composite_curve_on_surface(composite_curve):
	'''Entity composite_curve_on_surface definition.

	:param basis_surface
	:type basis_surface:SET(0,2,'surface', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__segments , inherited2__self_intersect ,  ):
		composite_curve.__init__(self , inherited0__name , inherited1__segments , inherited2__self_intersect , )

	@property
	def basis_surface(self):
		attribute_eval = get_basis_surface(self)
		return attribute_eval
	@basis_surface.setter
	def basis_surface(self, value):
	# DERIVED argument
		raise AssertionError('Argument basis_surface is DERIVED. It is computed and can not be set to any value')
	def wr1(self):
		eval_wr1_wr = (SIZEOF(self.basis_surface)  >  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = constraints_composite_curve_on_surface(self)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY boundary_curve #
####################
class boundary_curve(composite_curve_on_surface):
	'''Entity boundary_curve definition.
	'''
	def __init__( self , inherited0__name , inherited1__segments , inherited2__self_intersect ,  ):
		composite_curve_on_surface.__init__(self , inherited0__name , inherited1__segments , inherited2__self_intersect , )
	def wr1(self):
		eval_wr1_wr = self.self.composite_curve.self.closed_curve
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY outer_boundary_curve #
####################
class outer_boundary_curve(boundary_curve):
	'''Entity outer_boundary_curve definition.
	'''
	def __init__( self , inherited0__name , inherited1__segments , inherited2__self_intersect ,  ):
		boundary_curve.__init__(self , inherited0__name , inherited1__segments , inherited2__self_intersect , )

####################
 # ENTITY parametric_representation_context #
####################
class parametric_representation_context(representation_context):
	'''Entity parametric_representation_context definition.
	'''
	def __init__( self , inherited0__context_identifier , inherited1__context_type ,  ):
		representation_context.__init__(self , inherited0__context_identifier , inherited1__context_type , )

####################
 # ENTITY surface_patch #
####################
class surface_patch(founded_item):
	'''Entity surface_patch definition.

	:param parent_surface
	:type parent_surface:bounded_surface

	:param u_transition
	:type u_transition:transition_code

	:param v_transition
	:type v_transition:transition_code

	:param u_sense
	:type u_sense:BOOLEAN

	:param v_sense
	:type v_sense:BOOLEAN

	:param using_surfaces
	:type using_surfaces:BAG(1,None,'rectangular_composite_surface', scope = schema_scope)
	'''
	def __init__( self , parent_surface,u_transition,v_transition,u_sense,v_sense, ):
		founded_item.__init__(self , )
		self._parent_surface = parent_surface
		self._u_transition = u_transition
		self._v_transition = v_transition
		self._u_sense = u_sense
		self._v_sense = v_sense

	@property
	def parent_surface(self):
		return self._parent_surface
	@parent_surface.setter
	def parent_surface(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,bounded_surface):
			self._parent_surface = bounded_surface(value)
		else:
			self._parent_surface = value

	@property
	def u_transition(self):
		return self._u_transition
	@u_transition.setter
	def u_transition(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,transition_code):
			self._u_transition = transition_code(value)
		else:
			self._u_transition = value

	@property
	def v_transition(self):
		return self._v_transition
	@v_transition.setter
	def v_transition(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,transition_code):
			self._v_transition = transition_code(value)
		else:
			self._v_transition = value

	@property
	def u_sense(self):
		return self._u_sense
	@u_sense.setter
	def u_sense(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,BOOLEAN):
			self._u_sense = BOOLEAN(value)
		else:
			self._u_sense = value

	@property
	def v_sense(self):
		return self._v_sense
	@v_sense.setter
	def v_sense(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,BOOLEAN):
			self._v_sense = BOOLEAN(value)
		else:
			self._v_sense = value

	@property
	def using_surfaces(self):
		return self._using_surfaces
	@using_surfaces.setter
	def using_surfaces(self, value):
	# INVERSE argument
		raise AssertionError('Argument using_surfaces is INVERSE. It is computed and can not be set to any value')
	def wr1(self):
		eval_wr1_wr = ( not ('CONFIG_CONTROL_DESIGN.CURVE_BOUNDED_SURFACE'  ==  TYPEOF(self.parent_surface)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY action_request_status #
####################
class action_request_status(BaseEntityClass):
	'''Entity action_request_status definition.

	:param status
	:type status:label

	:param assigned_request
	:type assigned_request:versioned_action_request
	'''
	def __init__( self , status,assigned_request, ):
		self._status = status
		self._assigned_request = assigned_request

	@property
	def status(self):
		return self._status
	@status.setter
	def status(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,label):
			self._status = label(value)
		else:
			self._status = value

	@property
	def assigned_request(self):
		return self._assigned_request
	@assigned_request.setter
	def assigned_request(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,versioned_action_request):
			self._assigned_request = versioned_action_request(value)
		else:
			self._assigned_request = value

####################
 # ENTITY measure_with_unit #
####################
class measure_with_unit(BaseEntityClass):
	'''Entity measure_with_unit definition.

	:param value_component
	:type value_component:measure_value

	:param unit_component
	:type unit_component:unit
	'''
	def __init__( self , value_component,unit_component, ):
		self._value_component = value_component
		self._unit_component = unit_component

	@property
	def value_component(self):
		return self._value_component
	@value_component.setter
	def value_component(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,measure_value):
			self._value_component = measure_value(value)
		else:
			self._value_component = value

	@property
	def unit_component(self):
		return self._unit_component
	@unit_component.setter
	def unit_component(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,unit):
			self._unit_component = unit(value)
		else:
			self._unit_component = value
	def wr1(self):
		eval_wr1_wr = valid_units(self)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY area_measure_with_unit #
####################
class area_measure_with_unit(measure_with_unit):
	'''Entity area_measure_with_unit definition.
	'''
	def __init__( self , inherited0__value_component , inherited1__unit_component ,  ):
		measure_with_unit.__init__(self , inherited0__value_component , inherited1__unit_component , )
	def wr1(self):
		eval_wr1_wr = ('CONFIG_CONTROL_DESIGN.AREA_UNIT'  ==  TYPEOF(self.self.measure_with_unit.self.unit_component))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY person #
####################
class person(BaseEntityClass):
	'''Entity person definition.

	:param id
	:type id:identifier

	:param last_name
	:type last_name:label

	:param first_name
	:type first_name:label

	:param middle_names
	:type middle_names:LIST(1,None,'STRING', scope = schema_scope)

	:param prefix_titles
	:type prefix_titles:LIST(1,None,'STRING', scope = schema_scope)

	:param suffix_titles
	:type suffix_titles:LIST(1,None,'STRING', scope = schema_scope)
	'''
	def __init__( self , id,last_name,first_name,middle_names,prefix_titles,suffix_titles, ):
		self._id = id
		self._last_name = last_name
		self._first_name = first_name
		self._middle_names = middle_names
		self._prefix_titles = prefix_titles
		self._suffix_titles = suffix_titles

	@property
	def id(self):
		return self._id
	@id.setter
	def id(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,identifier):
			self._id = identifier(value)
		else:
			self._id = value

	@property
	def last_name(self):
		return self._last_name
	@last_name.setter
	def last_name(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,label):
				self._last_name = label(value)
			else:
				self._last_name = value
		else:
			self._last_name = value

	@property
	def first_name(self):
		return self._first_name
	@first_name.setter
	def first_name(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,label):
				self._first_name = label(value)
			else:
				self._first_name = value
		else:
			self._first_name = value

	@property
	def middle_names(self):
		return self._middle_names
	@middle_names.setter
	def middle_names(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,LIST(1,None,'STRING', scope = schema_scope)):
				self._middle_names = LIST(value)
			else:
				self._middle_names = value
		else:
			self._middle_names = value

	@property
	def prefix_titles(self):
		return self._prefix_titles
	@prefix_titles.setter
	def prefix_titles(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,LIST(1,None,'STRING', scope = schema_scope)):
				self._prefix_titles = LIST(value)
			else:
				self._prefix_titles = value
		else:
			self._prefix_titles = value

	@property
	def suffix_titles(self):
		return self._suffix_titles
	@suffix_titles.setter
	def suffix_titles(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,LIST(1,None,'STRING', scope = schema_scope)):
				self._suffix_titles = LIST(value)
			else:
				self._suffix_titles = value
		else:
			self._suffix_titles = value
	def wr1(self):
		eval_wr1_wr = (EXISTS(self.last_name)  or  EXISTS(self.first_name))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY quasi_uniform_surface #
####################
class quasi_uniform_surface(b_spline_surface):
	'''Entity quasi_uniform_surface definition.
	'''
	def __init__( self , inherited0__name , inherited1__u_degree , inherited2__v_degree , inherited3__control_points_list , inherited4__surface_form , inherited5__u_closed , inherited6__v_closed , inherited7__self_intersect ,  ):
		b_spline_surface.__init__(self , inherited0__name , inherited1__u_degree , inherited2__v_degree , inherited3__control_points_list , inherited4__surface_form , inherited5__u_closed , inherited6__v_closed , inherited7__self_intersect , )

####################
 # ENTITY edge #
####################
class edge(topological_representation_item):
	'''Entity edge definition.

	:param edge_start
	:type edge_start:vertex

	:param edge_end
	:type edge_end:vertex
	'''
	def __init__( self , inherited0__name , edge_start,edge_end, ):
		topological_representation_item.__init__(self , inherited0__name , )
		self._edge_start = edge_start
		self._edge_end = edge_end

	@property
	def edge_start(self):
		return self._edge_start
	@edge_start.setter
	def edge_start(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,vertex):
			self._edge_start = vertex(value)
		else:
			self._edge_start = value

	@property
	def edge_end(self):
		return self._edge_end
	@edge_end.setter
	def edge_end(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,vertex):
			self._edge_end = vertex(value)
		else:
			self._edge_end = value

####################
 # ENTITY oriented_edge #
####################
class oriented_edge(edge):
	'''Entity oriented_edge definition.

	:param edge_element
	:type edge_element:edge

	:param orientation
	:type orientation:BOOLEAN

	:param edge_edge_start
	:type edge_edge_start:vertex

	:param edge_edge_end
	:type edge_edge_end:vertex
	'''
	def __init__( self , inherited0__name , inherited1__edge_start , inherited2__edge_end , edge_element,orientation, ):
		edge.__init__(self , inherited0__name , inherited1__edge_start , inherited2__edge_end , )
		self._edge_element = edge_element
		self._orientation = orientation

	@property
	def edge_element(self):
		return self._edge_element
	@edge_element.setter
	def edge_element(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,edge):
			self._edge_element = edge(value)
		else:
			self._edge_element = value

	@property
	def orientation(self):
		return self._orientation
	@orientation.setter
	def orientation(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,BOOLEAN):
			self._orientation = BOOLEAN(value)
		else:
			self._orientation = value

	@property
	def edge_edge_start(self):
		attribute_eval = boolean_choose(self.self.orientation,self.self.edge_element.self.edge_start,self.self.edge_element.self.edge_end)
		return attribute_eval
	@edge_edge_start.setter
	def edge_edge_start(self, value):
	# DERIVED argument
		raise AssertionError('Argument edge_edge_start is DERIVED. It is computed and can not be set to any value')

	@property
	def edge_edge_end(self):
		attribute_eval = boolean_choose(self.self.orientation,self.self.edge_element.self.edge_end,self.self.edge_element.self.edge_start)
		return attribute_eval
	@edge_edge_end.setter
	def edge_edge_end(self, value):
	# DERIVED argument
		raise AssertionError('Argument edge_edge_end is DERIVED. It is computed and can not be set to any value')
	def wr1(self):
		eval_wr1_wr = ( not ('CONFIG_CONTROL_DESIGN.ORIENTED_EDGE'  ==  TYPEOF(self.self.edge_element)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY functionally_defined_transformation #
####################
class functionally_defined_transformation(BaseEntityClass):
	'''Entity functionally_defined_transformation definition.

	:param name
	:type name:label

	:param description
	:type description:text
	'''
	def __init__( self , name,description, ):
		self._name = name
		self._description = description

	@property
	def name(self):
		return self._name
	@name.setter
	def name(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,label):
			self._name = label(value)
		else:
			self._name = value

	@property
	def description(self):
		return self._description
	@description.setter
	def description(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,text):
			self._description = text(value)
		else:
			self._description = value

####################
 # ENTITY cartesian_transformation_operator #
####################
class cartesian_transformation_operator(geometric_representation_item,functionally_defined_transformation):
	'''Entity cartesian_transformation_operator definition.

	:param axis1
	:type axis1:direction

	:param axis2
	:type axis2:direction

	:param local_origin
	:type local_origin:cartesian_point

	:param scale
	:type scale:REAL

	:param scl
	:type scl:REAL
	'''
	def __init__( self , inherited0__name , inherited1__name , inherited2__description , axis1,axis2,local_origin,scale, ):
		geometric_representation_item.__init__(self , inherited0__name , )
		functionally_defined_transformation.__init__(self , inherited1__name , inherited2__description , )
		self._axis1 = axis1
		self._axis2 = axis2
		self._local_origin = local_origin
		self._scale = scale

	@property
	def axis1(self):
		return self._axis1
	@axis1.setter
	def axis1(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,direction):
				self._axis1 = direction(value)
			else:
				self._axis1 = value
		else:
			self._axis1 = value

	@property
	def axis2(self):
		return self._axis2
	@axis2.setter
	def axis2(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,direction):
				self._axis2 = direction(value)
			else:
				self._axis2 = value
		else:
			self._axis2 = value

	@property
	def local_origin(self):
		return self._local_origin
	@local_origin.setter
	def local_origin(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,cartesian_point):
			self._local_origin = cartesian_point(value)
		else:
			self._local_origin = value

	@property
	def scale(self):
		return self._scale
	@scale.setter
	def scale(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,REAL):
				self._scale = REAL(value)
			else:
				self._scale = value
		else:
			self._scale = value

	@property
	def scl(self):
		attribute_eval = NVL(self.scale,1)
		return attribute_eval
	@scl.setter
	def scl(self, value):
	# DERIVED argument
		raise AssertionError('Argument scl is DERIVED. It is computed and can not be set to any value')
	def wr1(self):
		eval_wr1_wr = (self.scl  >  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY cartesian_transformation_operator_3d #
####################
class cartesian_transformation_operator_3d(cartesian_transformation_operator):
	'''Entity cartesian_transformation_operator_3d definition.

	:param axis3
	:type axis3:direction

	:param u
	:type u:LIST(3,3,'direction', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__name , inherited2__description , inherited3__axis1 , inherited4__axis2 , inherited5__local_origin , inherited6__scale , axis3, ):
		cartesian_transformation_operator.__init__(self , inherited0__name , inherited1__name , inherited2__description , inherited3__axis1 , inherited4__axis2 , inherited5__local_origin , inherited6__scale , )
		self._axis3 = axis3

	@property
	def axis3(self):
		return self._axis3
	@axis3.setter
	def axis3(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,direction):
				self._axis3 = direction(value)
			else:
				self._axis3 = value
		else:
			self._axis3 = value

	@property
	def u(self):
		attribute_eval = base_axis(3,self.self.cartesian_transformation_operator.self.axis1,self.self.cartesian_transformation_operator.self.axis2,self.axis3)
		return attribute_eval
	@u.setter
	def u(self, value):
	# DERIVED argument
		raise AssertionError('Argument u is DERIVED. It is computed and can not be set to any value')
	def wr1(self):
		eval_wr1_wr = (self.self.geometric_representation_item.self.dim  ==  3)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY action_request_assignment #
####################
class action_request_assignment(BaseEntityClass):
	'''Entity action_request_assignment definition.

	:param assigned_action_request
	:type assigned_action_request:versioned_action_request
	'''
	def __init__( self , assigned_action_request, ):
		self._assigned_action_request = assigned_action_request

	@property
	def assigned_action_request(self):
		return self._assigned_action_request
	@assigned_action_request.setter
	def assigned_action_request(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,versioned_action_request):
			self._assigned_action_request = versioned_action_request(value)
		else:
			self._assigned_action_request = value

####################
 # ENTITY change_request #
####################
class change_request(action_request_assignment):
	'''Entity change_request definition.

	:param items
	:type items:SET(1,None,'change_request_item', scope = schema_scope)
	'''
	def __init__( self , inherited0__assigned_action_request , items, ):
		action_request_assignment.__init__(self , inherited0__assigned_action_request , )
		self._items = items

	@property
	def items(self):
		return self._items
	@items.setter
	def items(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(1,None,'change_request_item', scope = schema_scope)):
			self._items = SET(value)
		else:
			self._items = value

####################
 # ENTITY point #
####################
class point(geometric_representation_item):
	'''Entity point definition.
	'''
	def __init__( self , inherited0__name ,  ):
		geometric_representation_item.__init__(self , inherited0__name , )

####################
 # ENTITY degenerate_pcurve #
####################
class degenerate_pcurve(point):
	'''Entity degenerate_pcurve definition.

	:param basis_surface
	:type basis_surface:surface

	:param reference_to_curve
	:type reference_to_curve:definitional_representation
	'''
	def __init__( self , inherited0__name , basis_surface,reference_to_curve, ):
		point.__init__(self , inherited0__name , )
		self._basis_surface = basis_surface
		self._reference_to_curve = reference_to_curve

	@property
	def basis_surface(self):
		return self._basis_surface
	@basis_surface.setter
	def basis_surface(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,surface):
			self._basis_surface = surface(value)
		else:
			self._basis_surface = value

	@property
	def reference_to_curve(self):
		return self._reference_to_curve
	@reference_to_curve.setter
	def reference_to_curve(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,definitional_representation):
			self._reference_to_curve = definitional_representation(value)
		else:
			self._reference_to_curve = value
	def wr1(self):
		eval_wr1_wr = (SIZEOF(self.reference_to_curve.self.representation.self.items)  ==  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ('CONFIG_CONTROL_DESIGN.CURVE'  ==  TYPEOF(self.reference_to_curve.self.representation.self.items[1]))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (self.reference_to_curve.self.representation.self.items[1].self.geometric_representation_item.self.dim  ==  2)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr


####################
 # ENTITY date_and_time_assignment #
####################
class date_and_time_assignment(BaseEntityClass):
	'''Entity date_and_time_assignment definition.

	:param assigned_date_and_time
	:type assigned_date_and_time:date_and_time

	:param role
	:type role:date_time_role
	'''
	def __init__( self , assigned_date_and_time,role, ):
		self._assigned_date_and_time = assigned_date_and_time
		self._role = role

	@property
	def assigned_date_and_time(self):
		return self._assigned_date_and_time
	@assigned_date_and_time.setter
	def assigned_date_and_time(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,date_and_time):
			self._assigned_date_and_time = date_and_time(value)
		else:
			self._assigned_date_and_time = value

	@property
	def role(self):
		return self._role
	@role.setter
	def role(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,date_time_role):
			self._role = date_time_role(value)
		else:
			self._role = value

####################
 # ENTITY cc_design_date_and_time_assignment #
####################
class cc_design_date_and_time_assignment(date_and_time_assignment):
	'''Entity cc_design_date_and_time_assignment definition.

	:param items
	:type items:SET(1,None,'date_time_item', scope = schema_scope)
	'''
	def __init__( self , inherited0__assigned_date_and_time , inherited1__role , items, ):
		date_and_time_assignment.__init__(self , inherited0__assigned_date_and_time , inherited1__role , )
		self._items = items

	@property
	def items(self):
		return self._items
	@items.setter
	def items(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(1,None,'date_time_item', scope = schema_scope)):
			self._items = SET(value)
		else:
			self._items = value
	def wr1(self):
		eval_wr1_wr = cc_design_date_time_correlation(self)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY approval_relationship #
####################
class approval_relationship(BaseEntityClass):
	'''Entity approval_relationship definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param relating_approval
	:type relating_approval:approval

	:param related_approval
	:type related_approval:approval
	'''
	def __init__( self , name,description,relating_approval,related_approval, ):
		self._name = name
		self._description = description
		self._relating_approval = relating_approval
		self._related_approval = related_approval

	@property
	def name(self):
		return self._name
	@name.setter
	def name(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,label):
			self._name = label(value)
		else:
			self._name = value

	@property
	def description(self):
		return self._description
	@description.setter
	def description(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,text):
			self._description = text(value)
		else:
			self._description = value

	@property
	def relating_approval(self):
		return self._relating_approval
	@relating_approval.setter
	def relating_approval(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,approval):
			self._relating_approval = approval(value)
		else:
			self._relating_approval = value

	@property
	def related_approval(self):
		return self._related_approval
	@related_approval.setter
	def related_approval(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,approval):
			self._related_approval = approval(value)
		else:
			self._related_approval = value

####################
 # ENTITY geometric_set #
####################
class geometric_set(geometric_representation_item):
	'''Entity geometric_set definition.

	:param elements
	:type elements:SET(1,None,'geometric_set_select', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , elements, ):
		geometric_representation_item.__init__(self , inherited0__name , )
		self._elements = elements

	@property
	def elements(self):
		return self._elements
	@elements.setter
	def elements(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(1,None,'geometric_set_select', scope = schema_scope)):
			self._elements = SET(value)
		else:
			self._elements = value

####################
 # ENTITY uniform_surface #
####################
class uniform_surface(b_spline_surface):
	'''Entity uniform_surface definition.
	'''
	def __init__( self , inherited0__name , inherited1__u_degree , inherited2__v_degree , inherited3__control_points_list , inherited4__surface_form , inherited5__u_closed , inherited6__v_closed , inherited7__self_intersect ,  ):
		b_spline_surface.__init__(self , inherited0__name , inherited1__u_degree , inherited2__v_degree , inherited3__control_points_list , inherited4__surface_form , inherited5__u_closed , inherited6__v_closed , inherited7__self_intersect , )

####################
 # ENTITY certification #
####################
class certification(BaseEntityClass):
	'''Entity certification definition.

	:param name
	:type name:label

	:param purpose
	:type purpose:text

	:param kind
	:type kind:certification_type
	'''
	def __init__( self , name,purpose,kind, ):
		self._name = name
		self._purpose = purpose
		self._kind = kind

	@property
	def name(self):
		return self._name
	@name.setter
	def name(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,label):
			self._name = label(value)
		else:
			self._name = value

	@property
	def purpose(self):
		return self._purpose
	@purpose.setter
	def purpose(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,text):
			self._purpose = text(value)
		else:
			self._purpose = value

	@property
	def kind(self):
		return self._kind
	@kind.setter
	def kind(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,certification_type):
			self._kind = certification_type(value)
		else:
			self._kind = value

####################
 # ENTITY edge_based_wireframe_model #
####################
class edge_based_wireframe_model(geometric_representation_item):
	'''Entity edge_based_wireframe_model definition.

	:param ebwm_boundary
	:type ebwm_boundary:SET(1,None,'connected_edge_set', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , ebwm_boundary, ):
		geometric_representation_item.__init__(self , inherited0__name , )
		self._ebwm_boundary = ebwm_boundary

	@property
	def ebwm_boundary(self):
		return self._ebwm_boundary
	@ebwm_boundary.setter
	def ebwm_boundary(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(1,None,'connected_edge_set', scope = schema_scope)):
			self._ebwm_boundary = SET(value)
		else:
			self._ebwm_boundary = value

####################
 # ENTITY surface_curve #
####################
class surface_curve(curve):
	'''Entity surface_curve definition.

	:param curve_3d
	:type curve_3d:curve

	:param associated_geometry
	:type associated_geometry:LIST(1,2,'pcurve_or_surface', scope = schema_scope)

	:param master_representation
	:type master_representation:preferred_surface_curve_representation

	:param basis_surface
	:type basis_surface:SET(1,2,'surface', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , curve_3d,associated_geometry,master_representation, ):
		curve.__init__(self , inherited0__name , )
		self._curve_3d = curve_3d
		self._associated_geometry = associated_geometry
		self._master_representation = master_representation

	@property
	def curve_3d(self):
		return self._curve_3d
	@curve_3d.setter
	def curve_3d(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,curve):
			self._curve_3d = curve(value)
		else:
			self._curve_3d = value

	@property
	def associated_geometry(self):
		return self._associated_geometry
	@associated_geometry.setter
	def associated_geometry(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,LIST(1,2,'pcurve_or_surface', scope = schema_scope)):
			self._associated_geometry = LIST(value)
		else:
			self._associated_geometry = value

	@property
	def master_representation(self):
		return self._master_representation
	@master_representation.setter
	def master_representation(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,preferred_surface_curve_representation):
			self._master_representation = preferred_surface_curve_representation(value)
		else:
			self._master_representation = value

	@property
	def basis_surface(self):
		attribute_eval = get_basis_surface(self)
		return attribute_eval
	@basis_surface.setter
	def basis_surface(self, value):
	# DERIVED argument
		raise AssertionError('Argument basis_surface is DERIVED. It is computed and can not be set to any value')
	def wr1(self):
		eval_wr1_wr = (self.curve_3d.self.dim  ==  3)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (('CONFIG_CONTROL_DESIGN.PCURVE'  ==  TYPEOF(self.associated_geometry[1]))  or  (self.master_representation  !=  pcurve_s1))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (('CONFIG_CONTROL_DESIGN.PCURVE'  ==  TYPEOF(self.associated_geometry[2]))  or  (self.master_representation  !=  pcurve_s2))
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = ( not ('CONFIG_CONTROL_DESIGN.PCURVE'  ==  TYPEOF(self.curve_3d)))
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr


####################
 # ENTITY bounded_surface_curve #
####################
class bounded_surface_curve(surface_curve,bounded_curve):
	'''Entity bounded_surface_curve definition.
	'''
	def __init__( self , inherited0__name , inherited1__curve_3d , inherited2__associated_geometry , inherited3__master_representation , inherited4__name ,  ):
		surface_curve.__init__(self , inherited0__name , inherited1__curve_3d , inherited2__associated_geometry , inherited3__master_representation , )
		bounded_curve.__init__(self , inherited4__name , )
	def wr1(self):
		eval_wr1_wr = ('CONFIG_CONTROL_DESIGN.BOUNDED_CURVE'  ==  TYPEOF(self.self.surface_curve.self.curve_3d))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY conic #
####################
class conic(curve):
	'''Entity conic definition.

	:param position
	:type position:axis2_placement
	'''
	def __init__( self , inherited0__name , position, ):
		curve.__init__(self , inherited0__name , )
		self._position = position

	@property
	def position(self):
		return self._position
	@position.setter
	def position(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,axis2_placement):
			self._position = axis2_placement(value)
		else:
			self._position = value

####################
 # ENTITY hyperbola #
####################
class hyperbola(conic):
	'''Entity hyperbola definition.

	:param semi_axis
	:type semi_axis:positive_length_measure

	:param semi_imag_axis
	:type semi_imag_axis:positive_length_measure
	'''
	def __init__( self , inherited0__name , inherited1__position , semi_axis,semi_imag_axis, ):
		conic.__init__(self , inherited0__name , inherited1__position , )
		self._semi_axis = semi_axis
		self._semi_imag_axis = semi_imag_axis

	@property
	def semi_axis(self):
		return self._semi_axis
	@semi_axis.setter
	def semi_axis(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,positive_length_measure):
			self._semi_axis = positive_length_measure(value)
		else:
			self._semi_axis = value

	@property
	def semi_imag_axis(self):
		return self._semi_imag_axis
	@semi_imag_axis.setter
	def semi_imag_axis(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,positive_length_measure):
			self._semi_imag_axis = positive_length_measure(value)
		else:
			self._semi_imag_axis = value

####################
 # ENTITY property_definition #
####################
class property_definition(BaseEntityClass):
	'''Entity property_definition definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param definition
	:type definition:characterized_definition
	'''
	def __init__( self , name,description,definition, ):
		self._name = name
		self._description = description
		self._definition = definition

	@property
	def name(self):
		return self._name
	@name.setter
	def name(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,label):
			self._name = label(value)
		else:
			self._name = value

	@property
	def description(self):
		return self._description
	@description.setter
	def description(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,text):
			self._description = text(value)
		else:
			self._description = value

	@property
	def definition(self):
		return self._definition
	@definition.setter
	def definition(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,characterized_definition):
			self._definition = characterized_definition(value)
		else:
			self._definition = value

####################
 # ENTITY degenerate_toroidal_surface #
####################
class degenerate_toroidal_surface(toroidal_surface):
	'''Entity degenerate_toroidal_surface definition.

	:param select_outer
	:type select_outer:BOOLEAN
	'''
	def __init__( self , inherited0__name , inherited1__position , inherited2__major_radius , inherited3__minor_radius , select_outer, ):
		toroidal_surface.__init__(self , inherited0__name , inherited1__position , inherited2__major_radius , inherited3__minor_radius , )
		self._select_outer = select_outer

	@property
	def select_outer(self):
		return self._select_outer
	@select_outer.setter
	def select_outer(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,BOOLEAN):
			self._select_outer = BOOLEAN(value)
		else:
			self._select_outer = value
	def wr1(self):
		eval_wr1_wr = (self.major_radius  <  self.minor_radius)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY product_definition #
####################
class product_definition(BaseEntityClass):
	'''Entity product_definition definition.

	:param id
	:type id:identifier

	:param description
	:type description:text

	:param formation
	:type formation:product_definition_formation

	:param frame_of_reference
	:type frame_of_reference:product_definition_context
	'''
	def __init__( self , id,description,formation,frame_of_reference, ):
		self._id = id
		self._description = description
		self._formation = formation
		self._frame_of_reference = frame_of_reference

	@property
	def id(self):
		return self._id
	@id.setter
	def id(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,identifier):
			self._id = identifier(value)
		else:
			self._id = value

	@property
	def description(self):
		return self._description
	@description.setter
	def description(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,text):
			self._description = text(value)
		else:
			self._description = value

	@property
	def formation(self):
		return self._formation
	@formation.setter
	def formation(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,product_definition_formation):
			self._formation = product_definition_formation(value)
		else:
			self._formation = value

	@property
	def frame_of_reference(self):
		return self._frame_of_reference
	@frame_of_reference.setter
	def frame_of_reference(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,product_definition_context):
			self._frame_of_reference = product_definition_context(value)
		else:
			self._frame_of_reference = value

####################
 # ENTITY product_definition_with_associated_documents #
####################
class product_definition_with_associated_documents(product_definition):
	'''Entity product_definition_with_associated_documents definition.

	:param documentation_ids
	:type documentation_ids:SET(1,None,'document', scope = schema_scope)
	'''
	def __init__( self , inherited0__id , inherited1__description , inherited2__formation , inherited3__frame_of_reference , documentation_ids, ):
		product_definition.__init__(self , inherited0__id , inherited1__description , inherited2__formation , inherited3__frame_of_reference , )
		self._documentation_ids = documentation_ids

	@property
	def documentation_ids(self):
		return self._documentation_ids
	@documentation_ids.setter
	def documentation_ids(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(1,None,'document', scope = schema_scope)):
			self._documentation_ids = SET(value)
		else:
			self._documentation_ids = value

####################
 # ENTITY path #
####################
class path(topological_representation_item):
	'''Entity path definition.

	:param edge_list
	:type edge_list:LIST(1,None,'oriented_edge', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , edge_list, ):
		topological_representation_item.__init__(self , inherited0__name , )
		self._edge_list = edge_list

	@property
	def edge_list(self):
		return self._edge_list
	@edge_list.setter
	def edge_list(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,LIST(1,None,'oriented_edge', scope = schema_scope)):
			self._edge_list = LIST(value)
		else:
			self._edge_list = value
	def wr1(self):
		eval_wr1_wr = path_head_to_tail(self)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY action_assignment #
####################
class action_assignment(BaseEntityClass):
	'''Entity action_assignment definition.

	:param assigned_action
	:type assigned_action:action
	'''
	def __init__( self , assigned_action, ):
		self._assigned_action = assigned_action

	@property
	def assigned_action(self):
		return self._assigned_action
	@assigned_action.setter
	def assigned_action(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,action):
			self._assigned_action = action(value)
		else:
			self._assigned_action = value

####################
 # ENTITY start_work #
####################
class start_work(action_assignment):
	'''Entity start_work definition.

	:param items
	:type items:SET(1,None,'work_item', scope = schema_scope)
	'''
	def __init__( self , inherited0__assigned_action , items, ):
		action_assignment.__init__(self , inherited0__assigned_action , )
		self._items = items

	@property
	def items(self):
		return self._items
	@items.setter
	def items(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(1,None,'work_item', scope = schema_scope)):
			self._items = SET(value)
		else:
			self._items = value

####################
 # ENTITY approval #
####################
class approval(BaseEntityClass):
	'''Entity approval definition.

	:param status
	:type status:approval_status

	:param level
	:type level:label
	'''
	def __init__( self , status,level, ):
		self._status = status
		self._level = level

	@property
	def status(self):
		return self._status
	@status.setter
	def status(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,approval_status):
			self._status = approval_status(value)
		else:
			self._status = value

	@property
	def level(self):
		return self._level
	@level.setter
	def level(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,label):
			self._level = label(value)
		else:
			self._level = value

####################
 # ENTITY loop #
####################
class loop(topological_representation_item):
	'''Entity loop definition.
	'''
	def __init__( self , inherited0__name ,  ):
		topological_representation_item.__init__(self , inherited0__name , )

####################
 # ENTITY poly_loop #
####################
class poly_loop(loop,geometric_representation_item):
	'''Entity poly_loop definition.

	:param polygon
	:type polygon:LIST(3,None,'cartesian_point', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__name , polygon, ):
		loop.__init__(self , inherited0__name , )
		geometric_representation_item.__init__(self , inherited1__name , )
		self._polygon = polygon

	@property
	def polygon(self):
		return self._polygon
	@polygon.setter
	def polygon(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,LIST(3,None,'cartesian_point', scope = schema_scope)):
			self._polygon = LIST(value)
		else:
			self._polygon = value

####################
 # ENTITY point_on_surface #
####################
class point_on_surface(point):
	'''Entity point_on_surface definition.

	:param basis_surface
	:type basis_surface:surface

	:param point_parameter_u
	:type point_parameter_u:parameter_value

	:param point_parameter_v
	:type point_parameter_v:parameter_value
	'''
	def __init__( self , inherited0__name , basis_surface,point_parameter_u,point_parameter_v, ):
		point.__init__(self , inherited0__name , )
		self._basis_surface = basis_surface
		self._point_parameter_u = point_parameter_u
		self._point_parameter_v = point_parameter_v

	@property
	def basis_surface(self):
		return self._basis_surface
	@basis_surface.setter
	def basis_surface(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,surface):
			self._basis_surface = surface(value)
		else:
			self._basis_surface = value

	@property
	def point_parameter_u(self):
		return self._point_parameter_u
	@point_parameter_u.setter
	def point_parameter_u(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,parameter_value):
			self._point_parameter_u = parameter_value(value)
		else:
			self._point_parameter_u = value

	@property
	def point_parameter_v(self):
		return self._point_parameter_v
	@point_parameter_v.setter
	def point_parameter_v(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,parameter_value):
			self._point_parameter_v = parameter_value(value)
		else:
			self._point_parameter_v = value

####################
 # ENTITY product_concept #
####################
class product_concept(BaseEntityClass):
	'''Entity product_concept definition.

	:param id
	:type id:identifier

	:param name
	:type name:label

	:param description
	:type description:text

	:param market_context
	:type market_context:product_concept_context
	'''
	def __init__( self , id,name,description,market_context, ):
		self._id = id
		self._name = name
		self._description = description
		self._market_context = market_context

	@property
	def id(self):
		return self._id
	@id.setter
	def id(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,identifier):
			self._id = identifier(value)
		else:
			self._id = value

	@property
	def name(self):
		return self._name
	@name.setter
	def name(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,label):
			self._name = label(value)
		else:
			self._name = value

	@property
	def description(self):
		return self._description
	@description.setter
	def description(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,text):
			self._description = text(value)
		else:
			self._description = value

	@property
	def market_context(self):
		return self._market_context
	@market_context.setter
	def market_context(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,product_concept_context):
			self._market_context = product_concept_context(value)
		else:
			self._market_context = value

####################
 # ENTITY rational_b_spline_curve #
####################
class rational_b_spline_curve(b_spline_curve):
	'''Entity rational_b_spline_curve definition.

	:param weights_data
	:type weights_data:LIST(2,None,'REAL', scope = schema_scope)

	:param weights
	:type weights:ARRAY(0,upper_index_on_control_points,'REAL', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__degree , inherited2__control_points_list , inherited3__curve_form , inherited4__closed_curve , inherited5__self_intersect , weights_data, ):
		b_spline_curve.__init__(self , inherited0__name , inherited1__degree , inherited2__control_points_list , inherited3__curve_form , inherited4__closed_curve , inherited5__self_intersect , )
		self._weights_data = weights_data

	@property
	def weights_data(self):
		return self._weights_data
	@weights_data.setter
	def weights_data(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,LIST(2,None,'REAL', scope = schema_scope)):
			self._weights_data = LIST(value)
		else:
			self._weights_data = value

	@property
	def weights(self):
		attribute_eval = list_to_array(self.weights_data,0,self.upper_index_on_control_points)
		return attribute_eval
	@weights.setter
	def weights(self, value):
	# DERIVED argument
		raise AssertionError('Argument weights is DERIVED. It is computed and can not be set to any value')
	def wr1(self):
		eval_wr1_wr = (SIZEOF(self.weights_data)  ==  SIZEOF(self.self.b_spline_curve.self.control_points_list))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = curve_weights_positive(self)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY start_request #
####################
class start_request(action_request_assignment):
	'''Entity start_request definition.

	:param items
	:type items:SET(1,None,'start_request_item', scope = schema_scope)
	'''
	def __init__( self , inherited0__assigned_action_request , items, ):
		action_request_assignment.__init__(self , inherited0__assigned_action_request , )
		self._items = items

	@property
	def items(self):
		return self._items
	@items.setter
	def items(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(1,None,'start_request_item', scope = schema_scope)):
			self._items = SET(value)
		else:
			self._items = value

####################
 # ENTITY edge_based_wireframe_shape_representation #
####################
class edge_based_wireframe_shape_representation(shape_representation):
	'''Entity edge_based_wireframe_shape_representation definition.
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items ,  ):
		shape_representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  >=  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  0)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(None)  ==  0)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = (SIZEOF(None)  ==  0)
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr

	def wr6(self):
		eval_wr6_wr = (SIZEOF(None)  ==  0)
		if not eval_wr6_wr:
			raise AssertionError('Rule wr6 violated')
		else:
			return eval_wr6_wr

	def wr7(self):
		eval_wr7_wr = (SIZEOF(None)  ==  0)
		if not eval_wr7_wr:
			raise AssertionError('Rule wr7 violated')
		else:
			return eval_wr7_wr

	def wr8(self):
		eval_wr8_wr = (SIZEOF(None)  ==  0)
		if not eval_wr8_wr:
			raise AssertionError('Rule wr8 violated')
		else:
			return eval_wr8_wr

	def wr9(self):
		eval_wr9_wr = (self.self.context_of_items.self.geometric_representation_context.self.coordinate_space_dimension  ==  3)
		if not eval_wr9_wr:
			raise AssertionError('Rule wr9 violated')
		else:
			return eval_wr9_wr


####################
 # ENTITY polyline #
####################
class polyline(bounded_curve):
	'''Entity polyline definition.

	:param points
	:type points:LIST(2,None,'cartesian_point', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , points, ):
		bounded_curve.__init__(self , inherited0__name , )
		self._points = points

	@property
	def points(self):
		return self._points
	@points.setter
	def points(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,LIST(2,None,'cartesian_point', scope = schema_scope)):
			self._points = LIST(value)
		else:
			self._points = value

####################
 # ENTITY spherical_surface #
####################
class spherical_surface(elementary_surface):
	'''Entity spherical_surface definition.

	:param radius
	:type radius:positive_length_measure
	'''
	def __init__( self , inherited0__name , inherited1__position , radius, ):
		elementary_surface.__init__(self , inherited0__name , inherited1__position , )
		self._radius = radius

	def printer(self):
		print '    '+self.stepLine
		print '      '+self.position.stepLine
		self.position.printer()

	@property
	def radius(self):
		return self._radius
	@radius.setter
	def radius(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,positive_length_measure):
			self._radius = positive_length_measure(value)
		else:
			self._radius = value

####################
 # ENTITY contract_assignment #
####################
class contract_assignment(BaseEntityClass):
	'''Entity contract_assignment definition.

	:param assigned_contract
	:type assigned_contract:contract
	'''
	def __init__( self , assigned_contract, ):
		self._assigned_contract = assigned_contract

	@property
	def assigned_contract(self):
		return self._assigned_contract
	@assigned_contract.setter
	def assigned_contract(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,contract):
			self._assigned_contract = contract(value)
		else:
			self._assigned_contract = value

####################
 # ENTITY cc_design_contract #
####################
class cc_design_contract(contract_assignment):
	'''Entity cc_design_contract definition.

	:param items
	:type items:SET(1,None,'contracted_item', scope = schema_scope)
	'''
	def __init__( self , inherited0__assigned_contract , items, ):
		contract_assignment.__init__(self , inherited0__assigned_contract , )
		self._items = items

	@property
	def items(self):
		return self._items
	@items.setter
	def items(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(1,None,'contracted_item', scope = schema_scope)):
			self._items = SET(value)
		else:
			self._items = value

####################
 # ENTITY configuration_item #
####################
class configuration_item(BaseEntityClass):
	'''Entity configuration_item definition.

	:param id
	:type id:identifier

	:param name
	:type name:label

	:param description
	:type description:text

	:param item_concept
	:type item_concept:product_concept

	:param purpose
	:type purpose:label
	'''
	def __init__( self , id,name,description,item_concept,purpose, ):
		self._id = id
		self._name = name
		self._description = description
		self._item_concept = item_concept
		self._purpose = purpose

	@property
	def id(self):
		return self._id
	@id.setter
	def id(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,identifier):
			self._id = identifier(value)
		else:
			self._id = value

	@property
	def name(self):
		return self._name
	@name.setter
	def name(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,label):
			self._name = label(value)
		else:
			self._name = value

	@property
	def description(self):
		return self._description
	@description.setter
	def description(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,text):
				self._description = text(value)
			else:
				self._description = value
		else:
			self._description = value

	@property
	def item_concept(self):
		return self._item_concept
	@item_concept.setter
	def item_concept(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,product_concept):
			self._item_concept = product_concept(value)
		else:
			self._item_concept = value

	@property
	def purpose(self):
		return self._purpose
	@purpose.setter
	def purpose(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,label):
				self._purpose = label(value)
			else:
				self._purpose = value
		else:
			self._purpose = value

####################
 # ENTITY date #
####################
class date(BaseEntityClass):
	'''Entity date definition.

	:param year_component
	:type year_component:year_number
	'''
	def __init__( self , year_component, ):
		self._year_component = year_component

	@property
	def year_component(self):
		return self._year_component
	@year_component.setter
	def year_component(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,year_number):
			self._year_component = year_number(value)
		else:
			self._year_component = value

####################
 # ENTITY week_of_year_and_day_date #
####################
class week_of_year_and_day_date(date):
	'''Entity week_of_year_and_day_date definition.

	:param week_component
	:type week_component:week_in_year_number

	:param day_component
	:type day_component:day_in_week_number
	'''
	def __init__( self , inherited0__year_component , week_component,day_component, ):
		date.__init__(self , inherited0__year_component , )
		self._week_component = week_component
		self._day_component = day_component

	@property
	def week_component(self):
		return self._week_component
	@week_component.setter
	def week_component(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,week_in_year_number):
			self._week_component = week_in_year_number(value)
		else:
			self._week_component = value

	@property
	def day_component(self):
		return self._day_component
	@day_component.setter
	def day_component(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,day_in_week_number):
				self._day_component = day_in_week_number(value)
			else:
				self._day_component = value
		else:
			self._day_component = value

####################
 # ENTITY effectivity #
####################
class effectivity(BaseEntityClass):
	'''Entity effectivity definition.

	:param id
	:type id:identifier
	'''
	def __init__( self , id, ):
		self._id = id

	@property
	def id(self):
		return self._id
	@id.setter
	def id(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,identifier):
			self._id = identifier(value)
		else:
			self._id = value

####################
 # ENTITY lot_effectivity #
####################
class lot_effectivity(effectivity):
	'''Entity lot_effectivity definition.

	:param effectivity_lot_id
	:type effectivity_lot_id:identifier

	:param effectivity_lot_size
	:type effectivity_lot_size:measure_with_unit
	'''
	def __init__( self , inherited0__id , effectivity_lot_id,effectivity_lot_size, ):
		effectivity.__init__(self , inherited0__id , )
		self._effectivity_lot_id = effectivity_lot_id
		self._effectivity_lot_size = effectivity_lot_size

	@property
	def effectivity_lot_id(self):
		return self._effectivity_lot_id
	@effectivity_lot_id.setter
	def effectivity_lot_id(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,identifier):
			self._effectivity_lot_id = identifier(value)
		else:
			self._effectivity_lot_id = value

	@property
	def effectivity_lot_size(self):
		return self._effectivity_lot_size
	@effectivity_lot_size.setter
	def effectivity_lot_size(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,measure_with_unit):
			self._effectivity_lot_size = measure_with_unit(value)
		else:
			self._effectivity_lot_size = value

####################
 # ENTITY application_context_element #
####################
class application_context_element(BaseEntityClass):
	'''Entity application_context_element definition.

	:param name
	:type name:label

	:param frame_of_reference
	:type frame_of_reference:application_context
	'''
	def __init__( self , name,frame_of_reference, ):
		self._name = name
		self._frame_of_reference = frame_of_reference

	@property
	def name(self):
		return self._name
	@name.setter
	def name(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,label):
			self._name = label(value)
		else:
			self._name = value

	@property
	def frame_of_reference(self):
		return self._frame_of_reference
	@frame_of_reference.setter
	def frame_of_reference(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,application_context):
			self._frame_of_reference = application_context(value)
		else:
			self._frame_of_reference = value

####################
 # ENTITY shape_definition_representation #
####################
class shape_definition_representation(property_definition_representation):
	'''Entity shape_definition_representation definition.
	'''
	def __init__( self , inherited0__definition , inherited1__used_representation ,  ):
		property_definition_representation.__init__(self , inherited0__definition , inherited1__used_representation , )
	def wr1(self):
		eval_wr1_wr = (('CONFIG_CONTROL_DESIGN.SHAPE_DEFINITION'  ==  TYPEOF(self.self.definition.self.definition))  or  ('CONFIG_CONTROL_DESIGN.PRODUCT_DEFINITION_SHAPE'  ==  TYPEOF(self.self.definition)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ('CONFIG_CONTROL_DESIGN.SHAPE_REPRESENTATION'  ==  TYPEOF(self.self.used_representation))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY connected_face_set #
####################
class connected_face_set(topological_representation_item):
	'''Entity connected_face_set definition.

	:param cfs_faces
	:type cfs_faces:SET(1,None,'face', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , cfs_faces, ):
		topological_representation_item.__init__(self , inherited0__name , )
		self._cfs_faces = cfs_faces

	@property
	def cfs_faces(self):
		return self._cfs_faces
	@cfs_faces.setter
	def cfs_faces(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(1,None,'face', scope = schema_scope)):
			self._cfs_faces = SET(value)
		else:
			self._cfs_faces = value

####################
 # ENTITY closed_shell #
####################
class closed_shell(connected_face_set):
	'''Entity closed_shell definition.
	'''
	def __init__( self , inherited0__name , inherited1__cfs_faces ,  ):
		connected_face_set.__init__(self , inherited0__name , inherited1__cfs_faces , )
	''' Function getSurfaceType
	@param: type face_geometry type
	@return: list of face_geometry objects that are of a defined type
	'''
	def getSurfaceType(self, face_geometry_type):
		ret = []
		for af in self.cfs_faces:
			if(isinstance(af.face_geometry, face_geometry_type)):
				ret.append(af.face_geometry)
		return ret

	def getAdvancedFacesFromSurfaceType(self, surface_type):
		ret = []
		for af in self.cfs_faces:
			if(af.face_geometry.stepLine==surface_type.stepLine):
				ret.append(af)
		return ret



####################
 # ENTITY application_protocol_definition #
####################
class application_protocol_definition(BaseEntityClass):
	'''Entity application_protocol_definition definition.

	:param status
	:type status:label

	:param application_interpreted_model_schema_name
	:type application_interpreted_model_schema_name:label

	:param application_protocol_year
	:type application_protocol_year:year_number

	:param application
	:type application:application_context
	'''
	def __init__( self , status,application_interpreted_model_schema_name,application_protocol_year,application, ):
		self._status = status
		self._application_interpreted_model_schema_name = application_interpreted_model_schema_name
		self._application_protocol_year = application_protocol_year
		self._application = application

	@property
	def status(self):
		return self._status
	@status.setter
	def status(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,label):
			self._status = label(value)
		else:
			self._status = value

	@property
	def application_interpreted_model_schema_name(self):
		return self._application_interpreted_model_schema_name
	@application_interpreted_model_schema_name.setter
	def application_interpreted_model_schema_name(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,label):
			self._application_interpreted_model_schema_name = label(value)
		else:
			self._application_interpreted_model_schema_name = value

	@property
	def application_protocol_year(self):
		return self._application_protocol_year
	@application_protocol_year.setter
	def application_protocol_year(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,year_number):
			self._application_protocol_year = year_number(value)
		else:
			self._application_protocol_year = value

	@property
	def application(self):
		return self._application
	@application.setter
	def application(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,application_context):
			self._application = application_context(value)
		else:
			self._application = value

####################
 # ENTITY product_category #
####################
class product_category(BaseEntityClass):
	'''Entity product_category definition.

	:param name
	:type name:label

	:param description
	:type description:text
	'''
	def __init__( self , name,description, ):
		self._name = name
		self._description = description

	@property
	def name(self):
		return self._name
	@name.setter
	def name(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,label):
			self._name = label(value)
		else:
			self._name = value

	@property
	def description(self):
		return self._description
	@description.setter
	def description(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,text):
				self._description = text(value)
			else:
				self._description = value
		else:
			self._description = value

####################
 # ENTITY product_related_product_category #
####################
class product_related_product_category(product_category):
	'''Entity product_related_product_category definition.

	:param products
	:type products:SET(1,None,'product', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__description , products, ):
		product_category.__init__(self , inherited0__name , inherited1__description , )
		self._products = products

	@property
	def products(self):
		return self._products
	@products.setter
	def products(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(1,None,'product', scope = schema_scope)):
			self._products = SET(value)
		else:
			self._products = value

####################
 # ENTITY action_method #
####################
class action_method(BaseEntityClass):
	'''Entity action_method definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param consequence
	:type consequence:text

	:param purpose
	:type purpose:text
	'''
	def __init__( self , name,description,consequence,purpose, ):
		self._name = name
		self._description = description
		self._consequence = consequence
		self._purpose = purpose

	@property
	def name(self):
		return self._name
	@name.setter
	def name(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,label):
			self._name = label(value)
		else:
			self._name = value

	@property
	def description(self):
		return self._description
	@description.setter
	def description(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,text):
			self._description = text(value)
		else:
			self._description = value

	@property
	def consequence(self):
		return self._consequence
	@consequence.setter
	def consequence(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,text):
			self._consequence = text(value)
		else:
			self._consequence = value

	@property
	def purpose(self):
		return self._purpose
	@purpose.setter
	def purpose(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,text):
			self._purpose = text(value)
		else:
			self._purpose = value

####################
 # ENTITY product_definition_shape #
####################
class product_definition_shape(property_definition):
	'''Entity product_definition_shape definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__definition ,  ):
		property_definition.__init__(self , inherited0__name , inherited1__description , inherited2__definition , )
	def wr1(self):
		eval_wr1_wr = ( not ('CONFIG_CONTROL_DESIGN.SHAPE_DEFINITION'  ==  TYPEOF(self.self.property_definition.self.definition)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY seam_curve #
####################
class seam_curve(surface_curve):
	'''Entity seam_curve definition.
	'''
	def __init__( self , inherited0__name , inherited1__curve_3d , inherited2__associated_geometry , inherited3__master_representation ,  ):
		surface_curve.__init__(self , inherited0__name , inherited1__curve_3d , inherited2__associated_geometry , inherited3__master_representation , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(self.self.surface_curve.self.associated_geometry)  ==  2)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (associated_surface(self.self.surface_curve.self.associated_geometry[1])  ==  associated_surface(self.self.surface_curve.self.associated_geometry[2]))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = ('CONFIG_CONTROL_DESIGN.PCURVE'  ==  TYPEOF(self.self.surface_curve.self.associated_geometry[1]))
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = ('CONFIG_CONTROL_DESIGN.PCURVE'  ==  TYPEOF(self.self.surface_curve.self.associated_geometry[2]))
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr


####################
 # ENTITY configuration_design #
####################
class configuration_design(BaseEntityClass):
	'''Entity configuration_design definition.

	:param configuration
	:type configuration:configuration_item

	:param design
	:type design:product_definition_formation
	'''
	def __init__( self , configuration,design, ):
		self._configuration = configuration
		self._design = design

	@property
	def configuration(self):
		return self._configuration
	@configuration.setter
	def configuration(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,configuration_item):
			self._configuration = configuration_item(value)
		else:
			self._configuration = value

	@property
	def design(self):
		return self._design
	@design.setter
	def design(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,product_definition_formation):
			self._design = product_definition_formation(value)
		else:
			self._design = value

####################
 # ENTITY context_dependent_unit #
####################
class context_dependent_unit(named_unit):
	'''Entity context_dependent_unit definition.

	:param name
	:type name:label
	'''
	def __init__( self , inherited0__dimensions , name, ):
		named_unit.__init__(self , inherited0__dimensions , )
		self._name = name

	@property
	def name(self):
		return self._name
	@name.setter
	def name(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,label):
			self._name = label(value)
		else:
			self._name = value

####################
 # ENTITY action #
####################
class action(BaseEntityClass):
	'''Entity action definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param chosen_method
	:type chosen_method:action_method
	'''
	def __init__( self , name,description,chosen_method, ):
		self._name = name
		self._description = description
		self._chosen_method = chosen_method

	@property
	def name(self):
		return self._name
	@name.setter
	def name(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,label):
			self._name = label(value)
		else:
			self._name = value

	@property
	def description(self):
		return self._description
	@description.setter
	def description(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,text):
			self._description = text(value)
		else:
			self._description = value

	@property
	def chosen_method(self):
		return self._chosen_method
	@chosen_method.setter
	def chosen_method(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,action_method):
			self._chosen_method = action_method(value)
		else:
			self._chosen_method = value

####################
 # ENTITY executed_action #
####################
class executed_action(action):
	'''Entity executed_action definition.
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__chosen_method ,  ):
		action.__init__(self , inherited0__name , inherited1__description , inherited2__chosen_method , )

####################
 # ENTITY product_definition_relationship #
####################
class product_definition_relationship(BaseEntityClass):
	'''Entity product_definition_relationship definition.

	:param id
	:type id:identifier

	:param name
	:type name:label

	:param description
	:type description:text

	:param relating_product_definition
	:type relating_product_definition:product_definition

	:param related_product_definition
	:type related_product_definition:product_definition
	'''
	def __init__( self , id,name,description,relating_product_definition,related_product_definition, ):
		self._id = id
		self._name = name
		self._description = description
		self._relating_product_definition = relating_product_definition
		self._related_product_definition = related_product_definition

	@property
	def id(self):
		return self._id
	@id.setter
	def id(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,identifier):
			self._id = identifier(value)
		else:
			self._id = value

	@property
	def name(self):
		return self._name
	@name.setter
	def name(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,label):
			self._name = label(value)
		else:
			self._name = value

	@property
	def description(self):
		return self._description
	@description.setter
	def description(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,text):
			self._description = text(value)
		else:
			self._description = value

	@property
	def relating_product_definition(self):
		return self._relating_product_definition
	@relating_product_definition.setter
	def relating_product_definition(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,product_definition):
			self._relating_product_definition = product_definition(value)
		else:
			self._relating_product_definition = value

	@property
	def related_product_definition(self):
		return self._related_product_definition
	@related_product_definition.setter
	def related_product_definition(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,product_definition):
			self._related_product_definition = product_definition(value)
		else:
			self._related_product_definition = value

####################
 # ENTITY product_definition_usage #
####################
class product_definition_usage(product_definition_relationship):
	'''Entity product_definition_usage definition.
	'''
	def __init__( self , inherited0__id , inherited1__name , inherited2__description , inherited3__relating_product_definition , inherited4__related_product_definition ,  ):
		product_definition_relationship.__init__(self , inherited0__id , inherited1__name , inherited2__description , inherited3__relating_product_definition , inherited4__related_product_definition , )
	def wr1(self):
		eval_wr1_wr = acyclic_product_definition_relationship(self,[self.self.product_definition_relationship.self.related_product_definition],'CONFIG_CONTROL_DESIGN.PRODUCT_DEFINITION_USAGE')
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY assembly_component_usage #
####################
class assembly_component_usage(product_definition_usage):
	'''Entity assembly_component_usage definition.

	:param reference_designator
	:type reference_designator:identifier
	'''
	def __init__( self , inherited0__id , inherited1__name , inherited2__description , inherited3__relating_product_definition , inherited4__related_product_definition , reference_designator, ):
		product_definition_usage.__init__(self , inherited0__id , inherited1__name , inherited2__description , inherited3__relating_product_definition , inherited4__related_product_definition , )
		self._reference_designator = reference_designator

	@property
	def reference_designator(self):
		return self._reference_designator
	@reference_designator.setter
	def reference_designator(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,identifier):
				self._reference_designator = identifier(value)
			else:
				self._reference_designator = value
		else:
			self._reference_designator = value

####################
 # ENTITY specified_higher_usage_occurrence #
####################
class specified_higher_usage_occurrence(assembly_component_usage):
	'''Entity specified_higher_usage_occurrence definition.

	:param upper_usage
	:type upper_usage:assembly_component_usage

	:param next_usage
	:type next_usage:next_assembly_usage_occurrence
	'''
	def __init__( self , inherited0__id , inherited1__name , inherited2__description , inherited3__relating_product_definition , inherited4__related_product_definition , inherited5__reference_designator , upper_usage,next_usage, ):
		assembly_component_usage.__init__(self , inherited0__id , inherited1__name , inherited2__description , inherited3__relating_product_definition , inherited4__related_product_definition , inherited5__reference_designator , )
		self._upper_usage = upper_usage
		self._next_usage = next_usage

	@property
	def upper_usage(self):
		return self._upper_usage
	@upper_usage.setter
	def upper_usage(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,assembly_component_usage):
			self._upper_usage = assembly_component_usage(value)
		else:
			self._upper_usage = value

	@property
	def next_usage(self):
		return self._next_usage
	@next_usage.setter
	def next_usage(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,next_assembly_usage_occurrence):
			self._next_usage = next_assembly_usage_occurrence(value)
		else:
			self._next_usage = value
	def wr1(self):
		eval_wr1_wr = (self  !=  self.upper_usage)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (self.self.product_definition_relationship.self.relating_product_definition  ==  self.upper_usage.self.relating_product_definition)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (self.self.product_definition_relationship.self.related_product_definition  ==  self.next_usage.self.related_product_definition)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (self.upper_usage.self.related_product_definition  ==  self.next_usage.self.relating_product_definition)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = ( not ('CONFIG_CONTROL_DESIGN.PROMISSORY_USAGE_OCCURRENCE'  ==  TYPEOF(self.upper_usage)))
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr


####################
 # ENTITY mapped_item #
####################
class mapped_item(representation_item):
	'''Entity mapped_item definition.

	:param mapping_source
	:type mapping_source:representation_map

	:param mapping_target
	:type mapping_target:representation_item
	'''
	def __init__( self , inherited0__name , mapping_source,mapping_target, ):
		representation_item.__init__(self , inherited0__name , )
		self._mapping_source = mapping_source
		self._mapping_target = mapping_target

	@property
	def mapping_source(self):
		return self._mapping_source
	@mapping_source.setter
	def mapping_source(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,representation_map):
			self._mapping_source = representation_map(value)
		else:
			self._mapping_source = value

	@property
	def mapping_target(self):
		return self._mapping_target
	@mapping_target.setter
	def mapping_target(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,representation_item):
			self._mapping_target = representation_item(value)
		else:
			self._mapping_target = value
	def wr1(self):
		eval_wr1_wr = acyclic_mapped_representation(using_representations(self),[self])
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY approval_assignment #
####################
class approval_assignment(BaseEntityClass):
	'''Entity approval_assignment definition.

	:param assigned_approval
	:type assigned_approval:approval
	'''
	def __init__( self , assigned_approval, ):
		self._assigned_approval = assigned_approval

	@property
	def assigned_approval(self):
		return self._assigned_approval
	@assigned_approval.setter
	def assigned_approval(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,approval):
			self._assigned_approval = approval(value)
		else:
			self._assigned_approval = value

####################
 # ENTITY cc_design_approval #
####################
class cc_design_approval(approval_assignment):
	'''Entity cc_design_approval definition.

	:param items
	:type items:SET(1,None,'approved_item', scope = schema_scope)
	'''
	def __init__( self , inherited0__assigned_approval , items, ):
		approval_assignment.__init__(self , inherited0__assigned_approval , )
		self._items = items

	@property
	def items(self):
		return self._items
	@items.setter
	def items(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(1,None,'approved_item', scope = schema_scope)):
			self._items = SET(value)
		else:
			self._items = value

####################
 # ENTITY product_definition_context #
####################
class product_definition_context(application_context_element):
	'''Entity product_definition_context definition.

	:param life_cycle_stage
	:type life_cycle_stage:label
	'''
	def __init__( self , inherited0__name , inherited1__frame_of_reference , life_cycle_stage, ):
		application_context_element.__init__(self , inherited0__name , inherited1__frame_of_reference , )
		self._life_cycle_stage = life_cycle_stage

	@property
	def life_cycle_stage(self):
		return self._life_cycle_stage
	@life_cycle_stage.setter
	def life_cycle_stage(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,label):
			self._life_cycle_stage = label(value)
		else:
			self._life_cycle_stage = value

####################
 # ENTITY design_context #
####################
class design_context(product_definition_context):
	'''Entity design_context definition.
	'''
	def __init__( self , inherited0__name , inherited1__frame_of_reference , inherited2__life_cycle_stage ,  ):
		product_definition_context.__init__(self , inherited0__name , inherited1__frame_of_reference , inherited2__life_cycle_stage , )
	def wr1(self):
		eval_wr1_wr = (self.self.life_cycle_stage  ==  'design')
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY swept_surface #
####################
class swept_surface(surface):
	'''Entity swept_surface definition.

	:param swept_curve
	:type swept_curve:curve
	'''
	def __init__( self , inherited0__name , swept_curve, ):
		surface.__init__(self , inherited0__name , )
		self._swept_curve = swept_curve

	@property
	def swept_curve(self):
		return self._swept_curve
	@swept_curve.setter
	def swept_curve(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,curve):
			self._swept_curve = curve(value)
		else:
			self._swept_curve = value

####################
 # ENTITY surface_of_revolution #
####################
class surface_of_revolution(swept_surface):
	'''Entity surface_of_revolution definition.

	:param axis_position
	:type axis_position:axis1_placement

	:param axis_line
	:type axis_line:line
	'''
	def __init__( self , inherited0__name , inherited1__swept_curve , axis_position, ):
		swept_surface.__init__(self , inherited0__name , inherited1__swept_curve , )
		self._axis_position = axis_position

	def printer(self):
		print '    '+self.stepLine
		print '      '+self.swept_curve.stepLine
		print '      '+self.axis_position.stepLine
		self.axis_position.printer()

	@property
	def axis_position(self):
		return self._axis_position
	@axis_position.setter
	def axis_position(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,axis1_placement):
			self._axis_position = axis1_placement(value)
		else:
			self._axis_position = value

	@property
	def axis_line(self):
		attribute_eval = ((self.dummy_gri  ==  curve())  ==  line(self.axis_position.self.location,self.dummy_gri  ==  vector(self.axis_position.self.z,1)))
		return attribute_eval
	@axis_line.setter
	def axis_line(self, value):
	# DERIVED argument
		raise AssertionError('Argument axis_line is DERIVED. It is computed and can not be set to any value')

####################
 # ENTITY vector #
####################
class vector(geometric_representation_item):
	'''Entity vector definition.

	:param orientation
	:type orientation:direction

	:param magnitude
	:type magnitude:length_measure
	'''
	def __init__( self , inherited0__name , orientation,magnitude, ):
		geometric_representation_item.__init__(self , inherited0__name , )
		self._orientation = orientation
		self._magnitude = magnitude

	@property
	def orientation(self):
		return self._orientation
	@orientation.setter
	def orientation(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,direction):
			self._orientation = direction(value)
		else:
			self._orientation = value

	@property
	def magnitude(self):
		return self._magnitude
	@magnitude.setter
	def magnitude(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,length_measure):
			self._magnitude = length_measure(value)
		else:
			self._magnitude = value
	def wr1(self):
		eval_wr1_wr = (self.magnitude  >=  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY solid_angle_measure_with_unit #
####################
class solid_angle_measure_with_unit(measure_with_unit):
	'''Entity solid_angle_measure_with_unit definition.
	'''
	def __init__( self , inherited0__value_component , inherited1__unit_component ,  ):
		measure_with_unit.__init__(self , inherited0__value_component , inherited1__unit_component , )
	def wr1(self):
		eval_wr1_wr = ('CONFIG_CONTROL_DESIGN.SOLID_ANGLE_UNIT'  ==  TYPEOF(self.self.measure_with_unit.self.unit_component))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY person_and_organization_assignment #
####################
class person_and_organization_assignment(BaseEntityClass):
	'''Entity person_and_organization_assignment definition.

	:param assigned_person_and_organization
	:type assigned_person_and_organization:person_and_organization

	:param role
	:type role:person_and_organization_role
	'''
	def __init__( self , assigned_person_and_organization,role, ):
		self._assigned_person_and_organization = assigned_person_and_organization
		self._role = role

	@property
	def assigned_person_and_organization(self):
		return self._assigned_person_and_organization
	@assigned_person_and_organization.setter
	def assigned_person_and_organization(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,person_and_organization):
			self._assigned_person_and_organization = person_and_organization(value)
		else:
			self._assigned_person_and_organization = value

	@property
	def role(self):
		return self._role
	@role.setter
	def role(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,person_and_organization_role):
			self._role = person_and_organization_role(value)
		else:
			self._role = value

####################
 # ENTITY trimmed_curve #
####################
class trimmed_curve(bounded_curve):
	'''Entity trimmed_curve definition.

	:param basis_curve
	:type basis_curve:curve

	:param trim_1
	:type trim_1:SET(1,2,'trimming_select', scope = schema_scope)

	:param trim_2
	:type trim_2:SET(1,2,'trimming_select', scope = schema_scope)

	:param sense_agreement
	:type sense_agreement:BOOLEAN

	:param master_representation
	:type master_representation:trimming_preference
	'''
	def __init__( self , inherited0__name , basis_curve,trim_1,trim_2,sense_agreement,master_representation, ):
		bounded_curve.__init__(self , inherited0__name , )
		self._basis_curve = basis_curve
		self._trim_1 = trim_1
		self._trim_2 = trim_2
		self._sense_agreement = sense_agreement
		self._master_representation = master_representation

	@property
	def basis_curve(self):
		return self._basis_curve
	@basis_curve.setter
	def basis_curve(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,curve):
			self._basis_curve = curve(value)
		else:
			self._basis_curve = value

	@property
	def trim_1(self):
		return self._trim_1
	@trim_1.setter
	def trim_1(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(1,2,'trimming_select', scope = schema_scope)):
			self._trim_1 = SET(value)
		else:
			self._trim_1 = value

	@property
	def trim_2(self):
		return self._trim_2
	@trim_2.setter
	def trim_2(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(1,2,'trimming_select', scope = schema_scope)):
			self._trim_2 = SET(value)
		else:
			self._trim_2 = value

	@property
	def sense_agreement(self):
		return self._sense_agreement
	@sense_agreement.setter
	def sense_agreement(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,BOOLEAN):
			self._sense_agreement = BOOLEAN(value)
		else:
			self._sense_agreement = value

	@property
	def master_representation(self):
		return self._master_representation
	@master_representation.setter
	def master_representation(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,trimming_preference):
			self._master_representation = trimming_preference(value)
		else:
			self._master_representation = value
	def wr1(self):
		eval_wr1_wr = ((HIINDEX(self.trim_1)  ==  1)  or  (TYPEOF(self.trim_1[1])  !=  TYPEOF(self.trim_1[2])))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ((HIINDEX(self.trim_2)  ==  1)  or  (TYPEOF(self.trim_2[1])  !=  TYPEOF(self.trim_2[2])))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY vertex #
####################
class vertex(topological_representation_item):
	'''Entity vertex definition.
	'''
	def __init__( self , inherited0__name ,  ):
		topological_representation_item.__init__(self , inherited0__name , )

####################
 # ENTITY quantified_assembly_component_usage #
####################
class quantified_assembly_component_usage(assembly_component_usage):
	'''Entity quantified_assembly_component_usage definition.

	:param quantity
	:type quantity:measure_with_unit
	'''
	def __init__( self , inherited0__id , inherited1__name , inherited2__description , inherited3__relating_product_definition , inherited4__related_product_definition , inherited5__reference_designator , quantity, ):
		assembly_component_usage.__init__(self , inherited0__id , inherited1__name , inherited2__description , inherited3__relating_product_definition , inherited4__related_product_definition , inherited5__reference_designator , )
		self._quantity = quantity

	@property
	def quantity(self):
		return self._quantity
	@quantity.setter
	def quantity(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,measure_with_unit):
			self._quantity = measure_with_unit(value)
		else:
			self._quantity = value

####################
 # ENTITY product_category_relationship #
####################
class product_category_relationship(BaseEntityClass):
	'''Entity product_category_relationship definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param category
	:type category:product_category

	:param sub_category
	:type sub_category:product_category
	'''
	def __init__( self , name,description,category,sub_category, ):
		self._name = name
		self._description = description
		self._category = category
		self._sub_category = sub_category

	@property
	def name(self):
		return self._name
	@name.setter
	def name(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,label):
			self._name = label(value)
		else:
			self._name = value

	@property
	def description(self):
		return self._description
	@description.setter
	def description(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,text):
			self._description = text(value)
		else:
			self._description = value

	@property
	def category(self):
		return self._category
	@category.setter
	def category(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,product_category):
			self._category = product_category(value)
		else:
			self._category = value

	@property
	def sub_category(self):
		return self._sub_category
	@sub_category.setter
	def sub_category(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,product_category):
			self._sub_category = product_category(value)
		else:
			self._sub_category = value
	def wr1(self):
		eval_wr1_wr = acyclic_product_category_relationship(self,[self.self.sub_category])
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY organization #
####################
class organization(BaseEntityClass):
	'''Entity organization definition.

	:param id
	:type id:identifier

	:param name
	:type name:label

	:param description
	:type description:text
	'''
	def __init__( self , id,name,description, ):
		self._id = id
		self._name = name
		self._description = description

	@property
	def id(self):
		return self._id
	@id.setter
	def id(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,identifier):
				self._id = identifier(value)
			else:
				self._id = value
		else:
			self._id = value

	@property
	def name(self):
		return self._name
	@name.setter
	def name(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,label):
			self._name = label(value)
		else:
			self._name = value

	@property
	def description(self):
		return self._description
	@description.setter
	def description(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,text):
			self._description = text(value)
		else:
			self._description = value

####################
 # ENTITY cartesian_point #
####################
class cartesian_point(point):
	'''Entity cartesian_point definition.

	:param coordinates
	:type coordinates:LIST(1,3,'REAL', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , coordinates, ):
		point.__init__(self , inherited0__name , )
		self._coordinates = coordinates

	@property
	def coordinates(self):
		return self._coordinates
	@coordinates.setter
	def coordinates(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,LIST(1,3,'REAL', scope = schema_scope)):
			self._coordinates = LIST(value)
		else:
			self._coordinates = value

####################
 # ENTITY ellipse #
####################
class ellipse(conic):
	'''Entity ellipse definition.

	:param semi_axis_1
	:type semi_axis_1:positive_length_measure

	:param semi_axis_2
	:type semi_axis_2:positive_length_measure
	'''
	def __init__( self , inherited0__name , inherited1__position , semi_axis_1,semi_axis_2, ):
		conic.__init__(self , inherited0__name , inherited1__position , )
		self._semi_axis_1 = semi_axis_1
		self._semi_axis_2 = semi_axis_2

	@property
	def semi_axis_1(self):
		return self._semi_axis_1
	@semi_axis_1.setter
	def semi_axis_1(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,positive_length_measure):
			self._semi_axis_1 = positive_length_measure(value)
		else:
			self._semi_axis_1 = value

	@property
	def semi_axis_2(self):
		return self._semi_axis_2
	@semi_axis_2.setter
	def semi_axis_2(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,positive_length_measure):
			self._semi_axis_2 = positive_length_measure(value)
		else:
			self._semi_axis_2 = value

####################
 # ENTITY global_uncertainty_assigned_context #
####################
class global_uncertainty_assigned_context(representation_context):
	'''Entity global_uncertainty_assigned_context definition.

	:param uncertainty
	:type uncertainty:SET(1,None,'uncertainty_measure_with_unit', scope = schema_scope)
	'''
	def __init__( self , inherited0__context_identifier , inherited1__context_type , uncertainty, ):
		representation_context.__init__(self , inherited0__context_identifier , inherited1__context_type , )
		self._uncertainty = uncertainty

	@property
	def uncertainty(self):
		return self._uncertainty
	@uncertainty.setter
	def uncertainty(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(1,None,'uncertainty_measure_with_unit', scope = schema_scope)):
			self._uncertainty = SET(value)
		else:
			self._uncertainty = value

####################
 # ENTITY evaluated_degenerate_pcurve #
####################
class evaluated_degenerate_pcurve(degenerate_pcurve):
	'''Entity evaluated_degenerate_pcurve definition.

	:param equivalent_point
	:type equivalent_point:cartesian_point
	'''
	def __init__( self , inherited0__name , inherited1__basis_surface , inherited2__reference_to_curve , equivalent_point, ):
		degenerate_pcurve.__init__(self , inherited0__name , inherited1__basis_surface , inherited2__reference_to_curve , )
		self._equivalent_point = equivalent_point

	@property
	def equivalent_point(self):
		return self._equivalent_point
	@equivalent_point.setter
	def equivalent_point(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,cartesian_point):
			self._equivalent_point = cartesian_point(value)
		else:
			self._equivalent_point = value

####################
 # ENTITY geometrically_bounded_wireframe_shape_representation #
####################
class geometrically_bounded_wireframe_shape_representation(shape_representation):
	'''Entity geometrically_bounded_wireframe_shape_representation definition.
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items ,  ):
		shape_representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  >=  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  0)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(None)  ==  0)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = (SIZEOF(None)  ==  0)
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr

	def wr6(self):
		eval_wr6_wr = (SIZEOF(None)  ==  0)
		if not eval_wr6_wr:
			raise AssertionError('Rule wr6 violated')
		else:
			return eval_wr6_wr

	def wr7(self):
		eval_wr7_wr = (SIZEOF(None)  ==  0)
		if not eval_wr7_wr:
			raise AssertionError('Rule wr7 violated')
		else:
			return eval_wr7_wr


####################
 # ENTITY plane_angle_unit #
####################
class plane_angle_unit(named_unit):
	'''Entity plane_angle_unit definition.
	'''
	def __init__( self , inherited0__dimensions ,  ):
		named_unit.__init__(self , inherited0__dimensions , )
	def wr1(self):
		eval_wr1_wr = (((((((self.self.named_unit.self.dimensions.self.length_exponent  ==  0)  and  (self.self.named_unit.self.dimensions.self.mass_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.time_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.electric_current_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.thermodynamic_temperature_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.amount_of_substance_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.luminous_intensity_exponent  ==  0))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY shell_based_wireframe_model #
####################
class shell_based_wireframe_model(geometric_representation_item):
	'''Entity shell_based_wireframe_model definition.

	:param sbwm_boundary
	:type sbwm_boundary:SET(1,None,'shell', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , sbwm_boundary, ):
		geometric_representation_item.__init__(self , inherited0__name , )
		self._sbwm_boundary = sbwm_boundary

	@property
	def sbwm_boundary(self):
		return self._sbwm_boundary
	@sbwm_boundary.setter
	def sbwm_boundary(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(1,None,'shell', scope = schema_scope)):
			self._sbwm_boundary = SET(value)
		else:
			self._sbwm_boundary = value
	def wr1(self):
		eval_wr1_wr = constraints_geometry_shell_based_wireframe_model(self)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY application_context #
####################
class application_context(BaseEntityClass):
	'''Entity application_context definition.

	:param application
	:type application:text

	:param context_elements
	:type context_elements:SET(1,None,'application_context_element', scope = schema_scope)
	'''
	def __init__( self , application, ):
		self._application = application

	@property
	def application(self):
		return self._application
	@application.setter
	def application(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,text):
			self._application = text(value)
		else:
			self._application = value

	@property
	def context_elements(self):
		return self._context_elements
	@context_elements.setter
	def context_elements(self, value):
	# INVERSE argument
		raise AssertionError('Argument context_elements is INVERSE. It is computed and can not be set to any value')

####################
 # ENTITY open_shell #
####################
class open_shell(connected_face_set):
	'''Entity open_shell definition.
	'''
	def __init__( self , inherited0__name , inherited1__cfs_faces ,  ):
		connected_face_set.__init__(self , inherited0__name , inherited1__cfs_faces , )

####################
 # ENTITY axis2_placement_3d #
####################
class axis2_placement_3d(placement):
	'''Entity axis2_placement_3d definition.

	:param axis
	:type axis:direction

	:param ref_direction
	:type ref_direction:direction

	:param p
	:type p:LIST(3,3,'direction', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__location , axis,ref_direction, ):
		placement.__init__(self , inherited0__name , inherited1__location , )
		self._axis = axis
		self._ref_direction = ref_direction

	def printer(self):
		print '                '+self.location.stepLine
		print '                '+self.axis.stepLine
		if self.ref_direction:
			print '                '+self.ref_direction.stepLine
		 

	@property
	def axis(self):
		return self._axis
	@axis.setter
	def axis(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,direction):
				self._axis = direction(value)
			else:
				self._axis = value
		else:
			self._axis = value

	@property
	def ref_direction(self):
		return self._ref_direction
	@ref_direction.setter
	def ref_direction(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,direction):
				self._ref_direction = direction(value)
			else:
				self._ref_direction = value
		else:
			self._ref_direction = value

	@property
	def p(self):
		attribute_eval = build_axes(self.axis,self.ref_direction)
		return attribute_eval
	@p.setter
	def p(self, value):
	# DERIVED argument
		raise AssertionError('Argument p is DERIVED. It is computed and can not be set to any value')
	def wr1(self):
		eval_wr1_wr = (self.self.placement.self.location.self.dim  ==  3)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (( not EXISTS(self.axis))  or  (self.axis.self.dim  ==  3))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (( not EXISTS(self.ref_direction))  or  (self.ref_direction.self.dim  ==  3))
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = ((( not EXISTS(self.axis))  or  ( not EXISTS(self.ref_direction)))  or  (cross_product(self.axis,self.ref_direction).self.magnitude  >  0))
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr


####################
 # ENTITY security_classification_assignment #
####################
class security_classification_assignment(BaseEntityClass):
	'''Entity security_classification_assignment definition.

	:param assigned_security_classification
	:type assigned_security_classification:security_classification
	'''
	def __init__( self , assigned_security_classification, ):
		self._assigned_security_classification = assigned_security_classification

	@property
	def assigned_security_classification(self):
		return self._assigned_security_classification
	@assigned_security_classification.setter
	def assigned_security_classification(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,security_classification):
			self._assigned_security_classification = security_classification(value)
		else:
			self._assigned_security_classification = value

####################
 # ENTITY cc_design_security_classification #
####################
class cc_design_security_classification(security_classification_assignment):
	'''Entity cc_design_security_classification definition.

	:param items
	:type items:SET(1,None,'classified_item', scope = schema_scope)
	'''
	def __init__( self , inherited0__assigned_security_classification , items, ):
		security_classification_assignment.__init__(self , inherited0__assigned_security_classification , )
		self._items = items

	@property
	def items(self):
		return self._items
	@items.setter
	def items(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(1,None,'classified_item', scope = schema_scope)):
			self._items = SET(value)
		else:
			self._items = value

####################
 # ENTITY curve_replica #
####################
class curve_replica(curve):
	'''Entity curve_replica definition.

	:param parent_curve
	:type parent_curve:curve

	:param transformation
	:type transformation:cartesian_transformation_operator
	'''
	def __init__( self , inherited0__name , parent_curve,transformation, ):
		curve.__init__(self , inherited0__name , )
		self._parent_curve = parent_curve
		self._transformation = transformation

	@property
	def parent_curve(self):
		return self._parent_curve
	@parent_curve.setter
	def parent_curve(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,curve):
			self._parent_curve = curve(value)
		else:
			self._parent_curve = value

	@property
	def transformation(self):
		return self._transformation
	@transformation.setter
	def transformation(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,cartesian_transformation_operator):
			self._transformation = cartesian_transformation_operator(value)
		else:
			self._transformation = value
	def wr1(self):
		eval_wr1_wr = (self.transformation.self.dim  ==  self.parent_curve.self.dim)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = acyclic_curve_replica(self,self.parent_curve)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY vertex_loop #
####################
class vertex_loop(loop):
	'''Entity vertex_loop definition.

	:param loop_vertex
	:type loop_vertex:vertex
	'''
	def __init__( self , inherited0__name , loop_vertex, ):
		loop.__init__(self , inherited0__name , )
		self._loop_vertex = loop_vertex

	@property
	def loop_vertex(self):
		return self._loop_vertex
	@loop_vertex.setter
	def loop_vertex(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,vertex):
			self._loop_vertex = vertex(value)
		else:
			self._loop_vertex = value

####################
 # ENTITY calendar_date #
####################
class calendar_date(date):
	'''Entity calendar_date definition.

	:param day_component
	:type day_component:day_in_month_number

	:param month_component
	:type month_component:month_in_year_number
	'''
	def __init__( self , inherited0__year_component , day_component,month_component, ):
		date.__init__(self , inherited0__year_component , )
		self._day_component = day_component
		self._month_component = month_component

	@property
	def day_component(self):
		return self._day_component
	@day_component.setter
	def day_component(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,day_in_month_number):
			self._day_component = day_in_month_number(value)
		else:
			self._day_component = value

	@property
	def month_component(self):
		return self._month_component
	@month_component.setter
	def month_component(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,month_in_year_number):
			self._month_component = month_in_year_number(value)
		else:
			self._month_component = value
	def wr1(self):
		eval_wr1_wr = valid_calendar_date(self)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY edge_loop #
####################
class edge_loop(loop,path):
	'''Entity edge_loop definition.

	:param ne
	:type ne:INTEGER
	'''
	def __init__( self , inherited0__name , inherited1__name , inherited2__edge_list ,  ):
		loop.__init__(self , inherited0__name , )
		path.__init__(self , inherited1__name , inherited2__edge_list , )

	@property
	def ne(self):
		attribute_eval = SIZEOF(self.self.path.self.edge_list)
		return attribute_eval
	@ne.setter
	def ne(self, value):
	# DERIVED argument
		raise AssertionError('Argument ne is DERIVED. It is computed and can not be set to any value')
	def wr1(self):
		eval_wr1_wr = (self.self.path.self.edge_list[1].self.edge_start  ==  self.self.path.self.edge_list[self.ne].self.edge_end)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY oriented_closed_shell #
####################
class oriented_closed_shell(closed_shell):
	'''Entity oriented_closed_shell definition.

	:param closed_shell_element
	:type closed_shell_element:closed_shell

	:param orientation
	:type orientation:BOOLEAN

	:param connected_face_set_cfs_faces
	:type connected_face_set_cfs_faces:SET(1,None,'face', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__cfs_faces , closed_shell_element,orientation, ):
		closed_shell.__init__(self , inherited0__name , inherited1__cfs_faces , )
		self._closed_shell_element = closed_shell_element
		self._orientation = orientation

	@property
	def closed_shell_element(self):
		return self._closed_shell_element
	@closed_shell_element.setter
	def closed_shell_element(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,closed_shell):
			self._closed_shell_element = closed_shell(value)
		else:
			self._closed_shell_element = value

	@property
	def orientation(self):
		return self._orientation
	@orientation.setter
	def orientation(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,BOOLEAN):
			self._orientation = BOOLEAN(value)
		else:
			self._orientation = value

	@property
	def connected_face_set_cfs_faces(self):
		attribute_eval = conditional_reverse(self.self.orientation,self.self.closed_shell_element.self.cfs_faces)
		return attribute_eval
	@connected_face_set_cfs_faces.setter
	def connected_face_set_cfs_faces(self, value):
	# DERIVED argument
		raise AssertionError('Argument connected_face_set_cfs_faces is DERIVED. It is computed and can not be set to any value')
	def wr1(self):
		eval_wr1_wr = ( not ('CONFIG_CONTROL_DESIGN.ORIENTED_CLOSED_SHELL'  ==  TYPEOF(self.self.closed_shell_element)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY design_make_from_relationship #
####################
class design_make_from_relationship(product_definition_relationship):
	'''Entity design_make_from_relationship definition.
	'''
	def __init__( self , inherited0__id , inherited1__name , inherited2__description , inherited3__relating_product_definition , inherited4__related_product_definition ,  ):
		product_definition_relationship.__init__(self , inherited0__id , inherited1__name , inherited2__description , inherited3__relating_product_definition , inherited4__related_product_definition , )

####################
 # ENTITY shell_based_surface_model #
####################
class shell_based_surface_model(geometric_representation_item):
	'''Entity shell_based_surface_model definition.

	:param sbsm_boundary
	:type sbsm_boundary:SET(1,None,'shell', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , sbsm_boundary, ):
		geometric_representation_item.__init__(self , inherited0__name , )
		self._sbsm_boundary = sbsm_boundary

	@property
	def sbsm_boundary(self):
		return self._sbsm_boundary
	@sbsm_boundary.setter
	def sbsm_boundary(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(1,None,'shell', scope = schema_scope)):
			self._sbsm_boundary = SET(value)
		else:
			self._sbsm_boundary = value
	def wr1(self):
		eval_wr1_wr = constraints_geometry_shell_based_surface_model(self)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY face_bound #
####################
class face_bound(topological_representation_item):
	'''Entity face_bound definition.

	:param bound
	:type bound:loop

	:param orientation
	:type orientation:BOOLEAN
	'''
	def __init__( self , inherited0__name , bound,orientation, ):
		topological_representation_item.__init__(self , inherited0__name , )
		self._bound = bound
		self._orientation = orientation

	@property
	def bound(self):
		return self._bound
	@bound.setter
	def bound(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,loop):
			self._bound = loop(value)
		else:
			self._bound = value

	@property
	def orientation(self):
		return self._orientation
	@orientation.setter
	def orientation(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,BOOLEAN):
			self._orientation = BOOLEAN(value)
		else:
			self._orientation = value

####################
 # ENTITY representation_relationship_with_transformation #
####################
class representation_relationship_with_transformation(representation_relationship):
	'''Entity representation_relationship_with_transformation definition.

	:param transformation_operator
	:type transformation_operator:transformation
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__rep_1 , inherited3__rep_2 , transformation_operator, ):
		representation_relationship.__init__(self , inherited0__name , inherited1__description , inherited2__rep_1 , inherited3__rep_2 , )
		self._transformation_operator = transformation_operator

	@property
	def transformation_operator(self):
		return self._transformation_operator
	@transformation_operator.setter
	def transformation_operator(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,transformation):
			self._transformation_operator = transformation(value)
		else:
			self._transformation_operator = value
	def wr1(self):
		eval_wr1_wr = (self.self.representation_relationship.self.rep_1.self.context_of_items  !=  self.self.representation_relationship.self.rep_2.self.context_of_items)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY oriented_face #
####################
class oriented_face(face):
	'''Entity oriented_face definition.

	:param face_element
	:type face_element:face

	:param orientation
	:type orientation:BOOLEAN

	:param face_bounds
	:type face_bounds:SET(1,None,'face_bound', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__bounds , face_element,orientation, ):
		face.__init__(self , inherited0__name , inherited1__bounds , )
		self._face_element = face_element
		self._orientation = orientation

	@property
	def face_element(self):
		return self._face_element
	@face_element.setter
	def face_element(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,face):
			self._face_element = face(value)
		else:
			self._face_element = value

	@property
	def orientation(self):
		return self._orientation
	@orientation.setter
	def orientation(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,BOOLEAN):
			self._orientation = BOOLEAN(value)
		else:
			self._orientation = value

	@property
	def face_bounds(self):
		attribute_eval = conditional_reverse(self.self.orientation,self.self.face_element.self.bounds)
		return attribute_eval
	@face_bounds.setter
	def face_bounds(self, value):
	# DERIVED argument
		raise AssertionError('Argument face_bounds is DERIVED. It is computed and can not be set to any value')
	def wr1(self):
		eval_wr1_wr = ( not ('CONFIG_CONTROL_DESIGN.ORIENTED_FACE'  ==  TYPEOF(self.self.face_element)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY contract_type #
####################
class contract_type(BaseEntityClass):
	'''Entity contract_type definition.

	:param description
	:type description:label
	'''
	def __init__( self , description, ):
		self._description = description

	@property
	def description(self):
		return self._description
	@description.setter
	def description(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,label):
			self._description = label(value)
		else:
			self._description = value

####################
 # ENTITY pcurve #
####################
class pcurve(curve):
	'''Entity pcurve definition.

	:param basis_surface
	:type basis_surface:surface

	:param reference_to_curve
	:type reference_to_curve:definitional_representation
	'''
	def __init__( self , inherited0__name , basis_surface,reference_to_curve, ):
		curve.__init__(self , inherited0__name , )
		self._basis_surface = basis_surface
		self._reference_to_curve = reference_to_curve

	@property
	def basis_surface(self):
		return self._basis_surface
	@basis_surface.setter
	def basis_surface(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,surface):
			self._basis_surface = surface(value)
		else:
			self._basis_surface = value

	@property
	def reference_to_curve(self):
		return self._reference_to_curve
	@reference_to_curve.setter
	def reference_to_curve(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,definitional_representation):
			self._reference_to_curve = definitional_representation(value)
		else:
			self._reference_to_curve = value
	def wr1(self):
		eval_wr1_wr = (SIZEOF(self.reference_to_curve.self.representation.self.items)  ==  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = ('CONFIG_CONTROL_DESIGN.CURVE'  ==  TYPEOF(self.reference_to_curve.self.representation.self.items[1]))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (self.reference_to_curve.self.representation.self.items[1].self.geometric_representation_item.self.dim  ==  2)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr


####################
 # ENTITY bounded_pcurve #
####################
class bounded_pcurve(pcurve,bounded_curve):
	'''Entity bounded_pcurve definition.
	'''
	def __init__( self , inherited0__name , inherited1__basis_surface , inherited2__reference_to_curve , inherited3__name ,  ):
		pcurve.__init__(self , inherited0__name , inherited1__basis_surface , inherited2__reference_to_curve , )
		bounded_curve.__init__(self , inherited3__name , )
	def wr1(self):
		eval_wr1_wr = ('CONFIG_CONTROL_DESIGN.BOUNDED_CURVE'  ==  TYPEOF(self.self.pcurve.self.reference_to_curve.self.items[1]))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY certification_assignment #
####################
class certification_assignment(BaseEntityClass):
	'''Entity certification_assignment definition.

	:param assigned_certification
	:type assigned_certification:certification
	'''
	def __init__( self , assigned_certification, ):
		self._assigned_certification = assigned_certification

	@property
	def assigned_certification(self):
		return self._assigned_certification
	@assigned_certification.setter
	def assigned_certification(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,certification):
			self._assigned_certification = certification(value)
		else:
			self._assigned_certification = value

####################
 # ENTITY cc_design_certification #
####################
class cc_design_certification(certification_assignment):
	'''Entity cc_design_certification definition.

	:param items
	:type items:SET(1,None,'certified_item', scope = schema_scope)
	'''
	def __init__( self , inherited0__assigned_certification , items, ):
		certification_assignment.__init__(self , inherited0__assigned_certification , )
		self._items = items

	@property
	def items(self):
		return self._items
	@items.setter
	def items(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(1,None,'certified_item', scope = schema_scope)):
			self._items = SET(value)
		else:
			self._items = value

####################
 # ENTITY plane #
####################
class plane(elementary_surface):
	'''Entity plane definition.
	'''
	def __init__( self , inherited0__name , inherited1__position ,  ):
		elementary_surface.__init__(self , inherited0__name , inherited1__position , )

	def printer(self):
		print '    '+self.stepLine
		print '      '+self.position.stepLine
		self.position.printer()

####################
 # ENTITY change #
####################
class change(action_assignment):
	'''Entity change definition.

	:param items
	:type items:SET(1,None,'work_item', scope = schema_scope)
	'''
	def __init__( self , inherited0__assigned_action , items, ):
		action_assignment.__init__(self , inherited0__assigned_action , )
		self._items = items

	@property
	def items(self):
		return self._items
	@items.setter
	def items(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(1,None,'work_item', scope = schema_scope)):
			self._items = SET(value)
		else:
			self._items = value

####################
 # ENTITY circle #
####################
class circle(conic):
	'''Entity circle definition.

	:param radius
	:type radius:positive_length_measure
	'''
	def __init__( self , inherited0__name , inherited1__position , radius, ):
		conic.__init__(self , inherited0__name , inherited1__position , )
		self._radius = radius

	def printer(self):
		print '              '+self.position.stepLine
		self.position.printer()

	@property
	def radius(self):
		return self._radius
	@radius.setter
	def radius(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,positive_length_measure):
			self._radius = positive_length_measure(value)
		else:
			self._radius = value

####################
 # ENTITY line #
####################
class line(curve):
	'''Entity line definition.

	:param pnt
	:type pnt:cartesian_point

	:param dir
	:type dir:vector
	'''
	def __init__( self , inherited0__name , pnt,dir, ):
		curve.__init__(self , inherited0__name , )
		self._pnt = pnt
		self._dir = dir

	def printer(self):
		print '              '+self.pnt.stepLine
		print '              '+self.dir.stepLine

	@property
	def pnt(self):
		return self._pnt
	@pnt.setter
	def pnt(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,cartesian_point):
			self._pnt = cartesian_point(value)
		else:
			self._pnt = value

	@property
	def dir(self):
		return self._dir
	@dir.setter
	def dir(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,vector):
			self._dir = vector(value)
		else:
			self._dir = value
	def wr1(self):
		eval_wr1_wr = (self.dir.self.dim  ==  self.pnt.self.dim)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY contract #
####################
class contract(BaseEntityClass):
	'''Entity contract definition.

	:param name
	:type name:label

	:param purpose
	:type purpose:text

	:param kind
	:type kind:contract_type
	'''
	def __init__( self , name,purpose,kind, ):
		self._name = name
		self._purpose = purpose
		self._kind = kind

	@property
	def name(self):
		return self._name
	@name.setter
	def name(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,label):
			self._name = label(value)
		else:
			self._name = value

	@property
	def purpose(self):
		return self._purpose
	@purpose.setter
	def purpose(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,text):
			self._purpose = text(value)
		else:
			self._purpose = value

	@property
	def kind(self):
		return self._kind
	@kind.setter
	def kind(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,contract_type):
			self._kind = contract_type(value)
		else:
			self._kind = value

####################
 # ENTITY product_definition_effectivity #
####################
class product_definition_effectivity(effectivity):
	'''Entity product_definition_effectivity definition.

	:param usage
	:type usage:product_definition_relationship
	'''
	def __init__( self , inherited0__id , usage, ):
		effectivity.__init__(self , inherited0__id , )
		self._usage = usage

	@property
	def usage(self):
		return self._usage
	@usage.setter
	def usage(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,product_definition_relationship):
			self._usage = product_definition_relationship(value)
		else:
			self._usage = value

####################
 # ENTITY configuration_effectivity #
####################
class configuration_effectivity(product_definition_effectivity):
	'''Entity configuration_effectivity definition.

	:param configuration
	:type configuration:configuration_design
	'''
	def __init__( self , inherited0__id , inherited1__usage , configuration, ):
		product_definition_effectivity.__init__(self , inherited0__id , inherited1__usage , )
		self._configuration = configuration

	@property
	def configuration(self):
		return self._configuration
	@configuration.setter
	def configuration(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,configuration_design):
			self._configuration = configuration_design(value)
		else:
			self._configuration = value
	def wr1(self):
		eval_wr1_wr = ('CONFIG_CONTROL_DESIGN.PRODUCT_DEFINITION_USAGE'  ==  TYPEOF(self.self.product_definition_effectivity.self.usage))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY product #
####################
class product(BaseEntityClass):
	'''Entity product definition.

	:param id
	:type id:identifier

	:param name
	:type name:label

	:param description
	:type description:text

	:param frame_of_reference
	:type frame_of_reference:SET(1,None,'product_context', scope = schema_scope)
	'''
	def __init__( self , id,name,description,frame_of_reference, ):
		self._id = id
		self._name = name
		self._description = description
		self._frame_of_reference = frame_of_reference

	@property
	def id(self):
		return self._id
	@id.setter
	def id(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,identifier):
			self._id = identifier(value)
		else:
			self._id = value

	@property
	def name(self):
		return self._name
	@name.setter
	def name(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,label):
			self._name = label(value)
		else:
			self._name = value

	@property
	def description(self):
		return self._description
	@description.setter
	def description(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,text):
			self._description = text(value)
		else:
			self._description = value

	@property
	def frame_of_reference(self):
		return self._frame_of_reference
	@frame_of_reference.setter
	def frame_of_reference(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(1,None,'product_context', scope = schema_scope)):
			self._frame_of_reference = SET(value)
		else:
			self._frame_of_reference = value

####################
 # ENTITY document_relationship #
####################
class document_relationship(BaseEntityClass):
	'''Entity document_relationship definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param relating_document
	:type relating_document:document

	:param related_document
	:type related_document:document
	'''
	def __init__( self , name,description,relating_document,related_document, ):
		self._name = name
		self._description = description
		self._relating_document = relating_document
		self._related_document = related_document

	@property
	def name(self):
		return self._name
	@name.setter
	def name(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,label):
			self._name = label(value)
		else:
			self._name = value

	@property
	def description(self):
		return self._description
	@description.setter
	def description(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,text):
			self._description = text(value)
		else:
			self._description = value

	@property
	def relating_document(self):
		return self._relating_document
	@relating_document.setter
	def relating_document(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,document):
			self._relating_document = document(value)
		else:
			self._relating_document = value

	@property
	def related_document(self):
		return self._related_document
	@related_document.setter
	def related_document(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,document):
			self._related_document = document(value)
		else:
			self._related_document = value

####################
 # ENTITY versioned_action_request #
####################
class versioned_action_request(BaseEntityClass):
	'''Entity versioned_action_request definition.

	:param id
	:type id:identifier

	:param version
	:type version:label

	:param purpose
	:type purpose:text

	:param description
	:type description:text
	'''
	def __init__( self , id,version,purpose,description, ):
		self._id = id
		self._version = version
		self._purpose = purpose
		self._description = description

	@property
	def id(self):
		return self._id
	@id.setter
	def id(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,identifier):
			self._id = identifier(value)
		else:
			self._id = value

	@property
	def version(self):
		return self._version
	@version.setter
	def version(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,label):
			self._version = label(value)
		else:
			self._version = value

	@property
	def purpose(self):
		return self._purpose
	@purpose.setter
	def purpose(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,text):
			self._purpose = text(value)
		else:
			self._purpose = value

	@property
	def description(self):
		return self._description
	@description.setter
	def description(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,text):
			self._description = text(value)
		else:
			self._description = value

####################
 # ENTITY face_outer_bound #
####################
class face_outer_bound(face_bound):
	'''Entity face_outer_bound definition.
	'''
	def __init__( self , inherited0__name , inherited1__bound , inherited2__orientation ,  ):
		face_bound.__init__(self , inherited0__name , inherited1__bound , inherited2__orientation , )

####################
 # ENTITY organizational_project #
####################
class organizational_project(BaseEntityClass):
	'''Entity organizational_project definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param responsible_organizations
	:type responsible_organizations:SET(1,None,'organization', scope = schema_scope)
	'''
	def __init__( self , name,description,responsible_organizations, ):
		self._name = name
		self._description = description
		self._responsible_organizations = responsible_organizations

	@property
	def name(self):
		return self._name
	@name.setter
	def name(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,label):
			self._name = label(value)
		else:
			self._name = value

	@property
	def description(self):
		return self._description
	@description.setter
	def description(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,text):
			self._description = text(value)
		else:
			self._description = value

	@property
	def responsible_organizations(self):
		return self._responsible_organizations
	@responsible_organizations.setter
	def responsible_organizations(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(1,None,'organization', scope = schema_scope)):
			self._responsible_organizations = SET(value)
		else:
			self._responsible_organizations = value

####################
 # ENTITY ordinal_date #
####################
class ordinal_date(date):
	'''Entity ordinal_date definition.

	:param day_component
	:type day_component:day_in_year_number
	'''
	def __init__( self , inherited0__year_component , day_component, ):
		date.__init__(self , inherited0__year_component , )
		self._day_component = day_component

	@property
	def day_component(self):
		return self._day_component
	@day_component.setter
	def day_component(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,day_in_year_number):
			self._day_component = day_in_year_number(value)
		else:
			self._day_component = value
	def wr1(self):
		eval_wr1_wr = (((( not leap_year(self.self.year_component))  and  (1  <=  self.day_component))  and  (self.day_component  <=  365))  or  ((leap_year(self.self.year_component)  and  (1  <=  self.day_component))  and  (self.day_component  <=  366)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY rectangular_trimmed_surface #
####################
class rectangular_trimmed_surface(bounded_surface):
	'''Entity rectangular_trimmed_surface definition.

	:param basis_surface
	:type basis_surface:surface

	:param u1
	:type u1:parameter_value

	:param u2
	:type u2:parameter_value

	:param v1
	:type v1:parameter_value

	:param v2
	:type v2:parameter_value

	:param usense
	:type usense:BOOLEAN

	:param vsense
	:type vsense:BOOLEAN
	'''
	def __init__( self , inherited0__name , basis_surface,u1,u2,v1,v2,usense,vsense, ):
		bounded_surface.__init__(self , inherited0__name , )
		self._basis_surface = basis_surface
		self._u1 = u1
		self._u2 = u2
		self._v1 = v1
		self._v2 = v2
		self._usense = usense
		self._vsense = vsense

	@property
	def basis_surface(self):
		return self._basis_surface
	@basis_surface.setter
	def basis_surface(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,surface):
			self._basis_surface = surface(value)
		else:
			self._basis_surface = value

	@property
	def u1(self):
		return self._u1
	@u1.setter
	def u1(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,parameter_value):
			self._u1 = parameter_value(value)
		else:
			self._u1 = value

	@property
	def u2(self):
		return self._u2
	@u2.setter
	def u2(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,parameter_value):
			self._u2 = parameter_value(value)
		else:
			self._u2 = value

	@property
	def v1(self):
		return self._v1
	@v1.setter
	def v1(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,parameter_value):
			self._v1 = parameter_value(value)
		else:
			self._v1 = value

	@property
	def v2(self):
		return self._v2
	@v2.setter
	def v2(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,parameter_value):
			self._v2 = parameter_value(value)
		else:
			self._v2 = value

	@property
	def usense(self):
		return self._usense
	@usense.setter
	def usense(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,BOOLEAN):
			self._usense = BOOLEAN(value)
		else:
			self._usense = value

	@property
	def vsense(self):
		return self._vsense
	@vsense.setter
	def vsense(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,BOOLEAN):
			self._vsense = BOOLEAN(value)
		else:
			self._vsense = value
	def wr1(self):
		eval_wr1_wr = (self.u1  !=  self.u2)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (self.v1  !=  self.v2)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (((('CONFIG_CONTROL_DESIGN.ELEMENTARY_SURFACE'  ==  TYPEOF(self.basis_surface))  and  ( not ('CONFIG_CONTROL_DESIGN.PLANE'  ==  TYPEOF(self.basis_surface))))  or  ('CONFIG_CONTROL_DESIGN.SURFACE_OF_REVOLUTION'  ==  TYPEOF(self.basis_surface)))  or  (self.usense  ==  (self.u2  >  self.u1)))
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = ((('CONFIG_CONTROL_DESIGN.SPHERICAL_SURFACE'  ==  TYPEOF(self.basis_surface))  or  ('CONFIG_CONTROL_DESIGN.TOROIDAL_SURFACE'  ==  TYPEOF(self.basis_surface)))  or  (self.vsense  ==  (self.v2  >  self.v1)))
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr


####################
 # ENTITY cc_design_person_and_organization_assignment #
####################
class cc_design_person_and_organization_assignment(person_and_organization_assignment):
	'''Entity cc_design_person_and_organization_assignment definition.

	:param items
	:type items:SET(1,None,'person_organization_item', scope = schema_scope)
	'''
	def __init__( self , inherited0__assigned_person_and_organization , inherited1__role , items, ):
		person_and_organization_assignment.__init__(self , inherited0__assigned_person_and_organization , inherited1__role , )
		self._items = items

	@property
	def items(self):
		return self._items
	@items.setter
	def items(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(1,None,'person_organization_item', scope = schema_scope)):
			self._items = SET(value)
		else:
			self._items = value
	def wr1(self):
		eval_wr1_wr = cc_design_person_and_organization_correlation(self)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY definitional_representation #
####################
class definitional_representation(representation):
	'''Entity definitional_representation definition.
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items ,  ):
		representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )
	def wr1(self):
		eval_wr1_wr = ('CONFIG_CONTROL_DESIGN.PARAMETRIC_REPRESENTATION_CONTEXT'  ==  TYPEOF(self.self.representation.self.context_of_items))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY approval_person_organization #
####################
class approval_person_organization(BaseEntityClass):
	'''Entity approval_person_organization definition.

	:param person_organization
	:type person_organization:person_organization_select

	:param authorized_approval
	:type authorized_approval:approval

	:param role
	:type role:approval_role
	'''
	def __init__( self , person_organization,authorized_approval,role, ):
		self._person_organization = person_organization
		self._authorized_approval = authorized_approval
		self._role = role

	@property
	def person_organization(self):
		return self._person_organization
	@person_organization.setter
	def person_organization(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,person_organization_select):
			self._person_organization = person_organization_select(value)
		else:
			self._person_organization = value

	@property
	def authorized_approval(self):
		return self._authorized_approval
	@authorized_approval.setter
	def authorized_approval(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,approval):
			self._authorized_approval = approval(value)
		else:
			self._authorized_approval = value

	@property
	def role(self):
		return self._role
	@role.setter
	def role(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,approval_role):
			self._role = approval_role(value)
		else:
			self._role = value

####################
 # ENTITY curve_bounded_surface #
####################
class curve_bounded_surface(bounded_surface):
	'''Entity curve_bounded_surface definition.

	:param basis_surface
	:type basis_surface:surface

	:param boundaries
	:type boundaries:SET(1,None,'boundary_curve', scope = schema_scope)

	:param implicit_outer
	:type implicit_outer:BOOLEAN
	'''
	def __init__( self , inherited0__name , basis_surface,boundaries,implicit_outer, ):
		bounded_surface.__init__(self , inherited0__name , )
		self._basis_surface = basis_surface
		self._boundaries = boundaries
		self._implicit_outer = implicit_outer

	@property
	def basis_surface(self):
		return self._basis_surface
	@basis_surface.setter
	def basis_surface(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,surface):
			self._basis_surface = surface(value)
		else:
			self._basis_surface = value

	@property
	def boundaries(self):
		return self._boundaries
	@boundaries.setter
	def boundaries(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(1,None,'boundary_curve', scope = schema_scope)):
			self._boundaries = SET(value)
		else:
			self._boundaries = value

	@property
	def implicit_outer(self):
		return self._implicit_outer
	@implicit_outer.setter
	def implicit_outer(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,BOOLEAN):
			self._implicit_outer = BOOLEAN(value)
		else:
			self._implicit_outer = value
	def wr1(self):
		eval_wr1_wr = ( not (self.implicit_outer  and  ('CONFIG_CONTROL_DESIGN.OUTER_BOUNDARY_CURVE'  ==  TYPEOF(self.boundaries))))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (( not self.implicit_outer)  or  ('CONFIG_CONTROL_DESIGN.BOUNDED_SURFACE'  ==  TYPEOF(self.basis_surface)))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  <=  1)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(None)  ==  0)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr


####################
 # ENTITY parabola #
####################
class parabola(conic):
	'''Entity parabola definition.

	:param focal_dist
	:type focal_dist:length_measure
	'''
	def __init__( self , inherited0__name , inherited1__position , focal_dist, ):
		conic.__init__(self , inherited0__name , inherited1__position , )
		self._focal_dist = focal_dist

	@property
	def focal_dist(self):
		return self._focal_dist
	@focal_dist.setter
	def focal_dist(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,length_measure):
			self._focal_dist = length_measure(value)
		else:
			self._focal_dist = value
	def wr1(self):
		eval_wr1_wr = (self.focal_dist  !=  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY quasi_uniform_curve #
####################
class quasi_uniform_curve(b_spline_curve):
	'''Entity quasi_uniform_curve definition.
	'''
	def __init__( self , inherited0__name , inherited1__degree , inherited2__control_points_list , inherited3__curve_form , inherited4__closed_curve , inherited5__self_intersect ,  ):
		b_spline_curve.__init__(self , inherited0__name , inherited1__degree , inherited2__control_points_list , inherited3__curve_form , inherited4__closed_curve , inherited5__self_intersect , )

####################
 # ENTITY uncertainty_measure_with_unit #
####################
class uncertainty_measure_with_unit(measure_with_unit):
	'''Entity uncertainty_measure_with_unit definition.

	:param name
	:type name:label

	:param description
	:type description:text
	'''
	def __init__( self , inherited0__value_component , inherited1__unit_component , name,description, ):
		measure_with_unit.__init__(self , inherited0__value_component , inherited1__unit_component , )
		self._name = name
		self._description = description

	@property
	def name(self):
		return self._name
	@name.setter
	def name(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,label):
			self._name = label(value)
		else:
			self._name = value

	@property
	def description(self):
		return self._description
	@description.setter
	def description(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,text):
			self._description = text(value)
		else:
			self._description = value
	def wr1(self):
		eval_wr1_wr = valid_measure_value(self.self.measure_with_unit.self.value_component)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY uniform_curve #
####################
class uniform_curve(b_spline_curve):
	'''Entity uniform_curve definition.
	'''
	def __init__( self , inherited0__name , inherited1__degree , inherited2__control_points_list , inherited3__curve_form , inherited4__closed_curve , inherited5__self_intersect ,  ):
		b_spline_curve.__init__(self , inherited0__name , inherited1__degree , inherited2__control_points_list , inherited3__curve_form , inherited4__closed_curve , inherited5__self_intersect , )

####################
 # ENTITY geometric_curve_set #
####################
class geometric_curve_set(geometric_set):
	'''Entity geometric_curve_set definition.
	'''
	def __init__( self , inherited0__name , inherited1__elements ,  ):
		geometric_set.__init__(self , inherited0__name , inherited1__elements , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY length_unit #
####################
class length_unit(named_unit):
	'''Entity length_unit definition.
	'''
	def __init__( self , inherited0__dimensions ,  ):
		named_unit.__init__(self , inherited0__dimensions , )
	def wr1(self):
		eval_wr1_wr = (((((((self.self.named_unit.self.dimensions.self.length_exponent  ==  1)  and  (self.self.named_unit.self.dimensions.self.mass_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.time_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.electric_current_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.thermodynamic_temperature_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.amount_of_substance_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.luminous_intensity_exponent  ==  0))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY length_measure_with_unit #
####################
class length_measure_with_unit(measure_with_unit):
	'''Entity length_measure_with_unit definition.
	'''
	def __init__( self , inherited0__value_component , inherited1__unit_component ,  ):
		measure_with_unit.__init__(self , inherited0__value_component , inherited1__unit_component , )
	def wr1(self):
		eval_wr1_wr = ('CONFIG_CONTROL_DESIGN.LENGTH_UNIT'  ==  TYPEOF(self.self.measure_with_unit.self.unit_component))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY product_concept_context #
####################
class product_concept_context(application_context_element):
	'''Entity product_concept_context definition.

	:param market_segment_type
	:type market_segment_type:label
	'''
	def __init__( self , inherited0__name , inherited1__frame_of_reference , market_segment_type, ):
		application_context_element.__init__(self , inherited0__name , inherited1__frame_of_reference , )
		self._market_segment_type = market_segment_type

	@property
	def market_segment_type(self):
		return self._market_segment_type
	@market_segment_type.setter
	def market_segment_type(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,label):
			self._market_segment_type = label(value)
		else:
			self._market_segment_type = value

####################
 # ENTITY rational_b_spline_surface #
####################
class rational_b_spline_surface(b_spline_surface):
	'''Entity rational_b_spline_surface definition.

	:param weights_data
	:type weights_data:LIST(2,None,LIST(2,None,'REAL', scope = schema_scope))

	:param weights
	:type weights:ARRAY(0,u_upper,ARRAY(0,v_upper,'REAL', scope = schema_scope))
	'''
	def __init__( self , inherited0__name , inherited1__u_degree , inherited2__v_degree , inherited3__control_points_list , inherited4__surface_form , inherited5__u_closed , inherited6__v_closed , inherited7__self_intersect , weights_data, ):
		b_spline_surface.__init__(self , inherited0__name , inherited1__u_degree , inherited2__v_degree , inherited3__control_points_list , inherited4__surface_form , inherited5__u_closed , inherited6__v_closed , inherited7__self_intersect , )
		self._weights_data = weights_data

	@property
	def weights_data(self):
		return self._weights_data
	@weights_data.setter
	def weights_data(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,LIST(2,None,LIST(2,None,'REAL', scope = schema_scope))):
			self._weights_data = LIST(value)
		else:
			self._weights_data = value

	@property
	def weights(self):
		attribute_eval = make_array_of_array(self.weights_data,0,self.u_upper,0,self.v_upper)
		return attribute_eval
	@weights.setter
	def weights(self, value):
	# DERIVED argument
		raise AssertionError('Argument weights is DERIVED. It is computed and can not be set to any value')
	def wr1(self):
		eval_wr1_wr = ((SIZEOF(self.weights_data)  ==  SIZEOF(self.self.b_spline_surface.self.control_points_list))  and  (SIZEOF(self.weights_data[1])  ==  SIZEOF(self.self.b_spline_surface.self.control_points_list[1])))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = surface_weights_positive(self)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY local_time #
####################
class local_time(BaseEntityClass):
	'''Entity local_time definition.

	:param hour_component
	:type hour_component:hour_in_day

	:param minute_component
	:type minute_component:minute_in_hour

	:param second_component
	:type second_component:second_in_minute

	:param zone
	:type zone:coordinated_universal_time_offset
	'''
	def __init__( self , hour_component,minute_component,second_component,zone, ):
		self._hour_component = hour_component
		self._minute_component = minute_component
		self._second_component = second_component
		self._zone = zone

	@property
	def hour_component(self):
		return self._hour_component
	@hour_component.setter
	def hour_component(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,hour_in_day):
			self._hour_component = hour_in_day(value)
		else:
			self._hour_component = value

	@property
	def minute_component(self):
		return self._minute_component
	@minute_component.setter
	def minute_component(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,minute_in_hour):
				self._minute_component = minute_in_hour(value)
			else:
				self._minute_component = value
		else:
			self._minute_component = value

	@property
	def second_component(self):
		return self._second_component
	@second_component.setter
	def second_component(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,second_in_minute):
				self._second_component = second_in_minute(value)
			else:
				self._second_component = value
		else:
			self._second_component = value

	@property
	def zone(self):
		return self._zone
	@zone.setter
	def zone(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,coordinated_universal_time_offset):
			self._zone = coordinated_universal_time_offset(value)
		else:
			self._zone = value
	def wr1(self):
		eval_wr1_wr = valid_time(self)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY next_assembly_usage_occurrence #
####################
class next_assembly_usage_occurrence(assembly_component_usage):
	'''Entity next_assembly_usage_occurrence definition.
	'''
	def __init__( self , inherited0__id , inherited1__name , inherited2__description , inherited3__relating_product_definition , inherited4__related_product_definition , inherited5__reference_designator ,  ):
		assembly_component_usage.__init__(self , inherited0__id , inherited1__name , inherited2__description , inherited3__relating_product_definition , inherited4__related_product_definition , inherited5__reference_designator , )

####################
 # ENTITY conversion_based_unit #
####################
class conversion_based_unit(named_unit):
	'''Entity conversion_based_unit definition.

	:param name
	:type name:label

	:param conversion_factor
	:type conversion_factor:measure_with_unit
	'''
	def __init__( self , inherited0__dimensions , name,conversion_factor, ):
		named_unit.__init__(self , inherited0__dimensions , )
		self._name = name
		self._conversion_factor = conversion_factor

	@property
	def name(self):
		return self._name
	@name.setter
	def name(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,label):
			self._name = label(value)
		else:
			self._name = value

	@property
	def conversion_factor(self):
		return self._conversion_factor
	@conversion_factor.setter
	def conversion_factor(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,measure_with_unit):
			self._conversion_factor = measure_with_unit(value)
		else:
			self._conversion_factor = value

####################
 # ENTITY vertex_point #
####################
class vertex_point(vertex,geometric_representation_item):
	'''Entity vertex_point definition.

	:param vertex_geometry
	:type vertex_geometry:point
	'''
	def __init__( self , inherited0__name , inherited1__name , vertex_geometry, ):
		vertex.__init__(self , inherited0__name , )
		geometric_representation_item.__init__(self , inherited1__name , )
		self._vertex_geometry = vertex_geometry

	@property
	def vertex_geometry(self):
		return self._vertex_geometry
	@vertex_geometry.setter
	def vertex_geometry(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,point):
			self._vertex_geometry = point(value)
		else:
			self._vertex_geometry = value

####################
 # ENTITY dimensional_exponents #
####################
class dimensional_exponents(BaseEntityClass):
	'''Entity dimensional_exponents definition.

	:param length_exponent
	:type length_exponent:REAL

	:param mass_exponent
	:type mass_exponent:REAL

	:param time_exponent
	:type time_exponent:REAL

	:param electric_current_exponent
	:type electric_current_exponent:REAL

	:param thermodynamic_temperature_exponent
	:type thermodynamic_temperature_exponent:REAL

	:param amount_of_substance_exponent
	:type amount_of_substance_exponent:REAL

	:param luminous_intensity_exponent
	:type luminous_intensity_exponent:REAL
	'''
	def __init__( self , length_exponent,mass_exponent,time_exponent,electric_current_exponent,thermodynamic_temperature_exponent,amount_of_substance_exponent,luminous_intensity_exponent, ):
		self._length_exponent = length_exponent
		self._mass_exponent = mass_exponent
		self._time_exponent = time_exponent
		self._electric_current_exponent = electric_current_exponent
		self._thermodynamic_temperature_exponent = thermodynamic_temperature_exponent
		self._amount_of_substance_exponent = amount_of_substance_exponent
		self._luminous_intensity_exponent = luminous_intensity_exponent

	@property
	def length_exponent(self):
		return self._length_exponent
	@length_exponent.setter
	def length_exponent(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,REAL):
			self._length_exponent = REAL(value)
		else:
			self._length_exponent = value

	@property
	def mass_exponent(self):
		return self._mass_exponent
	@mass_exponent.setter
	def mass_exponent(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,REAL):
			self._mass_exponent = REAL(value)
		else:
			self._mass_exponent = value

	@property
	def time_exponent(self):
		return self._time_exponent
	@time_exponent.setter
	def time_exponent(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,REAL):
			self._time_exponent = REAL(value)
		else:
			self._time_exponent = value

	@property
	def electric_current_exponent(self):
		return self._electric_current_exponent
	@electric_current_exponent.setter
	def electric_current_exponent(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,REAL):
			self._electric_current_exponent = REAL(value)
		else:
			self._electric_current_exponent = value

	@property
	def thermodynamic_temperature_exponent(self):
		return self._thermodynamic_temperature_exponent
	@thermodynamic_temperature_exponent.setter
	def thermodynamic_temperature_exponent(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,REAL):
			self._thermodynamic_temperature_exponent = REAL(value)
		else:
			self._thermodynamic_temperature_exponent = value

	@property
	def amount_of_substance_exponent(self):
		return self._amount_of_substance_exponent
	@amount_of_substance_exponent.setter
	def amount_of_substance_exponent(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,REAL):
			self._amount_of_substance_exponent = REAL(value)
		else:
			self._amount_of_substance_exponent = value

	@property
	def luminous_intensity_exponent(self):
		return self._luminous_intensity_exponent
	@luminous_intensity_exponent.setter
	def luminous_intensity_exponent(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,REAL):
			self._luminous_intensity_exponent = REAL(value)
		else:
			self._luminous_intensity_exponent = value

####################
 # ENTITY product_context #
####################
class product_context(application_context_element):
	'''Entity product_context definition.

	:param discipline_type
	:type discipline_type:label
	'''
	def __init__( self , inherited0__name , inherited1__frame_of_reference , discipline_type, ):
		application_context_element.__init__(self , inherited0__name , inherited1__frame_of_reference , )
		self._discipline_type = discipline_type

	@property
	def discipline_type(self):
		return self._discipline_type
	@discipline_type.setter
	def discipline_type(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,label):
			self._discipline_type = label(value)
		else:
			self._discipline_type = value

####################
 # ENTITY offset_surface #
####################
class offset_surface(surface):
	'''Entity offset_surface definition.

	:param basis_surface
	:type basis_surface:surface

	:param distance
	:type distance:length_measure

	:param self_intersect
	:type self_intersect:LOGICAL
	'''
	def __init__( self , inherited0__name , basis_surface,distance,self_intersect, ):
		surface.__init__(self , inherited0__name , )
		self._basis_surface = basis_surface
		self._distance = distance
		self._self_intersect = self_intersect

	@property
	def basis_surface(self):
		return self._basis_surface
	@basis_surface.setter
	def basis_surface(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,surface):
			self._basis_surface = surface(value)
		else:
			self._basis_surface = value

	@property
	def distance(self):
		return self._distance
	@distance.setter
	def distance(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,length_measure):
			self._distance = length_measure(value)
		else:
			self._distance = value

	@property
	def self_intersect(self):
		return self._self_intersect
	@self_intersect.setter
	def self_intersect(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,LOGICAL):
			self._self_intersect = LOGICAL(value)
		else:
			self._self_intersect = value

####################
 # ENTITY context_dependent_shape_representation #
####################
class context_dependent_shape_representation(BaseEntityClass):
	'''Entity context_dependent_shape_representation definition.

	:param representation_relation
	:type representation_relation:shape_representation_relationship

	:param represented_product_relation
	:type represented_product_relation:product_definition_shape
	'''
	def __init__( self , representation_relation,represented_product_relation, ):
		self._representation_relation = representation_relation
		self._represented_product_relation = represented_product_relation

	@property
	def representation_relation(self):
		return self._representation_relation
	@representation_relation.setter
	def representation_relation(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,shape_representation_relationship):
			self._representation_relation = shape_representation_relationship(value)
		else:
			self._representation_relation = value

	@property
	def represented_product_relation(self):
		return self._represented_product_relation
	@represented_product_relation.setter
	def represented_product_relation(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,product_definition_shape):
			self._represented_product_relation = product_definition_shape(value)
		else:
			self._represented_product_relation = value
	def wr1(self):
		eval_wr1_wr = ('CONFIG_CONTROL_DESIGN.PRODUCT_DEFINITION_RELATIONSHIP'  ==  TYPEOF(self.self.represented_product_relation.self.definition))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY geometric_representation_context #
####################
class geometric_representation_context(representation_context):
	'''Entity geometric_representation_context definition.

	:param coordinate_space_dimension
	:type coordinate_space_dimension:dimension_count
	'''
	def __init__( self , inherited0__context_identifier , inherited1__context_type , coordinate_space_dimension, ):
		representation_context.__init__(self , inherited0__context_identifier , inherited1__context_type , )
		self._coordinate_space_dimension = coordinate_space_dimension

	@property
	def coordinate_space_dimension(self):
		return self._coordinate_space_dimension
	@coordinate_space_dimension.setter
	def coordinate_space_dimension(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,dimension_count):
			self._coordinate_space_dimension = dimension_count(value)
		else:
			self._coordinate_space_dimension = value

####################
 # ENTITY mass_measure_with_unit #
####################
class mass_measure_with_unit(measure_with_unit):
	'''Entity mass_measure_with_unit definition.
	'''
	def __init__( self , inherited0__value_component , inherited1__unit_component ,  ):
		measure_with_unit.__init__(self , inherited0__value_component , inherited1__unit_component , )
	def wr1(self):
		eval_wr1_wr = ('CONFIG_CONTROL_DESIGN.MASS_UNIT'  ==  TYPEOF(self.self.measure_with_unit.self.unit_component))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY si_unit #
####################
class si_unit(named_unit):
	'''Entity si_unit definition.

	:param prefix
	:type prefix:si_prefix

	:param name
	:type name:si_unit_name

	:param named_unit_dimensions
	:type named_unit_dimensions:dimensional_exponents
	'''
	def __init__( self , inherited0__dimensions , prefix,name, ):
		named_unit.__init__(self , inherited0__dimensions , )
		self._prefix = prefix
		self._name = name

	@property
	def prefix(self):
		return self._prefix
	@prefix.setter
	def prefix(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,si_prefix):
				self._prefix = si_prefix(value)
			else:
				self._prefix = value
		else:
			self._prefix = value

	@property
	def name(self):
		return self._name
	@name.setter
	def name(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,si_unit_name):
			self._name = si_unit_name(value)
		else:
			self._name = value

	@property
	def named_unit_dimensions(self):
		attribute_eval = dimensions_for_si_unit(self.self.name)
		return attribute_eval
	@named_unit_dimensions.setter
	def named_unit_dimensions(self, value):
	# DERIVED argument
		raise AssertionError('Argument named_unit_dimensions is DERIVED. It is computed and can not be set to any value')

####################
 # ENTITY document_reference #
####################
class document_reference(BaseEntityClass):
	'''Entity document_reference definition.

	:param assigned_document
	:type assigned_document:document

	:param source
	:type source:label
	'''
	def __init__( self , assigned_document,source, ):
		self._assigned_document = assigned_document
		self._source = source

	@property
	def assigned_document(self):
		return self._assigned_document
	@assigned_document.setter
	def assigned_document(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,document):
			self._assigned_document = document(value)
		else:
			self._assigned_document = value

	@property
	def source(self):
		return self._source
	@source.setter
	def source(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,label):
			self._source = label(value)
		else:
			self._source = value

####################
 # ENTITY vertex_shell #
####################
class vertex_shell(topological_representation_item):
	'''Entity vertex_shell definition.

	:param vertex_shell_extent
	:type vertex_shell_extent:vertex_loop
	'''
	def __init__( self , inherited0__name , vertex_shell_extent, ):
		topological_representation_item.__init__(self , inherited0__name , )
		self._vertex_shell_extent = vertex_shell_extent

	@property
	def vertex_shell_extent(self):
		return self._vertex_shell_extent
	@vertex_shell_extent.setter
	def vertex_shell_extent(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,vertex_loop):
			self._vertex_shell_extent = vertex_loop(value)
		else:
			self._vertex_shell_extent = value

####################
 # ENTITY promissory_usage_occurrence #
####################
class promissory_usage_occurrence(assembly_component_usage):
	'''Entity promissory_usage_occurrence definition.
	'''
	def __init__( self , inherited0__id , inherited1__name , inherited2__description , inherited3__relating_product_definition , inherited4__related_product_definition , inherited5__reference_designator ,  ):
		assembly_component_usage.__init__(self , inherited0__id , inherited1__name , inherited2__description , inherited3__relating_product_definition , inherited4__related_product_definition , inherited5__reference_designator , )

####################
 # ENTITY plane_angle_measure_with_unit #
####################
class plane_angle_measure_with_unit(measure_with_unit):
	'''Entity plane_angle_measure_with_unit definition.
	'''
	def __init__( self , inherited0__value_component , inherited1__unit_component ,  ):
		measure_with_unit.__init__(self , inherited0__value_component , inherited1__unit_component , )
	def wr1(self):
		eval_wr1_wr = ('CONFIG_CONTROL_DESIGN.PLANE_ANGLE_UNIT'  ==  TYPEOF(self.self.measure_with_unit.self.unit_component))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY shape_aspect #
####################
class shape_aspect(BaseEntityClass):
	'''Entity shape_aspect definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param of_shape
	:type of_shape:product_definition_shape

	:param product_definitional
	:type product_definitional:LOGICAL
	'''
	def __init__( self , name,description,of_shape,product_definitional, ):
		self._name = name
		self._description = description
		self._of_shape = of_shape
		self._product_definitional = product_definitional

	@property
	def name(self):
		return self._name
	@name.setter
	def name(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,label):
			self._name = label(value)
		else:
			self._name = value

	@property
	def description(self):
		return self._description
	@description.setter
	def description(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,text):
			self._description = text(value)
		else:
			self._description = value

	@property
	def of_shape(self):
		return self._of_shape
	@of_shape.setter
	def of_shape(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,product_definition_shape):
			self._of_shape = product_definition_shape(value)
		else:
			self._of_shape = value

	@property
	def product_definitional(self):
		return self._product_definitional
	@product_definitional.setter
	def product_definitional(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,LOGICAL):
			self._product_definitional = LOGICAL(value)
		else:
			self._product_definitional = value

####################
 # ENTITY volume_measure_with_unit #
####################
class volume_measure_with_unit(measure_with_unit):
	'''Entity volume_measure_with_unit definition.
	'''
	def __init__( self , inherited0__value_component , inherited1__unit_component ,  ):
		measure_with_unit.__init__(self , inherited0__value_component , inherited1__unit_component , )
	def wr1(self):
		eval_wr1_wr = ('CONFIG_CONTROL_DESIGN.VOLUME_UNIT'  ==  TYPEOF(self.self.measure_with_unit.self.unit_component))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY action_request_solution #
####################
class action_request_solution(BaseEntityClass):
	'''Entity action_request_solution definition.

	:param method
	:type method:action_method

	:param request
	:type request:versioned_action_request
	'''
	def __init__( self , method,request, ):
		self._method = method
		self._request = request

	@property
	def method(self):
		return self._method
	@method.setter
	def method(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,action_method):
			self._method = action_method(value)
		else:
			self._method = value

	@property
	def request(self):
		return self._request
	@request.setter
	def request(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,versioned_action_request):
			self._request = versioned_action_request(value)
		else:
			self._request = value

####################
 # ENTITY axis2_placement_2d #
####################
class axis2_placement_2d(placement):
	'''Entity axis2_placement_2d definition.

	:param ref_direction
	:type ref_direction:direction

	:param p
	:type p:LIST(2,2,'direction', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__location , ref_direction, ):
		placement.__init__(self , inherited0__name , inherited1__location , )
		self._ref_direction = ref_direction

	@property
	def ref_direction(self):
		return self._ref_direction
	@ref_direction.setter
	def ref_direction(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,direction):
				self._ref_direction = direction(value)
			else:
				self._ref_direction = value
		else:
			self._ref_direction = value

	@property
	def p(self):
		attribute_eval = build_2axes(self.ref_direction)
		return attribute_eval
	@p.setter
	def p(self, value):
	# DERIVED argument
		raise AssertionError('Argument p is DERIVED. It is computed and can not be set to any value')
	def wr1(self):
		eval_wr1_wr = (self.self.geometric_representation_item.self.dim  ==  2)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY directed_action #
####################
class directed_action(executed_action):
	'''Entity directed_action definition.

	:param directive
	:type directive:action_directive
	'''
	def __init__( self , inherited0__name , inherited1__description , inherited2__chosen_method , directive, ):
		executed_action.__init__(self , inherited0__name , inherited1__description , inherited2__chosen_method , )
		self._directive = directive

	@property
	def directive(self):
		return self._directive
	@directive.setter
	def directive(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,action_directive):
			self._directive = action_directive(value)
		else:
			self._directive = value

####################
 # ENTITY manifold_surface_shape_representation #
####################
class manifold_surface_shape_representation(shape_representation):
	'''Entity manifold_surface_shape_representation definition.
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items ,  ):
		shape_representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  >  0)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  0)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(None)  ==  0)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = (SIZEOF(None)  ==  0)
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr

	def wr6(self):
		eval_wr6_wr = (SIZEOF(None)  ==  0)
		if not eval_wr6_wr:
			raise AssertionError('Rule wr6 violated')
		else:
			return eval_wr6_wr

	def wr7(self):
		eval_wr7_wr = (SIZEOF(None)  ==  0)
		if not eval_wr7_wr:
			raise AssertionError('Rule wr7 violated')
		else:
			return eval_wr7_wr

	def wr8(self):
		eval_wr8_wr = (SIZEOF(None)  ==  0)
		if not eval_wr8_wr:
			raise AssertionError('Rule wr8 violated')
		else:
			return eval_wr8_wr

	def wr9(self):
		eval_wr9_wr = (SIZEOF(None)  ==  0)
		if not eval_wr9_wr:
			raise AssertionError('Rule wr9 violated')
		else:
			return eval_wr9_wr

	def wr10(self):
		eval_wr10_wr = (SIZEOF(None)  ==  0)
		if not eval_wr10_wr:
			raise AssertionError('Rule wr10 violated')
		else:
			return eval_wr10_wr

	def wr11(self):
		eval_wr11_wr = (SIZEOF(None)  ==  0)
		if not eval_wr11_wr:
			raise AssertionError('Rule wr11 violated')
		else:
			return eval_wr11_wr

	def wr12(self):
		eval_wr12_wr = (SIZEOF(None)  ==  0)
		if not eval_wr12_wr:
			raise AssertionError('Rule wr12 violated')
		else:
			return eval_wr12_wr

	def wr13(self):
		eval_wr13_wr = (SIZEOF(None)  ==  0)
		if not eval_wr13_wr:
			raise AssertionError('Rule wr13 violated')
		else:
			return eval_wr13_wr

	def wr14(self):
		eval_wr14_wr = (SIZEOF(None)  ==  0)
		if not eval_wr14_wr:
			raise AssertionError('Rule wr14 violated')
		else:
			return eval_wr14_wr

	def wr15(self):
		eval_wr15_wr = (SIZEOF(None)  ==  0)
		if not eval_wr15_wr:
			raise AssertionError('Rule wr15 violated')
		else:
			return eval_wr15_wr


####################
 # ENTITY geometrically_bounded_surface_shape_representation #
####################
class geometrically_bounded_surface_shape_representation(shape_representation):
	'''Entity geometrically_bounded_surface_shape_representation definition.
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items ,  ):
		shape_representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  >  0)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  0)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(None)  ==  0)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = (SIZEOF(None)  ==  0)
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr

	def wr6(self):
		eval_wr6_wr = (SIZEOF(None)  ==  0)
		if not eval_wr6_wr:
			raise AssertionError('Rule wr6 violated')
		else:
			return eval_wr6_wr

	def wr7(self):
		eval_wr7_wr = (SIZEOF(None)  >  0)
		if not eval_wr7_wr:
			raise AssertionError('Rule wr7 violated')
		else:
			return eval_wr7_wr


####################
 # ENTITY point_replica #
####################
class point_replica(point):
	'''Entity point_replica definition.

	:param parent_pt
	:type parent_pt:point

	:param transformation
	:type transformation:cartesian_transformation_operator
	'''
	def __init__( self , inherited0__name , parent_pt,transformation, ):
		point.__init__(self , inherited0__name , )
		self._parent_pt = parent_pt
		self._transformation = transformation

	@property
	def parent_pt(self):
		return self._parent_pt
	@parent_pt.setter
	def parent_pt(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,point):
			self._parent_pt = point(value)
		else:
			self._parent_pt = value

	@property
	def transformation(self):
		return self._transformation
	@transformation.setter
	def transformation(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,cartesian_transformation_operator):
			self._transformation = cartesian_transformation_operator(value)
		else:
			self._transformation = value
	def wr1(self):
		eval_wr1_wr = (self.transformation.self.dim  ==  self.parent_pt.self.dim)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = acyclic_point_replica(self,self.parent_pt)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY cc_design_specification_reference #
####################
class cc_design_specification_reference(document_reference):
	'''Entity cc_design_specification_reference definition.

	:param items
	:type items:SET(1,None,'specified_item', scope = schema_scope)
	'''
	def __init__( self , inherited0__assigned_document , inherited1__source , items, ):
		document_reference.__init__(self , inherited0__assigned_document , inherited1__source , )
		self._items = items

	@property
	def items(self):
		return self._items
	@items.setter
	def items(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(1,None,'specified_item', scope = schema_scope)):
			self._items = SET(value)
		else:
			self._items = value

####################
 # ENTITY coordinated_universal_time_offset #
####################
class coordinated_universal_time_offset(BaseEntityClass):
	'''Entity coordinated_universal_time_offset definition.

	:param hour_offset
	:type hour_offset:hour_in_day

	:param minute_offset
	:type minute_offset:minute_in_hour

	:param sense
	:type sense:ahead_or_behind
	'''
	def __init__( self , hour_offset,minute_offset,sense, ):
		self._hour_offset = hour_offset
		self._minute_offset = minute_offset
		self._sense = sense

	@property
	def hour_offset(self):
		return self._hour_offset
	@hour_offset.setter
	def hour_offset(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,hour_in_day):
			self._hour_offset = hour_in_day(value)
		else:
			self._hour_offset = value

	@property
	def minute_offset(self):
		return self._minute_offset
	@minute_offset.setter
	def minute_offset(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,minute_in_hour):
				self._minute_offset = minute_in_hour(value)
			else:
				self._minute_offset = value
		else:
			self._minute_offset = value

	@property
	def sense(self):
		return self._sense
	@sense.setter
	def sense(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,ahead_or_behind):
			self._sense = ahead_or_behind(value)
		else:
			self._sense = value

####################
 # ENTITY direction #
####################
class direction(geometric_representation_item):
	'''Entity direction definition.

	:param direction_ratios
	:type direction_ratios:LIST(2,3,'REAL', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , direction_ratios, ):
		geometric_representation_item.__init__(self , inherited0__name , )
		self._direction_ratios = direction_ratios

	@property
	def direction_ratios(self):
		return self._direction_ratios
	@direction_ratios.setter
	def direction_ratios(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,LIST(2,3,'REAL', scope = schema_scope)):
			self._direction_ratios = LIST(value)
		else:
			self._direction_ratios = value
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  >  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY approval_status #
####################
class approval_status(BaseEntityClass):
	'''Entity approval_status definition.

	:param name
	:type name:label
	'''
	def __init__( self , name, ):
		self._name = name

	@property
	def name(self):
		return self._name
	@name.setter
	def name(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,label):
			self._name = label(value)
		else:
			self._name = value

####################
 # ENTITY oriented_path #
####################
class oriented_path(path):
	'''Entity oriented_path definition.

	:param path_element
	:type path_element:path

	:param orientation
	:type orientation:BOOLEAN

	:param path_edge_list
	:type path_edge_list:LIST(1,None,'oriented_edge', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__edge_list , path_element,orientation, ):
		path.__init__(self , inherited0__name , inherited1__edge_list , )
		self._path_element = path_element
		self._orientation = orientation

	@property
	def path_element(self):
		return self._path_element
	@path_element.setter
	def path_element(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,path):
			self._path_element = path(value)
		else:
			self._path_element = value

	@property
	def orientation(self):
		return self._orientation
	@orientation.setter
	def orientation(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,BOOLEAN):
			self._orientation = BOOLEAN(value)
		else:
			self._orientation = value

	@property
	def path_edge_list(self):
		attribute_eval = conditional_reverse(self.self.orientation,self.self.path_element.self.edge_list)
		return attribute_eval
	@path_edge_list.setter
	def path_edge_list(self, value):
	# DERIVED argument
		raise AssertionError('Argument path_edge_list is DERIVED. It is computed and can not be set to any value')
	def wr1(self):
		eval_wr1_wr = ( not ('CONFIG_CONTROL_DESIGN.ORIENTED_PATH'  ==  TYPEOF(self.self.path_element)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY representation_map #
####################
class representation_map(BaseEntityClass):
	'''Entity representation_map definition.

	:param mapping_origin
	:type mapping_origin:representation_item

	:param mapped_representation
	:type mapped_representation:representation

	:param map_usage
	:type map_usage:SET(1,None,'mapped_item', scope = schema_scope)
	'''
	def __init__( self , mapping_origin,mapped_representation, ):
		self._mapping_origin = mapping_origin
		self._mapped_representation = mapped_representation

	@property
	def mapping_origin(self):
		return self._mapping_origin
	@mapping_origin.setter
	def mapping_origin(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,representation_item):
			self._mapping_origin = representation_item(value)
		else:
			self._mapping_origin = value

	@property
	def mapped_representation(self):
		return self._mapped_representation
	@mapped_representation.setter
	def mapped_representation(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,representation):
			self._mapped_representation = representation(value)
		else:
			self._mapped_representation = value

	@property
	def map_usage(self):
		return self._map_usage
	@map_usage.setter
	def map_usage(self, value):
	# INVERSE argument
		raise AssertionError('Argument map_usage is INVERSE. It is computed and can not be set to any value')
	def wr1(self):
		eval_wr1_wr = item_in_context(self.self.mapping_origin,self.self.mapped_representation.self.context_of_items)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY dated_effectivity #
####################
class dated_effectivity(effectivity):
	'''Entity dated_effectivity definition.

	:param effectivity_start_date
	:type effectivity_start_date:date_and_time

	:param effectivity_end_date
	:type effectivity_end_date:date_and_time
	'''
	def __init__( self , inherited0__id , effectivity_start_date,effectivity_end_date, ):
		effectivity.__init__(self , inherited0__id , )
		self._effectivity_start_date = effectivity_start_date
		self._effectivity_end_date = effectivity_end_date

	@property
	def effectivity_start_date(self):
		return self._effectivity_start_date
	@effectivity_start_date.setter
	def effectivity_start_date(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,date_and_time):
			self._effectivity_start_date = date_and_time(value)
		else:
			self._effectivity_start_date = value

	@property
	def effectivity_end_date(self):
		return self._effectivity_end_date
	@effectivity_end_date.setter
	def effectivity_end_date(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,date_and_time):
				self._effectivity_end_date = date_and_time(value)
			else:
				self._effectivity_end_date = value
		else:
			self._effectivity_end_date = value

####################
 # ENTITY volume_unit #
####################
class volume_unit(named_unit):
	'''Entity volume_unit definition.
	'''
	def __init__( self , inherited0__dimensions ,  ):
		named_unit.__init__(self , inherited0__dimensions , )
	def wr1(self):
		eval_wr1_wr = (((((((self.self.named_unit.self.dimensions.self.length_exponent  ==  3)  and  (self.self.named_unit.self.dimensions.self.mass_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.time_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.electric_current_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.thermodynamic_temperature_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.amount_of_substance_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.luminous_intensity_exponent  ==  0))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY bezier_surface #
####################
class bezier_surface(b_spline_surface):
	'''Entity bezier_surface definition.
	'''
	def __init__( self , inherited0__name , inherited1__u_degree , inherited2__v_degree , inherited3__control_points_list , inherited4__surface_form , inherited5__u_closed , inherited6__v_closed , inherited7__self_intersect ,  ):
		b_spline_surface.__init__(self , inherited0__name , inherited1__u_degree , inherited2__v_degree , inherited3__control_points_list , inherited4__surface_form , inherited5__u_closed , inherited6__v_closed , inherited7__self_intersect , )

####################
 # ENTITY cylindrical_surface #
####################
class cylindrical_surface(elementary_surface):
	'''Entity cylindrical_surface definition.

	:param radius
	:type radius:positive_length_measure
	'''
	def __init__( self , inherited0__name , inherited1__position , radius, ):
		elementary_surface.__init__(self , inherited0__name , inherited1__position , )
		self._radius = radius

	@property
	def radius(self):
		return self._radius
	@radius.setter
	def radius(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,positive_length_measure):
			self._radius = positive_length_measure(value)
		else:
			self._radius = value

	def printer(self):
		print '    '+self.stepLine
		print '      '+self.position.stepLine
		self.position.printer()
		#print '      Radius : '+str(self.radius)

####################
 # ENTITY person_and_organization #
####################
class person_and_organization(BaseEntityClass):
	'''Entity person_and_organization definition.

	:param the_person
	:type the_person:person

	:param the_organization
	:type the_organization:organization
	'''
	def __init__( self , the_person,the_organization, ):
		self._the_person = the_person
		self._the_organization = the_organization

	@property
	def the_person(self):
		return self._the_person
	@the_person.setter
	def the_person(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,person):
			self._the_person = person(value)
		else:
			self._the_person = value

	@property
	def the_organization(self):
		return self._the_organization
	@the_organization.setter
	def the_organization(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,organization):
			self._the_organization = organization(value)
		else:
			self._the_organization = value

####################
 # ENTITY brep_with_voids #
####################
class brep_with_voids(manifold_solid_brep):
	'''Entity brep_with_voids definition.

	:param voids
	:type voids:SET(1,None,'oriented_closed_shell', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__outer , voids, ):
		manifold_solid_brep.__init__(self , inherited0__name , inherited1__outer , )
		self._voids = voids

	@property
	def voids(self):
		return self._voids
	@voids.setter
	def voids(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(1,None,'oriented_closed_shell', scope = schema_scope)):
			self._voids = SET(value)
		else:
			self._voids = value

####################
 # ENTITY connected_edge_set #
####################
class connected_edge_set(topological_representation_item):
	'''Entity connected_edge_set definition.

	:param ces_edges
	:type ces_edges:SET(1,None,'edge', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , ces_edges, ):
		topological_representation_item.__init__(self , inherited0__name , )
		self._ces_edges = ces_edges

	@property
	def ces_edges(self):
		return self._ces_edges
	@ces_edges.setter
	def ces_edges(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(1,None,'edge', scope = schema_scope)):
			self._ces_edges = SET(value)
		else:
			self._ces_edges = value

####################
 # ENTITY alternate_product_relationship #
####################
class alternate_product_relationship(BaseEntityClass):
	'''Entity alternate_product_relationship definition.

	:param name
	:type name:label

	:param definition
	:type definition:text

	:param alternate
	:type alternate:product

	:param base
	:type base:product

	:param basis
	:type basis:text
	'''
	def __init__( self , name,definition,alternate,base,basis, ):
		self._name = name
		self._definition = definition
		self._alternate = alternate
		self._base = base
		self._basis = basis

	@property
	def name(self):
		return self._name
	@name.setter
	def name(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,label):
			self._name = label(value)
		else:
			self._name = value

	@property
	def definition(self):
		return self._definition
	@definition.setter
	def definition(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,text):
			self._definition = text(value)
		else:
			self._definition = value

	@property
	def alternate(self):
		return self._alternate
	@alternate.setter
	def alternate(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,product):
			self._alternate = product(value)
		else:
			self._alternate = value

	@property
	def base(self):
		return self._base
	@base.setter
	def base(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,product):
			self._base = product(value)
		else:
			self._base = value

	@property
	def basis(self):
		return self._basis
	@basis.setter
	def basis(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,text):
			self._basis = text(value)
		else:
			self._basis = value
	def wr1(self):
		eval_wr1_wr = (self.alternate  !=  self.base)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY surface_of_linear_extrusion #
####################
class surface_of_linear_extrusion(swept_surface):
	'''Entity surface_of_linear_extrusion definition.

	:param extrusion_axis
	:type extrusion_axis:vector
	'''
	def __init__( self , inherited0__name , inherited1__swept_curve , extrusion_axis, ):
		swept_surface.__init__(self , inherited0__name , inherited1__swept_curve , )
		self._extrusion_axis = extrusion_axis

	@property
	def extrusion_axis(self):
		return self._extrusion_axis
	@extrusion_axis.setter
	def extrusion_axis(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,vector):
			self._extrusion_axis = vector(value)
		else:
			self._extrusion_axis = value

####################
 # ENTITY security_classification #
####################
class security_classification(BaseEntityClass):
	'''Entity security_classification definition.

	:param name
	:type name:label

	:param purpose
	:type purpose:text

	:param security_level
	:type security_level:security_classification_level
	'''
	def __init__( self , name,purpose,security_level, ):
		self._name = name
		self._purpose = purpose
		self._security_level = security_level

	@property
	def name(self):
		return self._name
	@name.setter
	def name(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,label):
			self._name = label(value)
		else:
			self._name = value

	@property
	def purpose(self):
		return self._purpose
	@purpose.setter
	def purpose(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,text):
			self._purpose = text(value)
		else:
			self._purpose = value

	@property
	def security_level(self):
		return self._security_level
	@security_level.setter
	def security_level(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,security_classification_level):
			self._security_level = security_classification_level(value)
		else:
			self._security_level = value

####################
 # ENTITY certification_type #
####################
class certification_type(BaseEntityClass):
	'''Entity certification_type definition.

	:param description
	:type description:label
	'''
	def __init__( self , description, ):
		self._description = description

	@property
	def description(self):
		return self._description
	@description.setter
	def description(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,label):
			self._description = label(value)
		else:
			self._description = value

####################
 # ENTITY approval_date_time #
####################
class approval_date_time(BaseEntityClass):
	'''Entity approval_date_time definition.

	:param date_time
	:type date_time:date_time_select

	:param dated_approval
	:type dated_approval:approval
	'''
	def __init__( self , date_time,dated_approval, ):
		self._date_time = date_time
		self._dated_approval = dated_approval

	@property
	def date_time(self):
		return self._date_time
	@date_time.setter
	def date_time(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,date_time_select):
			self._date_time = date_time_select(value)
		else:
			self._date_time = value

	@property
	def dated_approval(self):
		return self._dated_approval
	@dated_approval.setter
	def dated_approval(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,approval):
			self._dated_approval = approval(value)
		else:
			self._dated_approval = value

####################
 # ENTITY point_on_curve #
####################
class point_on_curve(point):
	'''Entity point_on_curve definition.

	:param basis_curve
	:type basis_curve:curve

	:param point_parameter
	:type point_parameter:parameter_value
	'''
	def __init__( self , inherited0__name , basis_curve,point_parameter, ):
		point.__init__(self , inherited0__name , )
		self._basis_curve = basis_curve
		self._point_parameter = point_parameter

	@property
	def basis_curve(self):
		return self._basis_curve
	@basis_curve.setter
	def basis_curve(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,curve):
			self._basis_curve = curve(value)
		else:
			self._basis_curve = value

	@property
	def point_parameter(self):
		return self._point_parameter
	@point_parameter.setter
	def point_parameter(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,parameter_value):
			self._point_parameter = parameter_value(value)
		else:
			self._point_parameter = value

####################
 # ENTITY intersection_curve #
####################
class intersection_curve(surface_curve):
	'''Entity intersection_curve definition.
	'''
	def __init__( self , inherited0__name , inherited1__curve_3d , inherited2__associated_geometry , inherited3__master_representation ,  ):
		surface_curve.__init__(self , inherited0__name , inherited1__curve_3d , inherited2__associated_geometry , inherited3__master_representation , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(self.self.surface_curve.self.associated_geometry)  ==  2)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (associated_surface(self.self.surface_curve.self.associated_geometry[1])  !=  associated_surface(self.self.surface_curve.self.associated_geometry[2]))
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr


####################
 # ENTITY action_directive #
####################
class action_directive(BaseEntityClass):
	'''Entity action_directive definition.

	:param name
	:type name:label

	:param description
	:type description:text

	:param analysis
	:type analysis:text

	:param comment
	:type comment:text

	:param requests
	:type requests:SET(1,None,'versioned_action_request', scope = schema_scope)
	'''
	def __init__( self , name,description,analysis,comment,requests, ):
		self._name = name
		self._description = description
		self._analysis = analysis
		self._comment = comment
		self._requests = requests

	@property
	def name(self):
		return self._name
	@name.setter
	def name(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,label):
			self._name = label(value)
		else:
			self._name = value

	@property
	def description(self):
		return self._description
	@description.setter
	def description(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,text):
			self._description = text(value)
		else:
			self._description = value

	@property
	def analysis(self):
		return self._analysis
	@analysis.setter
	def analysis(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,text):
			self._analysis = text(value)
		else:
			self._analysis = value

	@property
	def comment(self):
		return self._comment
	@comment.setter
	def comment(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,text):
			self._comment = text(value)
		else:
			self._comment = value

	@property
	def requests(self):
		return self._requests
	@requests.setter
	def requests(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(1,None,'versioned_action_request', scope = schema_scope)):
			self._requests = SET(value)
		else:
			self._requests = value

####################
 # ENTITY offset_curve_3d #
####################
class offset_curve_3d(curve):
	'''Entity offset_curve_3d definition.

	:param basis_curve
	:type basis_curve:curve

	:param distance
	:type distance:length_measure

	:param self_intersect
	:type self_intersect:LOGICAL

	:param ref_direction
	:type ref_direction:direction
	'''
	def __init__( self , inherited0__name , basis_curve,distance,self_intersect,ref_direction, ):
		curve.__init__(self , inherited0__name , )
		self._basis_curve = basis_curve
		self._distance = distance
		self._self_intersect = self_intersect
		self._ref_direction = ref_direction

	@property
	def basis_curve(self):
		return self._basis_curve
	@basis_curve.setter
	def basis_curve(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,curve):
			self._basis_curve = curve(value)
		else:
			self._basis_curve = value

	@property
	def distance(self):
		return self._distance
	@distance.setter
	def distance(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,length_measure):
			self._distance = length_measure(value)
		else:
			self._distance = value

	@property
	def self_intersect(self):
		return self._self_intersect
	@self_intersect.setter
	def self_intersect(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,LOGICAL):
			self._self_intersect = LOGICAL(value)
		else:
			self._self_intersect = value

	@property
	def ref_direction(self):
		return self._ref_direction
	@ref_direction.setter
	def ref_direction(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,direction):
			self._ref_direction = direction(value)
		else:
			self._ref_direction = value
	def wr1(self):
		eval_wr1_wr = ((self.basis_curve.self.dim  ==  3)  and  (self.ref_direction.self.dim  ==  3))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY area_unit #
####################
class area_unit(named_unit):
	'''Entity area_unit definition.
	'''
	def __init__( self , inherited0__dimensions ,  ):
		named_unit.__init__(self , inherited0__dimensions , )
	def wr1(self):
		eval_wr1_wr = (((((((self.self.named_unit.self.dimensions.self.length_exponent  ==  2)  and  (self.self.named_unit.self.dimensions.self.mass_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.time_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.electric_current_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.thermodynamic_temperature_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.amount_of_substance_exponent  ==  0))  and  (self.self.named_unit.self.dimensions.self.luminous_intensity_exponent  ==  0))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY oriented_open_shell #
####################
class oriented_open_shell(open_shell):
	'''Entity oriented_open_shell definition.

	:param open_shell_element
	:type open_shell_element:open_shell

	:param orientation
	:type orientation:BOOLEAN

	:param connected_face_set_cfs_faces
	:type connected_face_set_cfs_faces:SET(1,None,'face', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , inherited1__cfs_faces , open_shell_element,orientation, ):
		open_shell.__init__(self , inherited0__name , inherited1__cfs_faces , )
		self._open_shell_element = open_shell_element
		self._orientation = orientation

	@property
	def open_shell_element(self):
		return self._open_shell_element
	@open_shell_element.setter
	def open_shell_element(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,open_shell):
			self._open_shell_element = open_shell(value)
		else:
			self._open_shell_element = value

	@property
	def orientation(self):
		return self._orientation
	@orientation.setter
	def orientation(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,BOOLEAN):
			self._orientation = BOOLEAN(value)
		else:
			self._orientation = value

	@property
	def connected_face_set_cfs_faces(self):
		attribute_eval = conditional_reverse(self.self.orientation,self.self.open_shell_element.self.cfs_faces)
		return attribute_eval
	@connected_face_set_cfs_faces.setter
	def connected_face_set_cfs_faces(self, value):
	# DERIVED argument
		raise AssertionError('Argument connected_face_set_cfs_faces is DERIVED. It is computed and can not be set to any value')
	def wr1(self):
		eval_wr1_wr = ( not ('CONFIG_CONTROL_DESIGN.ORIENTED_OPEN_SHELL'  ==  TYPEOF(self.self.open_shell_element)))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY shell_based_wireframe_shape_representation #
####################
class shell_based_wireframe_shape_representation(shape_representation):
	'''Entity shell_based_wireframe_shape_representation definition.
	'''
	def __init__( self , inherited0__name , inherited1__items , inherited2__context_of_items ,  ):
		shape_representation.__init__(self , inherited0__name , inherited1__items , inherited2__context_of_items , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(None)  ==  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  >=  1)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  0)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(None)  ==  0)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = (SIZEOF(None)  ==  0)
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr

	def wr6(self):
		eval_wr6_wr = (SIZEOF(None)  ==  0)
		if not eval_wr6_wr:
			raise AssertionError('Rule wr6 violated')
		else:
			return eval_wr6_wr

	def wr7(self):
		eval_wr7_wr = (SIZEOF(None)  ==  0)
		if not eval_wr7_wr:
			raise AssertionError('Rule wr7 violated')
		else:
			return eval_wr7_wr

	def wr8(self):
		eval_wr8_wr = (SIZEOF(None)  ==  0)
		if not eval_wr8_wr:
			raise AssertionError('Rule wr8 violated')
		else:
			return eval_wr8_wr

	def wr9(self):
		eval_wr9_wr = (SIZEOF(None)  ==  0)
		if not eval_wr9_wr:
			raise AssertionError('Rule wr9 violated')
		else:
			return eval_wr9_wr

	def wr10(self):
		eval_wr10_wr = (SIZEOF(None)  ==  0)
		if not eval_wr10_wr:
			raise AssertionError('Rule wr10 violated')
		else:
			return eval_wr10_wr

	def wr11(self):
		eval_wr11_wr = (SIZEOF(None)  ==  0)
		if not eval_wr11_wr:
			raise AssertionError('Rule wr11 violated')
		else:
			return eval_wr11_wr

	def wr12(self):
		eval_wr12_wr = (SIZEOF(None)  ==  0)
		if not eval_wr12_wr:
			raise AssertionError('Rule wr12 violated')
		else:
			return eval_wr12_wr

	def wr13(self):
		eval_wr13_wr = (self.self.context_of_items.self.geometric_representation_context.self.coordinate_space_dimension  ==  3)
		if not eval_wr13_wr:
			raise AssertionError('Rule wr13 violated')
		else:
			return eval_wr13_wr


####################
 # ENTITY advanced_face #
####################
class advanced_face(face_surface):
	'''Entity advanced_face definition.
	'''
	def __init__( self , inherited0__name , inherited1__bounds , inherited2__name , inherited3__face_geometry , inherited4__same_sense ,  ):
		face_surface.__init__(self , inherited0__name , inherited1__bounds , inherited2__name , inherited3__face_geometry , inherited4__same_sense , )
	def wr1(self):
		eval_wr1_wr = (SIZEOF(['CONFIG_CONTROL_DESIGN.ELEMENTARY_SURFACE','CONFIG_CONTROL_DESIGN.B_SPLINE_SURFACE','CONFIG_CONTROL_DESIGN.SWEPT_SURFACE']  *  TYPEOF(self.face_geometry))  ==  1)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr

	def getEdgeType(self, edgeType):
		ret = []
		for fb in self.bounds:
			for oe in fb.bound.edge_list:
				if(isinstance(oe.edge_element.edge_geometry, edgeType)):
					ret.append(oe.edge_element.edge_geometry)
		return ret

	'''
	def getAdvancedFacesThatShareEdgeCurve(self, closed_shell):
		for b in self.bounds:
			for oe in b.bound.edge_list:
				for i,af in enumerate(closed_shell.cfs_faces):
					if(i!=closed_shell.cfs_faces.index(self) and isinstance(af.face_geometry, cylindrical_surface)):
						for baf in af.bounds:
							for boe in baf.bound.edge_list:
								if(oe.edge_element.stepLine == boe.edge_element.stepLine and isinstance(boe.edge_element.edge_geometry, line) and isinstance(oe.edge_element.edge_geometry, line)):
									print self.stepLine+'--'+af.stepLine
	'''

	def wr2(self):
		eval_wr2_wr = (SIZEOF(None)  ==  0)
		if not eval_wr2_wr:
			raise AssertionError('Rule wr2 violated')
		else:
			return eval_wr2_wr

	def wr3(self):
		eval_wr3_wr = (SIZEOF(None)  ==  0)
		if not eval_wr3_wr:
			raise AssertionError('Rule wr3 violated')
		else:
			return eval_wr3_wr

	def wr4(self):
		eval_wr4_wr = (SIZEOF(None)  ==  0)
		if not eval_wr4_wr:
			raise AssertionError('Rule wr4 violated')
		else:
			return eval_wr4_wr

	def wr5(self):
		eval_wr5_wr = (SIZEOF(None)  ==  0)
		if not eval_wr5_wr:
			raise AssertionError('Rule wr5 violated')
		else:
			return eval_wr5_wr

	def wr6(self):
		eval_wr6_wr = (( not ('CONFIG_CONTROL_DESIGN.SWEPT_SURFACE'  ==  TYPEOF(self.face_geometry)))  or  (SIZEOF(['CONFIG_CONTROL_DESIGN.LINE','CONFIG_CONTROL_DESIGN.CONIC','CONFIG_CONTROL_DESIGN.POLYLINE','CONFIG_CONTROL_DESIGN.B_SPLINE_CURVE']  *  TYPEOF(self.face_geometry.self.swept_surface.self.swept_curve))  ==  1))
		if not eval_wr6_wr:
			raise AssertionError('Rule wr6 violated')
		else:
			return eval_wr6_wr

	def wr7(self):
		eval_wr7_wr = (SIZEOF(None)  ==  0)
		if not eval_wr7_wr:
			raise AssertionError('Rule wr7 violated')
		else:
			return eval_wr7_wr

	def wr8(self):
		eval_wr8_wr = (SIZEOF(None)  ==  0)
		if not eval_wr8_wr:
			raise AssertionError('Rule wr8 violated')
		else:
			return eval_wr8_wr

	def wr9(self):
		eval_wr9_wr = (SIZEOF(None)  ==  0)
		if not eval_wr9_wr:
			raise AssertionError('Rule wr9 violated')
		else:
			return eval_wr9_wr

	def wr10(self):
		eval_wr10_wr = (((( not ('CONFIG_CONTROL_DESIGN.SWEPT_SURFACE'  ==  TYPEOF(self.face_geometry)))  or  ( not ('CONFIG_CONTROL_DESIGN.POLYLINE'  ==  TYPEOF(self.face_geometry.self.swept_surface.self.swept_curve))))  or  (SIZEOF(self.face_geometry.self.swept_surface.self.swept_curve.self.polyline.self.points)  >=  3))  and  (SIZEOF(None)  ==  0))
		if not eval_wr10_wr:
			raise AssertionError('Rule wr10 violated')
		else:
			return eval_wr10_wr


####################
 # ENTITY date_time_role #
####################
class date_time_role(BaseEntityClass):
	'''Entity date_time_role definition.

	:param name
	:type name:label
	'''
	def __init__( self , name, ):
		self._name = name

	@property
	def name(self):
		return self._name
	@name.setter
	def name(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,label):
			self._name = label(value)
		else:
			self._name = value

####################
 # ENTITY document_type #
####################
class document_type(BaseEntityClass):
	'''Entity document_type definition.

	:param product_data_type
	:type product_data_type:label
	'''
	def __init__( self , product_data_type, ):
		self._product_data_type = product_data_type

	@property
	def product_data_type(self):
		return self._product_data_type
	@product_data_type.setter
	def product_data_type(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,label):
			self._product_data_type = label(value)
		else:
			self._product_data_type = value

####################
 # ENTITY supplied_part_relationship #
####################
class supplied_part_relationship(product_definition_relationship):
	'''Entity supplied_part_relationship definition.
	'''
	def __init__( self , inherited0__id , inherited1__name , inherited2__description , inherited3__relating_product_definition , inherited4__related_product_definition ,  ):
		product_definition_relationship.__init__(self , inherited0__id , inherited1__name , inherited2__description , inherited3__relating_product_definition , inherited4__related_product_definition , )

####################
 # ENTITY conical_surface #
####################
class conical_surface(elementary_surface):
	'''Entity conical_surface definition.

	:param radius
	:type radius:length_measure

	:param semi_angle
	:type semi_angle:plane_angle_measure
	'''
	def __init__( self , inherited0__name , inherited1__position , radius,semi_angle, ):
		elementary_surface.__init__(self , inherited0__name , inherited1__position , )
		self._radius = radius
		self._semi_angle = semi_angle

	def printer(self):
		print '    '+self.stepLine
		print '      '+self.position.stepLine
		self.position.printer()

	@property
	def radius(self):
		return self._radius
	@radius.setter
	def radius(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,length_measure):
			self._radius = length_measure(value)
		else:
			self._radius = value

	@property
	def semi_angle(self):
		return self._semi_angle
	@semi_angle.setter
	def semi_angle(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,plane_angle_measure):
			self._semi_angle = plane_angle_measure(value)
		else:
			self._semi_angle = value
	def wr1(self):
		eval_wr1_wr = (self.radius  >=  0)
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY edge_curve #
####################
class edge_curve(edge,geometric_representation_item):
	'''Entity edge_curve definition.

	:param edge_geometry
	:type edge_geometry:curve

	:param same_sense
	:type same_sense:BOOLEAN
	'''
	def __init__( self , inherited0__name , inherited1__edge_start , inherited2__edge_end , inherited3__name , edge_geometry,same_sense, ):
		edge.__init__(self , inherited0__name , inherited1__edge_start , inherited2__edge_end , )
		geometric_representation_item.__init__(self , inherited3__name , )
		self._edge_geometry = edge_geometry
		self._same_sense = same_sense

	@property
	def edge_geometry(self):
		return self._edge_geometry
	@edge_geometry.setter
	def edge_geometry(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,curve):
			self._edge_geometry = curve(value)
		else:
			self._edge_geometry = value

	@property
	def same_sense(self):
		return self._same_sense
	@same_sense.setter
	def same_sense(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,BOOLEAN):
			self._same_sense = BOOLEAN(value)
		else:
			self._same_sense = value

####################
 # ENTITY serial_numbered_effectivity #
####################
class serial_numbered_effectivity(effectivity):
	'''Entity serial_numbered_effectivity definition.

	:param effectivity_start_id
	:type effectivity_start_id:identifier

	:param effectivity_end_id
	:type effectivity_end_id:identifier
	'''
	def __init__( self , inherited0__id , effectivity_start_id,effectivity_end_id, ):
		effectivity.__init__(self , inherited0__id , )
		self._effectivity_start_id = effectivity_start_id
		self._effectivity_end_id = effectivity_end_id

	@property
	def effectivity_start_id(self):
		return self._effectivity_start_id
	@effectivity_start_id.setter
	def effectivity_start_id(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,identifier):
			self._effectivity_start_id = identifier(value)
		else:
			self._effectivity_start_id = value

	@property
	def effectivity_end_id(self):
		return self._effectivity_end_id
	@effectivity_end_id.setter
	def effectivity_end_id(self, value):
		if value != None: # OPTIONAL attribute
			if not check_type(value,identifier):
				self._effectivity_end_id = identifier(value)
			else:
				self._effectivity_end_id = value
		else:
			self._effectivity_end_id = value

####################
 # ENTITY wire_shell #
####################
class wire_shell(topological_representation_item):
	'''Entity wire_shell definition.

	:param wire_shell_extent
	:type wire_shell_extent:SET(1,None,'loop', scope = schema_scope)
	'''
	def __init__( self , inherited0__name , wire_shell_extent, ):
		topological_representation_item.__init__(self , inherited0__name , )
		self._wire_shell_extent = wire_shell_extent

	@property
	def wire_shell_extent(self):
		return self._wire_shell_extent
	@wire_shell_extent.setter
	def wire_shell_extent(self, value):
		# Mandatory argument
		assert value != None, 'Argument "value" is mantatory and cannot be set to None'
		if not check_type(value,SET(1,None,'loop', scope = schema_scope)):
			self._wire_shell_extent = SET(value)
		else:
			self._wire_shell_extent = value
	def wr1(self):
		eval_wr1_wr = ( not mixed_loop_type_set(self.wire_shell_extent))
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # ENTITY mechanical_context #
####################
class mechanical_context(product_context):
	'''Entity mechanical_context definition.
	'''
	def __init__( self , inherited0__name , inherited1__frame_of_reference , inherited2__discipline_type ,  ):
		product_context.__init__(self , inherited0__name , inherited1__frame_of_reference , inherited2__discipline_type , )
	def wr1(self):
		eval_wr1_wr = (self.self.discipline_type  ==  'mechanical')
		if not eval_wr1_wr:
			raise AssertionError('Rule wr1 violated')
		else:
			return eval_wr1_wr


####################
 # FUNCTION valid_time #
####################
def valid_time(time,):
	'''
	:param time
	:type time:local_time
	'''
	if (EXISTS(time.second_component)):
		return EXISTS(time.minute_component)
	else:
		return TRUE

####################
 # FUNCTION closed_shell_reversed #
####################
def closed_shell_reversed(a_shell,):
	'''
	:param a_shell
	:type a_shell:closed_shell
	'''
	if ('CONFIG_CONTROL_DESIGN.ORIENTED_CLOSED_SHELL'  ==  TYPEOF(a_shell)):
		the_reverse = ((dummy_tri  ==  connected_face_set(a_shell.connected_face_set.cfs_faces))  ==  closed_shell())  ==  oriented_closed_shell(a_shell.oriented_closed_shell.closed_shell_element, not a_shell.oriented_closed_shell.orientation)
	else:
		the_reverse = ((dummy_tri  ==  connected_face_set(a_shell.connected_face_set.cfs_faces))  ==  closed_shell())  ==  oriented_closed_shell(a_shell,FALSE)
	return the_reverse

####################
 # FUNCTION msb_shells #
####################
def msb_shells(brep,):
	'''
	:param brep
	:type brep:manifold_solid_brep
	'''
	if (SIZEOF(None)  >=  1):
		return brep.brep_with_voids.voids  +  brep.outer
	else:
		return [brep.outer]

####################
 # FUNCTION using_representations #
####################
def using_representations(item,):
	'''
	:param item
	:type item:founded_item_select
	'''
	results = []
	result_bag = USEDIN(item,'CONFIG_CONTROL_DESIGN.REPRESENTATION.ITEMS')
	if (SIZEOF(result_bag)  >  0):
		for i in range(1,HIINDEX(result_bag),1):
			results = results  +  result_bag[i]
	intermediate_items = using_items(item,[])
	if (SIZEOF(intermediate_items)  >  0):
		for i in range(1,HIINDEX(intermediate_items),1):
			result_bag = USEDIN(intermediate_items[i],'CONFIG_CONTROL_DESIGN.REPRESENTATION.ITEMS')
			if (SIZEOF(result_bag)  >  0):
				for j in range(1,HIINDEX(result_bag),1):
					results = results  +  result_bag[j]
	return results

####################
 # FUNCTION bag_to_set #
####################
def bag_to_set(the_bag,):
	'''
	:param the_bag
	:type the_bag:(null)
	'''
	if (SIZEOF(the_bag)  >  0):
		for i in range(1,HIINDEX(the_bag),1):
			the_set = the_set  +  the_bag[i]
	return the_set

####################
 # FUNCTION build_axes #
####################
def build_axes(axis,ref_direction,):
	'''
	:param axis
	:type axis:direction
	:param ref_direction
	:type ref_direction:direction
	'''
	d1 = NVL(normalise(axis),dummy_gri  ==  direction([0,0,1]))
	d2 = first_proj_axis(d1,ref_direction)
	return [d2,normalise(cross_product(d1,d2)).orientation,d1]

####################
 # FUNCTION constraints_geometry_shell_based_wireframe_model #
####################
def constraints_geometry_shell_based_wireframe_model(m,):
	'''
	:param m
	:type m:shell_based_wireframe_model
	'''
	for j in range(1,SIZEOF(m.sbwm_boundary),1):
		if (( not ('CONFIG_CONTROL_DESIGN.WIRE_SHELL'  ==  TYPEOF(m.sbwm_boundary[j])))  and  ( not ('CONFIG_CONTROL_DESIGN.VERTEX_SHELL'  ==  TYPEOF(m.sbwm_boundary[j])))):
			result = FALSE
			return result
	return result

####################
 # FUNCTION scalar_times_vector #
####################
def scalar_times_vector(scalar,vec,):
	'''
	:param scalar
	:type scalar:REAL
	:param vec
	:type vec:vector_or_direction
	'''
	if (( not EXISTS(scalar))  or  ( not EXISTS(vec))):
		return  None 
	else:
		if ('CONFIG_CONTROL_DESIGN.VECTOR'  ==  TYPEOF(vec)):
			v = dummy_gri  ==  direction(vec.orientation.direction_ratios)
			mag = scalar  *  vec.magnitude
		else:
			v = dummy_gri  ==  direction(vec.direction_ratios)
			mag = scalar
		if (mag  <  0):
			for i in range(1,SIZEOF(v.direction_ratios),1):
				v.direction_ratios[i] = -v.direction_ratios[i]
			mag = -mag
		result = dummy_gri  ==  vector(normalise(v),mag)
	return result

####################
 # FUNCTION valid_geometrically_bounded_wf_curve #
####################
def valid_geometrically_bounded_wf_curve(crv,):
	'''
	:param crv
	:type crv:curve
	'''
	if (SIZEOF(['CONFIG_CONTROL_DESIGN.POLYLINE','CONFIG_CONTROL_DESIGN.B_SPLINE_CURVE','CONFIG_CONTROL_DESIGN.ELLIPSE','CONFIG_CONTROL_DESIGN.CIRCLE']  *  TYPEOF(crv))  ==  1):
		return TRUE
	else:
		if ('CONFIG_CONTROL_DESIGN.TRIMMED_CURVE'  ==  TYPEOF(crv)):
			if (SIZEOF(['CONFIG_CONTROL_DESIGN.LINE','CONFIG_CONTROL_DESIGN.PARABOLA','CONFIG_CONTROL_DESIGN.HYPERBOLA']  *  TYPEOF(crv.trimmed_curve.basis_curve))  ==  1):
				return TRUE
			else:
				return valid_geometrically_bounded_wf_curve(crv.trimmed_curve.basis_curve)
		else:
			if ('CONFIG_CONTROL_DESIGN.OFFSET_CURVE_3D'  ==  TYPEOF(crv)):
				return valid_geometrically_bounded_wf_curve(crv.offset_curve_3d.basis_curve)
			else:
				if ('CONFIG_CONTROL_DESIGN.CURVE_REPLICA'  ==  TYPEOF(crv)):
					return valid_geometrically_bounded_wf_curve(crv.curve_replica.parent_curve)
				else:
					if ('CONFIG_CONTROL_DESIGN.COMPOSITE_CURVE'  ==  TYPEOF(crv)):
						return SIZEOF(None)  ==  0
	return FALSE

####################
 # FUNCTION valid_wireframe_edge_curve #
####################
def valid_wireframe_edge_curve(crv,):
	'''
	:param crv
	:type crv:curve
	'''
	if (SIZEOF(['CONFIG_CONTROL_DESIGN.LINE','CONFIG_CONTROL_DESIGN.CONIC','CONFIG_CONTROL_DESIGN.B_SPLINE_CURVE','CONFIG_CONTROL_DESIGN.POLYLINE']  *  TYPEOF(crv))  ==  1):
		return TRUE
	else:
		if ('CONFIG_CONTROL_DESIGN.CURVE_REPLICA'  ==  TYPEOF(crv)):
			return valid_wireframe_edge_curve(crv.curve_replica.parent_curve)
		else:
			if ('CONFIG_CONTROL_DESIGN.OFFSET_CURVE_3D'  ==  TYPEOF(crv)):
				return valid_wireframe_edge_curve(crv.offset_curve_3d.basis_curve)
	return FALSE

####################
 # FUNCTION leap_year #
####################
def leap_year(year,):
	'''
	:param year
	:type year:INTEGER
	'''
	if ((((year  %  4)  ==  0)  and  ((year  %  100)  !=  0))  or  ((year  %  400)  ==  0)):
		return TRUE
	else:
		return FALSE

####################
 # FUNCTION orthogonal_complement #
####################
def orthogonal_complement(vec,):
	'''
	:param vec
	:type vec:direction
	'''
	if ((vec.dim  !=  2)  or  ( not EXISTS(vec))):
		return  None 
	else:
		result = dummy_gri  ==  direction([-vec.direction_ratios[2],vec.direction_ratios[1]])
		return result

####################
 # FUNCTION gbsf_check_curve #
####################
def gbsf_check_curve(cv,):
	'''
	:param cv
	:type cv:curve
	'''
	if (SIZEOF(['CONFIG_CONTROL_DESIGN.BOUNDED_CURVE','CONFIG_CONTROL_DESIGN.CONIC','CONFIG_CONTROL_DESIGN.CURVE_REPLICA','CONFIG_CONTROL_DESIGN.LINE','CONFIG_CONTROL_DESIGN.OFFSET_CURVE_3D']  *  TYPEOF(cv))  >  1):
		return FALSE
	else:
		if (SIZEOF(['CONFIG_CONTROL_DESIGN.CIRCLE','CONFIG_CONTROL_DESIGN.ELLIPSE']  *  TYPEOF(cv))  ==  1):
			return TRUE
		else:
			if ((('CONFIG_CONTROL_DESIGN.B_SPLINE_CURVE'  ==  TYPEOF(cv))  and  (cv.b_spline_curve.self_intersect  ==  FALSE))  or  (cv.b_spline_curve.self_intersect  ==  UNKNOWN)):
				return TRUE
			else:
				if ((('CONFIG_CONTROL_DESIGN.COMPOSITE_CURVE'  ==  TYPEOF(cv))  and  (cv.composite_curve.self_intersect  ==  FALSE))  or  (cv.composite_curve.self_intersect  ==  UNKNOWN)):
					return SIZEOF(None)  ==  0
				else:
					if ('CONFIG_CONTROL_DESIGN.CURVE_REPLICA'  ==  TYPEOF(cv)):
						return gbsf_check_curve(cv.curve_replica.parent_curve)
					else:
						if ((('CONFIG_CONTROL_DESIGN.OFFSET_CURVE_3D'  ==  TYPEOF(cv))  and  ((cv.offset_curve_3d.self_intersect  ==  FALSE)  or  (cv.offset_curve_3d.self_intersect  ==  UNKNOWN)))  and  ( not ('CONFIG_CONTROL_DESIGN.POLYLINE'  ==  TYPEOF(cv.basis_curve)))):
							return gbsf_check_curve(cv.offset_curve_3d.basis_curve)
						else:
							if ('CONFIG_CONTROL_DESIGN.PCURVE'  ==  TYPEOF(cv)):
								return gbsf_check_curve(cv.pcurve.reference_to_curve.representation.items[1])  and  gbsf_check_surface(cv.pcurve.basis_surface)
							else:
								if ('CONFIG_CONTROL_DESIGN.POLYLINE'  ==  TYPEOF(cv)):
									if (SIZEOF(cv.polyline.points)  >=  3):
										return TRUE
								else:
									if ('CONFIG_CONTROL_DESIGN.SURFACE_CURVE'  ==  TYPEOF(cv)):
										if (gbsf_check_curve(cv.surface_curve.curve_3d)):
											for i in range(1,SIZEOF(cv.surface_curve.associated_geometry),1):
												if ('CONFIG_CONTROL_DESIGN.SURFACE'  ==  TYPEOF(cv.surface_curve.associated_geometry[i])):
													if ( not gbsf_check_surface(cv.surface_curve.associated_geometry[i])):
														return FALSE
												else:
													if ('CONFIG_CONTROL_DESIGN.PCURVE'  ==  TYPEOF(cv.surface_curve.associated_geometry[i])):
														if ( not gbsf_check_curve(cv.surface_curve.associated_geometry[i])):
															return FALSE
											return TRUE
									else:
										if ('CONFIG_CONTROL_DESIGN.TRIMMED_CURVE'  ==  TYPEOF(cv)):
											if (SIZEOF(['CONFIG_CONTROL_DESIGN.LINE','CONFIG_CONTROL_DESIGN.PARABOLA','CONFIG_CONTROL_DESIGN.HYPERBOLA']  *  TYPEOF(cv.trimmed_curve.basis_curve))  ==  1):
												return TRUE
											else:
												return gbsf_check_curve(cv.trimmed_curve.basis_curve)
	return FALSE

####################
 # FUNCTION valid_wireframe_vertex_point #
####################
def valid_wireframe_vertex_point(pnt,):
	'''
	:param pnt
	:type pnt:point
	'''
	if ('CONFIG_CONTROL_DESIGN.CARTESIAN_POINT'  ==  TYPEOF(pnt)):
		return TRUE
	else:
		if ('CONFIG_CONTROL_DESIGN.POINT_REPLICA'  ==  TYPEOF(pnt)):
			return valid_wireframe_vertex_point(pnt.point_replica.parent_pt)
	return FALSE

####################
 # FUNCTION normalise #
####################
def normalise(arg,):
	'''
	:param arg
	:type arg:vector_or_direction
	'''
	if ( not EXISTS(arg)):
		result =  None 
	else:
		ndim = arg.dim
		if ('CONFIG_CONTROL_DESIGN.VECTOR'  ==  TYPEOF(arg)):
			# begin/end block
			v = dummy_gri  ==  direction(arg.orientation.direction_ratios)
			if (arg.magnitude  ==  0):
				return  None 
			else:
				vec = dummy_gri  ==  vector(v,1)
		else:
			v = dummy_gri  ==  direction(arg.direction_ratios)
		mag = 0
		for i in range(1,ndim,1):
			mag = mag  +  (v.direction_ratios[i]  *  v.direction_ratios[i])
		if (mag  >  0):
			mag = SQRT(mag)
			for i in range(1,ndim,1):
				v.direction_ratios[i] = v.direction_ratios[i] / mag
			if ('CONFIG_CONTROL_DESIGN.VECTOR'  ==  TYPEOF(arg)):
				vec.orientation = v
				result = vec
			else:
				result = v
		else:
			return  None 
	return result

####################
 # FUNCTION derive_dimensional_exponents #
####################
def derive_dimensional_exponents(x,):
	'''
	:param x
	:type x:unit
	'''
	result = x.dimensions
	return result

####################
 # FUNCTION acyclic_product_definition_relationship #
####################
def acyclic_product_definition_relationship(relation,relatives,specific_relation,):
	'''
	:param relation
	:type relation:product_definition_relationship
	:param relatives
	:type relatives:(null)
	:param specific_relation
	:type specific_relation:STRING
	'''
	if (relation.relating_product_definition  ==  relatives):
		return FALSE
	x = None
	for i in range(1,HIINDEX(x),1):
		if ( not acyclic_product_definition_relationship(x[i],relatives  +  relation.relating_product_definition,specific_relation)):
			return FALSE
	return TRUE

####################
 # FUNCTION make_array_of_array #
####################
def make_array_of_array(lis,low1,u1,low2,u2,):
	'''
	:param lis
	:type lis:(null)
	:param low1
	:type low1:INTEGER
	:param u1
	:type u1:INTEGER
	:param low2
	:type low2:INTEGER
	:param u2
	:type u2:INTEGER
	'''
	if (((u1 - low1)  +  1)  !=  SIZEOF(lis)):
		return  None 
	if (((u2 - low2)  +  1)  !=  SIZEOF(lis[1])):
		return  None 
	res = [list_to_array(lis[1],low2,u2),(u1 - low1)  +  1]
	for i in range(2,HIINDEX(lis),1):
		if (((u2 - low2)  +  1)  !=  SIZEOF(lis[i])):
			return  None 
		res[(low1  +  i) - 1] = list_to_array(lis[i],low2,u2)
	return res

####################
 # FUNCTION build_2axes #
####################
def build_2axes(ref_direction,):
	'''
	:param ref_direction
	:type ref_direction:direction
	'''
	return [d,orthogonal_complement(d)]

####################
 # FUNCTION mixed_loop_type_set #
####################
def mixed_loop_type_set(l,):
	'''
	:param l
	:type l:(null)
	'''
	if (SIZEOF(l)  <=  1):
		return FALSE
	poly_loop_type = 'CONFIG_CONTROL_DESIGN.POLY_LOOP'  ==  TYPEOF(l[1])
	for i in range(2,SIZEOF(l),1):
		if (('CONFIG_CONTROL_DESIGN.POLY_LOOP'  ==  TYPEOF(l[i]))  !=  poly_loop_type):
			return TRUE
	return FALSE

####################
 # FUNCTION second_proj_axis #
####################
def second_proj_axis(z_axis,x_axis,arg,):
	'''
	:param z_axis
	:type z_axis:direction
	:param x_axis
	:type x_axis:direction
	:param arg
	:type arg:direction
	'''
	if ( not EXISTS(arg)):
		v = dummy_gri  ==  direction([0,1,0])
	else:
		v = arg
	temp = scalar_times_vector(dot_product(v,z_axis),z_axis)
	y_axis = vector_difference(v,temp)
	temp = scalar_times_vector(dot_product(v,x_axis),x_axis)
	y_axis = vector_difference(y_axis,temp)
	y_axis = normalise(y_axis)
	return y_axis.orientation

####################
 # FUNCTION path_head_to_tail #
####################
def path_head_to_tail(a_path,):
	'''
	:param a_path
	:type a_path:path
	'''
	n = SIZEOF(a_path.edge_list)
	for i in range(2,n,1):
		p = p  and  (a_path.edge_list[i - 1].edge_end  ==  a_path.edge_list[i].edge_start)
	return p

####################
 # FUNCTION set_of_topology_reversed #
####################
def set_of_topology_reversed(a_set,):
	'''
	:param a_set
	:type a_set:set_of_reversible_topology_item
	'''
	the_reverse = []
	for i in range(1,SIZEOF(a_set),1):
		the_reverse = the_reverse  +  topology_reversed(a_set[i])
	return the_reverse

####################
 # FUNCTION valid_calendar_date #
####################
def valid_calendar_date(date,):
	'''
	:param date
	:type date:calendar_date
	'''
	if ( not ((1  <=  date.day_component)  and  (date.day_component  <=  31))):
		return FALSE
	case_selector = date.month_component
	if  case_selector == 4:
		return (1  <=  date.day_component)  and  (date.day_component  <=  30)
	elif case_selector == 6:
		return (1  <=  date.day_component)  and  (date.day_component  <=  30)
	elif case_selector == 9:
		return (1  <=  date.day_component)  and  (date.day_component  <=  30)
	elif case_selector == 11:
		return (1  <=  date.day_component)  and  (date.day_component  <=  30)
	elif case_selector == 2:
		# begin/end block
		if (leap_year(date.year_component)):
			return (1  <=  date.day_component)  and  (date.day_component  <=  29)
		else:
			return (1  <=  date.day_component)  and  (date.day_component  <=  28)
	else:
		return TRUE

####################
 # FUNCTION curve_weights_positive #
####################
def curve_weights_positive(b,):
	'''
	:param b
	:type b:rational_b_spline_curve
	'''
	for i in range(0,b.upper_index_on_control_points,1):
		if (b.weights[i]  <=  0):
			result = FALSE
			return result
	return result

####################
 # FUNCTION list_face_loops #
####################
def list_face_loops(f,):
	'''
	:param f
	:type f:face
	'''
	for i in range(1,SIZEOF(f.bounds),1):
		loops = loops  +  f.bounds[i].bound
	return loops

####################
 # FUNCTION gbsf_check_surface #
####################
def gbsf_check_surface(sf,):
	'''
	:param sf
	:type sf:surface
	'''
	if ((('CONFIG_CONTROL_DESIGN.B_SPLINE_SURFACE'  ==  TYPEOF(sf))  and  (sf.b_spline_surface.self_intersect  ==  FALSE))  or  (sf.b_spline_surface.self_intersect  ==  UNKNOWN)):
		return TRUE
	else:
		if (SIZEOF(['CONFIG_CONTROL_DESIGN.SPHERICAL_SURFACE','CONFIG_CONTROL_DESIGN.TOROIDAL_SURFACE']  *  TYPEOF(sf))  ==  1):
			return TRUE
		else:
			if ('CONFIG_CONTROL_DESIGN.CURVE_BOUNDED_SURFACE'  ==  TYPEOF(sf)):
				if (SIZEOF(['CONFIG_CONTROL_DESIGN.CONICAL_SURFACE','CONFIG_CONTROL_DESIGN.CYLINDRICAL_SURFACE','CONFIG_CONTROL_DESIGN.PLANE']  *  TYPEOF(sf.curve_bounded_surface.basis_surface))  ==  1):
					return SIZEOF(None)  ==  0
				else:
					if (gbsf_check_surface(sf.curve_bounded_surface.basis_surface)):
						return SIZEOF(None)  ==  0
			else:
				if ((('CONFIG_CONTROL_DESIGN.OFFSET_SURFACE'  ==  TYPEOF(sf))  and  (sf.offset_surface.self_intersect  ==  FALSE))  or  (sf.offset_surface.self_intersect  ==  UNKNOWN)):
					return gbsf_check_surface(sf.offset_surface.basis_surface)
				else:
					if ('CONFIG_CONTROL_DESIGN.RECTANGULAR_COMPOSITE_SURFACE'  ==  TYPEOF(sf)):
						for i in range(1,SIZEOF(sf.rectangular_composite_surface.segments),1):
							for j in range(1,SIZEOF(sf.rectangular_composite_surface.segments[i]),1):
								if ( not gbsf_check_surface(sf.rectangular_composite_surface.segments[i][j].parent_surface)):
									return FALSE
						return TRUE
					else:
						if ('CONFIG_CONTROL_DESIGN.RECTANGULAR_TRIMMED_SURFACE'  ==  TYPEOF(sf)):
							if (SIZEOF(['CONFIG_CONTROL_DESIGN.CONICAL_SURFACE','CONFIG_CONTROL_DESIGN.CYLINDRICAL_SURFACE','CONFIG_CONTROL_DESIGN.PLANE']  *  TYPEOF(sf.rectangular_trimmed_surface.basis_surface))  ==  1):
								return TRUE
							else:
								return gbsf_check_surface(sf.rectangular_trimmed_surface.basis_surface)
						else:
							if ('CONFIG_CONTROL_DESIGN.SURFACE_REPLICA'  ==  TYPEOF(sf)):
								return gbsf_check_surface(sf.surface_replica.parent_surface)
							else:
								if ('CONFIG_CONTROL_DESIGN.SWEPT_SURFACE'  ==  TYPEOF(sf)):
									return gbsf_check_curve(sf.swept_surface.swept_curve)
	return FALSE

####################
 # FUNCTION boolean_choose #
####################
def boolean_choose(b,choice1,choice2,):
	'''
	:param b
	:type b:BOOLEAN
	:param choice1
	:type choice1:(null)
	:param choice2
	:type choice2:(null)
	'''
	if (b):
		return choice1
	else:
		return choice2

####################
 # FUNCTION msf_surface_check #
####################
def msf_surface_check(surf,):
	'''
	:param surf
	:type surf:surface
	'''
	if ('CONFIG_CONTROL_DESIGN.ELEMENTARY_SURFACE'  ==  TYPEOF(surf)):
		return TRUE
	else:
		if ('CONFIG_CONTROL_DESIGN.SWEPT_SURFACE'  ==  TYPEOF(surf)):
			return msf_curve_check(surf.swept_surface.swept_curve)
		else:
			if ((('CONFIG_CONTROL_DESIGN.OFFSET_SURFACE'  ==  TYPEOF(surf))  and  (surf.offset_surface.self_intersect  ==  FALSE))  or  (surf.offset_surface.self_intersect  ==  UNKNOWN)):
				return msf_surface_check(surf.offset_surface.basis_surface)
			else:
				if ('CONFIG_CONTROL_DESIGN.SURFACE_REPLICA'  ==  TYPEOF(surf)):
					return msf_surface_check(surf.surface_replica.parent_surface)
				else:
					if ((('CONFIG_CONTROL_DESIGN.B_SPLINE_SURFACE'  ==  TYPEOF(surf))  and  (surf.b_spline_surface.self_intersect  ==  FALSE))  or  (surf.b_spline_surface.self_intersect  ==  UNKNOWN)):
						return TRUE
	return FALSE

####################
 # FUNCTION path_reversed #
####################
def path_reversed(a_path,):
	'''
	:param a_path
	:type a_path:path
	'''
	if ('CONFIG_CONTROL_DESIGN.ORIENTED_PATH'  ==  TYPEOF(a_path)):
		the_reverse = (dummy_tri  ==  path(list_of_topology_reversed(a_path.edge_list)))  ==  oriented_path(a_path.oriented_path.path_element, not a_path.oriented_path.orientation)
	else:
		the_reverse = (dummy_tri  ==  path(list_of_topology_reversed(a_path.edge_list)))  ==  oriented_path(a_path,FALSE)
	return the_reverse

####################
 # FUNCTION valid_measure_value #
####################
def valid_measure_value(m,):
	'''
	:param m
	:type m:measure_value
	'''
	if ('REAL'  ==  TYPEOF(m)):
		return m  >  0
	else:
		if ('INTEGER'  ==  TYPEOF(m)):
			return m  >  0
		else:
			return TRUE

####################
 # FUNCTION constraints_composite_curve_on_surface #
####################
def constraints_composite_curve_on_surface(c,):
	'''
	:param c
	:type c:composite_curve_on_surface
	'''
	for k in range(1,n_segments,1):
		if ((( not ('CONFIG_CONTROL_DESIGN.PCURVE'  ==  TYPEOF(c.composite_curve.segments[k].parent_curve)))  and  ( not ('CONFIG_CONTROL_DESIGN.SURFACE_CURVE'  ==  TYPEOF(c.composite_curve.segments[k].parent_curve))))  and  ( not ('CONFIG_CONTROL_DESIGN.COMPOSITE_CURVE_ON_SURFACE'  ==  TYPEOF(c.composite_curve.segments[k].parent_curve)))):
			return FALSE
	return TRUE

####################
 # FUNCTION dimension_of #
####################
def dimension_of(item,):
	'''
	:param item
	:type item:geometric_representation_item
	'''
	x = using_representations(item)
	y = x[1].context_of_items
	return y.geometric_representation_context.coordinate_space_dimension

####################
 # FUNCTION unique_version_change_order #
####################
def unique_version_change_order(c,):
	'''
	:param c
	:type c:action
	'''
	for i in range(1,SIZEOF(ords.requests),1):
		assign = assign  +  None
	for k in range(1,SIZEOF(assign),1):
		versions = versions  +  assign[k].items
	return SIZEOF(None)  ==  0

####################
 # FUNCTION acyclic_point_replica #
####################
def acyclic_point_replica(rep,parent,):
	'''
	:param rep
	:type rep:point_replica
	:param parent
	:type parent:point
	'''
	if ( not ('CONFIG_CONTROL_DESIGN.POINT_REPLICA'  ==  TYPEOF(parent))):
		return TRUE
	if (parent  ==  rep):
		return FALSE
	else:
		return acyclic_point_replica(rep,parent.point_replica.parent_pt)

####################
 # FUNCTION cross_product #
####################
def cross_product(arg1,arg2,):
	'''
	:param arg1
	:type arg1:direction
	:param arg2
	:type arg2:direction
	'''
	if (((( not EXISTS(arg1))  or  (arg1.dim  ==  2))  or  ( not EXISTS(arg2)))  or  (arg2.dim  ==  2)):
		return  None 
	else:
		# begin/end block
		v1 = normalise(arg1).direction_ratios
		v2 = normalise(arg2).direction_ratios
		res = dummy_gri  ==  direction([(v1[2]  *  v2[3]) - (v1[3]  *  v2[2]),(v1[3]  *  v2[1]) - (v1[1]  *  v2[3]),(v1[1]  *  v2[2]) - (v1[2]  *  v2[1])])
		mag = 0
		for i in range(1,3,1):
			mag = mag  +  (res.direction_ratios[i]  *  res.direction_ratios[i])
		if (mag  >  0):
			result = dummy_gri  ==  vector(res,SQRT(mag))
		else:
			result = dummy_gri  ==  vector(arg1,0)
		return result

####################
 # FUNCTION face_bound_reversed #
####################
def face_bound_reversed(a_face_bound,):
	'''
	:param a_face_bound
	:type a_face_bound:face_bound
	'''
	if ('CONFIG_CONTROL_DESIGN.FACE_OUTER_BOUND'  ==  TYPEOF(a_face_bound)):
		the_reverse = (dummy_tri  ==  face_bound(a_face_bound.face_bound.bound, not a_face_bound.face_bound.orientation))  ==  face_outer_bound()
	else:
		the_reverse = dummy_tri  ==  face_bound(a_face_bound.bound, not a_face_bound.orientation)
	return the_reverse

####################
 # FUNCTION constraints_geometry_shell_based_surface_model #
####################
def constraints_geometry_shell_based_surface_model(m,):
	'''
	:param m
	:type m:shell_based_surface_model
	'''
	for j in range(1,SIZEOF(m.sbsm_boundary),1):
		if (( not ('CONFIG_CONTROL_DESIGN.OPEN_SHELL'  ==  TYPEOF(m.sbsm_boundary[j])))  and  ( not ('CONFIG_CONTROL_DESIGN.CLOSED_SHELL'  ==  TYPEOF(m.sbsm_boundary[j])))):
			result = FALSE
			return result
	return result

####################
 # FUNCTION shell_reversed #
####################
def shell_reversed(a_shell,):
	'''
	:param a_shell
	:type a_shell:shell
	'''
	if ('CONFIG_CONTROL_DESIGN.OPEN_SHELL'  ==  TYPEOF(a_shell)):
		return open_shell_reversed(a_shell)
	else:
		if ('CONFIG_CONTROL_DESIGN.CLOSED_SHELL'  ==  TYPEOF(a_shell)):
			return closed_shell_reversed(a_shell)
		else:
			return  None 

####################
 # FUNCTION cc_design_date_time_correlation #
####################
def cc_design_date_time_correlation(e,):
	'''
	:param e
	:type e:cc_design_date_and_time_assignment
	'''
	dt_role = e.date_and_time_assignment.role.name
	case_selector = dt_role
	if  case_selector == 'creation_date':
		if (SIZEOF(e.items)  !=  SIZEOF(None)):
			return FALSE
	elif case_selector == 'request_date':
		if (SIZEOF(e.items)  !=  SIZEOF(None)):
			return FALSE
	elif case_selector == 'release_date':
		if (SIZEOF(e.items)  !=  SIZEOF(None)):
			return FALSE
	elif case_selector == 'start_date':
		if (SIZEOF(e.items)  !=  SIZEOF(None)):
			return FALSE
	elif case_selector == 'sign_off_date':
		if (SIZEOF(e.items)  !=  SIZEOF(None)):
			return FALSE
	elif case_selector == 'contract_date':
		if (SIZEOF(e.items)  !=  SIZEOF(None)):
			return FALSE
	elif case_selector == 'certification_date':
		if (SIZEOF(e.items)  !=  SIZEOF(None)):
			return FALSE
	elif case_selector == 'classification_date':
		if (SIZEOF(e.items)  !=  SIZEOF(None)):
			return FALSE
	elif case_selector == 'declassification_date':
		if (SIZEOF(e.items)  !=  SIZEOF(None)):
			return FALSE
	else:
		return TRUE
	return TRUE

####################
 # FUNCTION cc_design_person_and_organization_correlation #
####################
def cc_design_person_and_organization_correlation(e,):
	'''
	:param e
	:type e:cc_design_person_and_organization_assignment
	'''
	po_role = e.person_and_organization_assignment.role.name
	case_selector = po_role
	if  case_selector == 'request_recipient':
		if (SIZEOF(e.items)  !=  SIZEOF(None)):
			return FALSE
	elif case_selector == 'initiator':
		if (SIZEOF(e.items)  !=  SIZEOF(None)):
			return FALSE
	elif case_selector == 'creator':
		if (SIZEOF(e.items)  !=  SIZEOF(None)):
			return FALSE
	elif case_selector == 'part_supplier':
		if (SIZEOF(e.items)  !=  SIZEOF(None)):
			return FALSE
	elif case_selector == 'design_supplier':
		if (SIZEOF(e.items)  !=  SIZEOF(None)):
			return FALSE
	elif case_selector == 'design_owner':
		if (SIZEOF(e.items)  !=  SIZEOF(None)):
			return FALSE
	elif case_selector == 'configuration_manager':
		if (SIZEOF(e.items)  !=  SIZEOF(None)):
			return FALSE
	elif case_selector == 'contractor':
		if (SIZEOF(e.items)  !=  SIZEOF(None)):
			return FALSE
	elif case_selector == 'classification_officer':
		if (SIZEOF(e.items)  !=  SIZEOF(None)):
			return FALSE
	else:
		return TRUE
	return TRUE

####################
 # FUNCTION get_basis_surface #
####################
def get_basis_surface(c,):
	'''
	:param c
	:type c:curve_on_surface
	'''
	surfs = []
	if ('CONFIG_CONTROL_DESIGN.PCURVE'  ==  TYPEOF(c)):
		surfs = [c.pcurve.basis_surface]
	else:
		if ('CONFIG_CONTROL_DESIGN.SURFACE_CURVE'  ==  TYPEOF(c)):
			n = SIZEOF(c.surface_curve.associated_geometry)
			for i in range(1,n,1):
				surfs = surfs  +  associated_surface(c.surface_curve.associated_geometry[i])
	if ('CONFIG_CONTROL_DESIGN.COMPOSITE_CURVE_ON_SURFACE'  ==  TYPEOF(c)):
		n = SIZEOF(c.composite_curve.segments)
		surfs = get_basis_surface(c.composite_curve.segments[1].parent_curve)
		if (n  >  1):
			for i in range(2,n,1):
				surfs = surfs  *  get_basis_surface(c.composite_curve.segments[i].parent_curve)
	return surfs

####################
 # FUNCTION dot_product #
####################
def dot_product(arg1,arg2,):
	'''
	:param arg1
	:type arg1:direction
	:param arg2
	:type arg2:direction
	'''
	if (( not EXISTS(arg1))  or  ( not EXISTS(arg2))):
		scalar =  None 
	else:
		if (arg1.dim  !=  arg2.dim):
			scalar =  None 
		else:
			# begin/end block
			vec1 = normalise(arg1)
			vec2 = normalise(arg2)
			ndim = arg1.dim
			scalar = 0
			for i in range(1,ndim,1):
				scalar = scalar  +  (vec1.direction_ratios[i]  *  vec2.direction_ratios[i])
	return scalar

####################
 # FUNCTION list_of_topology_reversed #
####################
def list_of_topology_reversed(a_list,):
	'''
	:param a_list
	:type a_list:list_of_reversible_topology_item
	'''
	the_reverse = []
	for i in range(1,SIZEOF(a_list),1):
		the_reverse = topology_reversed(a_list[i])  +  the_reverse
	return the_reverse

####################
 # FUNCTION acyclic_mapped_representation #
####################
def acyclic_mapped_representation(parent_set,children_set,):
	'''
	:param parent_set
	:type parent_set:(null)
	:param children_set
	:type children_set:(null)
	'''
	x = None
	if (SIZEOF(x)  >  0):
		for i in range(1,HIINDEX(x),1):
			if (x[i].mapped_item.mapping_source.mapped_representation  ==  parent_set):
				return FALSE
			if ( not acyclic_mapped_representation(parent_set  +  x[i].mapped_item.mapping_source.mapped_representation,x[i].mapped_item.mapping_source.mapped_representation.items)):
				return FALSE
	x = children_set - x
	if (SIZEOF(x)  >  0):
		for i in range(1,HIINDEX(x),1):
			y = None
			if ( not acyclic_mapped_representation(parent_set,y)):
				return FALSE
	return TRUE

####################
 # FUNCTION base_axis #
####################
def base_axis(dim,axis1,axis2,axis3,):
	'''
	:param dim
	:type dim:INTEGER
	:param axis1
	:type axis1:direction
	:param axis2
	:type axis2:direction
	:param axis3
	:type axis3:direction
	'''
	if (dim  ==  3):
		d1 = NVL(normalise(axis3),dummy_gri  ==  direction([0,0,1]))
		d2 = first_proj_axis(d1,axis1)
		u = [d2,second_proj_axis(d1,d2,axis2),d1]
	else:
		if (EXISTS(axis1)):
			d1 = normalise(axis1)
			u = [d1,orthogonal_complement(d1)]
			if (EXISTS(axis2)):
				factor = dot_product(axis2,u[2])
				if (factor  <  0):
					u[2].direction_ratios[1] = -u[2].direction_ratios[1]
					u[2].direction_ratios[2] = -u[2].direction_ratios[2]
		else:
			if (EXISTS(axis2)):
				d1 = normalise(axis2)
				u = [orthogonal_complement(d1),d1]
				u[1].direction_ratios[1] = -u[1].direction_ratios[1]
				u[1].direction_ratios[2] = -u[1].direction_ratios[2]
			else:
				u = [dummy_gri  ==  direction([1,0]),dummy_gri  ==  direction([0,1])]
	return u

####################
 # FUNCTION acyclic_curve_replica #
####################
def acyclic_curve_replica(rep,parent,):
	'''
	:param rep
	:type rep:curve_replica
	:param parent
	:type parent:curve
	'''
	if ( not ('CONFIG_CONTROL_DESIGN.CURVE_REPLICA'  ==  TYPEOF(parent))):
		return TRUE
	if (parent  ==  rep):
		return FALSE
	else:
		return acyclic_curve_replica(rep,parent.curve_replica.parent_curve)

####################
 # FUNCTION face_reversed #
####################
def face_reversed(a_face,):
	'''
	:param a_face
	:type a_face:face
	'''
	if ('CONFIG_CONTROL_DESIGN.ORIENTED_FACE'  ==  TYPEOF(a_face)):
		the_reverse = (dummy_tri  ==  face(set_of_topology_reversed(a_face.bounds)))  ==  oriented_face(a_face.oriented_face.face_element, not a_face.oriented_face.orientation)
	else:
		the_reverse = (dummy_tri  ==  face(set_of_topology_reversed(a_face.bounds)))  ==  oriented_face(a_face,FALSE)
	return the_reverse

####################
 # FUNCTION edge_reversed #
####################
def edge_reversed(an_edge,):
	'''
	:param an_edge
	:type an_edge:edge
	'''
	if ('CONFIG_CONTROL_DESIGN.ORIENTED_EDGE'  ==  TYPEOF(an_edge)):
		the_reverse = (dummy_tri  ==  edge(an_edge.edge_end,an_edge.edge_start))  ==  oriented_edge(an_edge.oriented_edge.edge_element, not an_edge.oriented_edge.orientation)
	else:
		the_reverse = (dummy_tri  ==  edge(an_edge.edge_end,an_edge.edge_start))  ==  oriented_edge(an_edge,FALSE)
	return the_reverse

####################
 # FUNCTION list_to_set #
####################
def list_to_set(l,):
	'''
	:param l
	:type l:(null)
	'''
	for i in range(1,SIZEOF(l),1):
		s = s  +  l[i]
	return s

####################
 # FUNCTION constraints_param_b_spline #
####################
def constraints_param_b_spline(degree,up_knots,up_cp,knot_mult,knots,):
	'''
	:param degree
	:type degree:INTEGER
	:param up_knots
	:type up_knots:INTEGER
	:param up_cp
	:type up_cp:INTEGER
	:param knot_mult
	:type knot_mult:(null)
	:param knots
	:type knots:(null)
	'''
	sum = knot_mult[1]
	for i in range(2,up_knots,1):
		sum = sum  +  knot_mult[i]
	if ((((degree  <  1)  or  (up_knots  <  2))  or  (up_cp  <  degree))  or  (sum  !=  ((degree  +  up_cp)  +  2))):
		result = FALSE
		return result
	k = knot_mult[1]
	if ((k  <  1)  or  (k  >  (degree  +  1))):
		result = FALSE
		return result
	for i in range(2,up_knots,1):
		if ((knot_mult[i]  <  1)  or  (knots[i]  <=  knots[i - 1])):
			result = FALSE
			return result
		k = knot_mult[i]
		if ((i  <  up_knots)  and  (k  >  degree)):
			result = FALSE
			return result
		if ((i  ==  up_knots)  and  (k  >  (degree  +  1))):
			result = FALSE
			return result
	return result

####################
 # FUNCTION item_in_context #
####################
def item_in_context(item,cntxt,):
	'''
	:param item
	:type item:representation_item
	:param cntxt
	:type cntxt:representation_context
	'''
	if (SIZEOF(USEDIN(item,'CONFIG_CONTROL_DESIGN.REPRESENTATION.ITEMS')  *  cntxt.representations_in_context)  >  0):
		return TRUE
	else:
		y = None
		if (SIZEOF(y)  >  0):
			for i in range(1,HIINDEX(y),1):
				if (item_in_context(y[i],cntxt)):
					return TRUE
	return FALSE

####################
 # FUNCTION valid_units #
####################
def valid_units(m,):
	'''
	:param m
	:type m:measure_with_unit
	'''
	if ('CONFIG_CONTROL_DESIGN.LENGTH_MEASURE'  ==  TYPEOF(m.value_component)):
		if (derive_dimensional_exponents(m.unit_component)  !=  dimensional_exponents(1,0,0,0,0,0,0)):
			return FALSE
	if ('CONFIG_CONTROL_DESIGN.MASS_MEASURE'  ==  TYPEOF(m.value_component)):
		if (derive_dimensional_exponents(m.unit_component)  !=  dimensional_exponents(0,1,0,0,0,0,0)):
			return FALSE
	if ('CONFIG_CONTROL_DESIGN.TIME_MEASURE'  ==  TYPEOF(m.value_component)):
		if (derive_dimensional_exponents(m.unit_component)  !=  dimensional_exponents(0,0,1,0,0,0,0)):
			return FALSE
	if ('CONFIG_CONTROL_DESIGN.ELECTRIC_CURRENT_MEASURE'  ==  TYPEOF(m.value_component)):
		if (derive_dimensional_exponents(m.unit_component)  !=  dimensional_exponents(0,0,0,1,0,0,0)):
			return FALSE
	if ('CONFIG_CONTROL_DESIGN.THERMODYNAMIC_TEMPERATURE_MEASURE'  ==  TYPEOF(m.value_component)):
		if (derive_dimensional_exponents(m.unit_component)  !=  dimensional_exponents(0,0,0,0,1,0,0)):
			return FALSE
	if ('CONFIG_CONTROL_DESIGN.AMOUNT_OF_SUBSTANCE_MEASURE'  ==  TYPEOF(m.value_component)):
		if (derive_dimensional_exponents(m.unit_component)  !=  dimensional_exponents(0,0,0,0,0,1,0)):
			return FALSE
	if ('CONFIG_CONTROL_DESIGN.LUMINOUS_INTENSITY_MEASURE'  ==  TYPEOF(m.value_component)):
		if (derive_dimensional_exponents(m.unit_component)  !=  dimensional_exponents(0,0,0,0,0,0,1)):
			return FALSE
	if ('CONFIG_CONTROL_DESIGN.PLANE_ANGLE_MEASURE'  ==  TYPEOF(m.value_component)):
		if (derive_dimensional_exponents(m.unit_component)  !=  dimensional_exponents(0,0,0,0,0,0,0)):
			return FALSE
	if ('CONFIG_CONTROL_DESIGN.SOLID_ANGLE_MEASURE'  ==  TYPEOF(m.value_component)):
		if (derive_dimensional_exponents(m.unit_component)  !=  dimensional_exponents(0,0,0,0,0,0,0)):
			return FALSE
	if ('CONFIG_CONTROL_DESIGN.AREA_MEASURE'  ==  TYPEOF(m.value_component)):
		if (derive_dimensional_exponents(m.unit_component)  !=  dimensional_exponents(2,0,0,0,0,0,0)):
			return FALSE
	if ('CONFIG_CONTROL_DESIGN.VOLUME_MEASURE'  ==  TYPEOF(m.value_component)):
		if (derive_dimensional_exponents(m.unit_component)  !=  dimensional_exponents(3,0,0,0,0,0,0)):
			return FALSE
	if ('CONFIG_CONTROL_DESIGN.RATIO_MEASURE'  ==  TYPEOF(m.value_component)):
		if (derive_dimensional_exponents(m.unit_component)  !=  dimensional_exponents(0,0,0,0,0,0,0)):
			return FALSE
	if ('CONFIG_CONTROL_DESIGN.POSITIVE_LENGTH_MEASURE'  ==  TYPEOF(m.value_component)):
		if (derive_dimensional_exponents(m.unit_component)  !=  dimensional_exponents(1,0,0,0,0,0,0)):
			return FALSE
	if ('CONFIG_CONTROL_DESIGN.POSITIVE_PLANE_ANGLE_MEASURE'  ==  TYPEOF(m.value_component)):
		if (derive_dimensional_exponents(m.unit_component)  !=  dimensional_exponents(0,0,0,0,0,0,0)):
			return FALSE
	return TRUE

####################
 # FUNCTION acyclic_product_category_relationship #
####################
def acyclic_product_category_relationship(relation,children,):
	'''
	:param relation
	:type relation:product_category_relationship
	:param children
	:type children:(null)
	'''
	for i in range(1,HIINDEX(children),1):
		if (relation.category  ==  children[i]):
			return FALSE
	x = bag_to_set(USEDIN(relation.category,'CONFIG_CONTROL_DESIGN.'  +  'PRODUCT_CATEGORY_RELATIONSHIP.SUB_CATEGORY'))
	local_children = children  +  relation.category
	if (SIZEOF(x)  >  0):
		for i in range(1,HIINDEX(x),1):
			if ( not acyclic_product_category_relationship(x[i],local_children)):
				return FALSE
	return TRUE

####################
 # FUNCTION assembly_shape_is_defined #
####################
def assembly_shape_is_defined(assy,schma,):
	'''
	:param assy
	:type assy:next_assembly_usage_occurrence
	:param schma
	:type schma:STRING
	'''
	pr1_set = bag_to_set(USEDIN(assy.related_product_definition,schma  +  '.PROPERTY_DEFINITION.DEFINITION'))
	for i in range(1,HIINDEX(pr1_set),1):
		sdr_set = sdr_set  +  None
	pdrel_set = bag_to_set(USEDIN(assy.related_product_definition,(schma  +  '.PRODUCT_DEFINITION_RELATIONSHIP.')  +  'RELATED_PRODUCT_DEFINITION'))
	for j in range(1,HIINDEX(pdrel_set),1):
		pr2_set = pr2_set  +  USEDIN(pdrel_set[j],schma  +  '.PROPERTY_DEFINITION.DEFINITION')
	for i in range(1,HIINDEX(pr2_set),1):
		sdr_set = sdr_set  +  None
	if (SIZEOF(sdr_set)  >  0):
		for i in range(1,HIINDEX(sdr_set),1):
			srr_set = None
			if (SIZEOF(srr_set)  >  0):
				for j in range(1,HIINDEX(srr_set),1):
					if (SIZEOF(None  *  None)  >=  1):
						if (SIZEOF(None)  >  0):
							return FALSE
	return TRUE

####################
 # FUNCTION first_proj_axis #
####################
def first_proj_axis(z_axis,arg,):
	'''
	:param z_axis
	:type z_axis:direction
	:param arg
	:type arg:direction
	'''
	if ( not EXISTS(z_axis)):
		return  None 
	else:
		z = normalise(z_axis)
		if ( not EXISTS(arg)):
			if (z.direction_ratios  !=  [1,0,0]):
				v = dummy_gri  ==  direction([1,0,0])
			else:
				v = dummy_gri  ==  direction([0,1,0])
		else:
			if (arg.dim  !=  3):
				return  None 
			if (cross_product(arg,z).magnitude  ==  0):
				return  None 
			else:
				v = normalise(arg)
		x_vec = scalar_times_vector(dot_product(v,z),z)
		x_axis = vector_difference(v,x_vec).orientation
		x_axis = normalise(x_axis)
	return x_axis

####################
 # FUNCTION surface_weights_positive #
####################
def surface_weights_positive(b,):
	'''
	:param b
	:type b:rational_b_spline_surface
	'''
	for i in range(0,b.u_upper,1):
		for j in range(0,b.v_upper,1):
			if (b.weights[i][j]  <=  0):
				result = FALSE
				return result
	return result

####################
 # FUNCTION conditional_reverse #
####################
def conditional_reverse(p,an_item,):
	'''
	:param p
	:type p:BOOLEAN
	:param an_item
	:type an_item:reversible_topology
	'''
	if (p):
		return an_item
	else:
		return topology_reversed(an_item)

####################
 # FUNCTION dimensions_for_si_unit #
####################
def dimensions_for_si_unit(n,):
	'''
	:param n
	:type n:si_unit_name
	'''
	case_selector = n
	if  case_selector == metre:
		return dimensional_exponents(1,0,0,0,0,0,0)
	elif case_selector == gram:
		return dimensional_exponents(0,1,0,0,0,0,0)
	elif case_selector == second:
		return dimensional_exponents(0,0,1,0,0,0,0)
	elif case_selector == ampere:
		return dimensional_exponents(0,0,0,1,0,0,0)
	elif case_selector == kelvin:
		return dimensional_exponents(0,0,0,0,1,0,0)
	elif case_selector == mole:
		return dimensional_exponents(0,0,0,0,0,1,0)
	elif case_selector == candela:
		return dimensional_exponents(0,0,0,0,0,0,1)
	elif case_selector == radian:
		return dimensional_exponents(0,0,0,0,0,0,0)
	elif case_selector == steradian:
		return dimensional_exponents(0,0,0,0,0,0,0)
	elif case_selector == hertz:
		return dimensional_exponents(0,0,-1,0,0,0,0)
	elif case_selector == newton:
		return dimensional_exponents(1,1,-2,0,0,0,0)
	elif case_selector == pascal:
		return dimensional_exponents(-1,1,-2,0,0,0,0)
	elif case_selector == joule:
		return dimensional_exponents(2,1,-2,0,0,0,0)
	elif case_selector == watt:
		return dimensional_exponents(2,1,-3,0,0,0,0)
	elif case_selector == coulomb:
		return dimensional_exponents(0,0,1,1,0,0,0)
	elif case_selector == volt:
		return dimensional_exponents(2,1,-3,-1,0,0,0)
	elif case_selector == farad:
		return dimensional_exponents(-2,-1,4,1,0,0,0)
	elif case_selector == ohm:
		return dimensional_exponents(2,1,-3,-2,0,0,0)
	elif case_selector == siemens:
		return dimensional_exponents(-2,-1,3,2,0,0,0)
	elif case_selector == weber:
		return dimensional_exponents(2,1,-2,-1,0,0,0)
	elif case_selector == tesla:
		return dimensional_exponents(0,1,-2,-1,0,0,0)
	elif case_selector == henry:
		return dimensional_exponents(2,1,-2,-2,0,0,0)
	elif case_selector == degree_celsius:
		return dimensional_exponents(0,0,0,0,1,0,0)
	elif case_selector == lumen:
		return dimensional_exponents(0,0,0,0,0,0,1)
	elif case_selector == lux:
		return dimensional_exponents(-2,0,0,0,0,0,1)
	elif case_selector == becquerel:
		return dimensional_exponents(0,0,-1,0,0,0,0)
	elif case_selector == gray:
		return dimensional_exponents(2,0,-2,0,0,0,0)
	elif case_selector == sievert:
		return dimensional_exponents(2,0,-2,0,0,0,0)

####################
 # FUNCTION open_shell_reversed #
####################
def open_shell_reversed(a_shell,):
	'''
	:param a_shell
	:type a_shell:open_shell
	'''
	if ('CONFIG_CONTROL_DESIGN.ORIENTED_OPEN_SHELL'  ==  TYPEOF(a_shell)):
		the_reverse = ((dummy_tri  ==  connected_face_set(a_shell.connected_face_set.cfs_faces))  ==  open_shell())  ==  oriented_open_shell(a_shell.oriented_open_shell.open_shell_element, not a_shell.oriented_open_shell.orientation)
	else:
		the_reverse = ((dummy_tri  ==  connected_face_set(a_shell.connected_face_set.cfs_faces))  ==  open_shell())  ==  oriented_open_shell(a_shell,FALSE)
	return the_reverse

####################
 # FUNCTION valid_geometrically_bounded_wf_point #
####################
def valid_geometrically_bounded_wf_point(pnt,):
	'''
	:param pnt
	:type pnt:point
	'''
	if ('CONFIG_CONTROL_DESIGN.CARTESIAN_POINT'  ==  TYPEOF(pnt)):
		return TRUE
	else:
		if ('CONFIG_CONTROL_DESIGN.POINT_ON_CURVE'  ==  TYPEOF(pnt)):
			return valid_geometrically_bounded_wf_curve(pnt.point_on_curve.basis_curve)
		else:
			if ('CONFIG_CONTROL_DESIGN.POINT_REPLICA'  ==  TYPEOF(pnt)):
				return valid_geometrically_bounded_wf_point(pnt.point_replica.parent_pt)
	return FALSE

####################
 # FUNCTION associated_surface #
####################
def associated_surface(arg,):
	'''
	:param arg
	:type arg:pcurve_or_surface
	'''
	if ('CONFIG_CONTROL_DESIGN.PCURVE'  ==  TYPEOF(arg)):
		surf = arg.basis_surface
	else:
		surf = arg
	return surf

####################
 # FUNCTION constraints_rectangular_composite_surface #
####################
def constraints_rectangular_composite_surface(s,):
	'''
	:param s
	:type s:rectangular_composite_surface
	'''
	for i in range(1,s.n_u,1):
		for j in range(1,s.n_v,1):
			if ( not (('CONFIG_CONTROL_DESIGN.B_SPLINE_SURFACE'  ==  TYPEOF(s.segments[i][j].parent_surface))  or  ('CONFIG_CONTROL_DESIGN.RECTANGULAR_TRIMMED_SURFACE'  ==  TYPEOF(s.segments[i][j].parent_surface)))):
				return FALSE
	for i in range(1,s.n_u - 1,1):
		for j in range(1,s.n_v,1):
			if (s.segments[i][j].u_transition  ==  discontinuous):
				return FALSE
	for i in range(1,s.n_u,1):
		for j in range(1,s.n_v - 1,1):
			if (s.segments[i][j].v_transition  ==  discontinuous):
				return FALSE
	return TRUE

####################
 # FUNCTION vector_difference #
####################
def vector_difference(arg1,arg2,):
	'''
	:param arg1
	:type arg1:vector_or_direction
	:param arg2
	:type arg2:vector_or_direction
	'''
	if ((( not EXISTS(arg1))  or  ( not EXISTS(arg2)))  or  (arg1.dim  !=  arg2.dim)):
		return  None 
	else:
		# begin/end block
		if ('CONFIG_CONTROL_DESIGN.VECTOR'  ==  TYPEOF(arg1)):
			mag1 = arg1.magnitude
			vec1 = arg1.orientation
		else:
			mag1 = 1
			vec1 = arg1
		if ('CONFIG_CONTROL_DESIGN.VECTOR'  ==  TYPEOF(arg2)):
			mag2 = arg2.magnitude
			vec2 = arg2.orientation
		else:
			mag2 = 1
			vec2 = arg2
		vec1 = normalise(vec1)
		vec2 = normalise(vec2)
		ndim = SIZEOF(vec1.direction_ratios)
		mag = 0
		res = dummy_gri  ==  direction(vec1.direction_ratios)
		for i in range(1,ndim,1):
			res.direction_ratios[i] = (mag1  *  vec1.direction_ratios[i])  +  (mag2  *  vec2.direction_ratios[i])
			mag = mag  +  (res.direction_ratios[i]  *  res.direction_ratios[i])
		if (mag  >  0):
			result = dummy_gri  ==  vector(res,SQRT(mag))
		else:
			result = dummy_gri  ==  vector(vec1,0)
	return result

####################
 # FUNCTION acyclic_surface_replica #
####################
def acyclic_surface_replica(rep,parent,):
	'''
	:param rep
	:type rep:surface_replica
	:param parent
	:type parent:surface
	'''
	if ( not ('CONFIG_CONTROL_DESIGN.SURFACE_REPLICA'  ==  TYPEOF(parent))):
		return TRUE
	if (parent  ==  rep):
		return FALSE
	else:
		return acyclic_surface_replica(rep,parent.surface_replica.parent_surface)

####################
 # FUNCTION list_to_array #
####################
def list_to_array(lis,low,u,):
	'''
	:param lis
	:type lis:(null)
	:param low
	:type low:INTEGER
	:param u
	:type u:INTEGER
	'''
	n = SIZEOF(lis)
	if (n  !=  ((u - low)  +  1)):
		return  None 
	else:
		res = [lis[1],n]
		for i in range(2,n,1):
			res[(low  +  i) - 1] = lis[i]
		return res

####################
 # FUNCTION msf_curve_check #
####################
def msf_curve_check(cv,):
	'''
	:param cv
	:type cv:curve
	'''
	if (SIZEOF(['CONFIG_CONTROL_DESIGN.BOUNDED_CURVE','CONFIG_CONTROL_DESIGN.CONIC','CONFIG_CONTROL_DESIGN.CURVE_REPLICA','CONFIG_CONTROL_DESIGN.LINE','CONFIG_CONTROL_DESIGN.OFFSET_CURVE_3D']  *  TYPEOF(cv))  >  1):
		return FALSE
	else:
		if ((('CONFIG_CONTROL_DESIGN.B_SPLINE_CURVE'  ==  TYPEOF(cv))  and  (cv.b_spline_curve.self_intersect  ==  FALSE))  or  (cv.b_spline_curve.self_intersect  ==  UNKNOWN)):
			return TRUE
		else:
			if (SIZEOF(['CONFIG_CONTROL_DESIGN.CONIC','CONFIG_CONTROL_DESIGN.LINE']  *  TYPEOF(cv))  ==  1):
				return TRUE
			else:
				if ('CONFIG_CONTROL_DESIGN.CURVE_REPLICA'  ==  TYPEOF(cv)):
					return msf_curve_check(cv.curve_replica.parent_curve)
				else:
					if ((('CONFIG_CONTROL_DESIGN.OFFSET_CURVE_3D'  ==  TYPEOF(cv))  and  ((cv.offset_curve_3d.self_intersect  ==  FALSE)  or  (cv.offset_curve_3d.self_intersect  ==  UNKNOWN)))  and  ( not ('CONFIG_CONTROL_DESIGN.POLYLINE'  ==  TYPEOF(cv.basis_curve)))):
						return msf_curve_check(cv.offset_curve_3d.basis_curve)
					else:
						if ('CONFIG_CONTROL_DESIGN.PCURVE'  ==  TYPEOF(cv)):
							return msf_curve_check(cv.pcurve.reference_to_curve.representation.items[1])  and  msf_surface_check(cv.pcurve.basis_surface)
						else:
							if ('CONFIG_CONTROL_DESIGN.SURFACE_CURVE'  ==  TYPEOF(cv)):
								if (msf_curve_check(cv.surface_curve.curve_3d)):
									for i in range(1,SIZEOF(cv.surface_curve.associated_geometry),1):
										if ('CONFIG_CONTROL_DESIGN.SURFACE'  ==  TYPEOF(cv.surface_curve.associated_geometry[i])):
											if ( not msf_surface_check(cv.surface_curve.associated_geometry[i])):
												return FALSE
										else:
											if ('CONFIG_CONTROL_DESIGN.PCURVE'  ==  TYPEOF(cv.surface_curve.associated_geometry[i])):
												if ( not msf_curve_check(cv.surface_curve.associated_geometry[i])):
													return FALSE
									return TRUE
							else:
								if ('CONFIG_CONTROL_DESIGN.POLYLINE'  ==  TYPEOF(cv)):
									if (SIZEOF(cv.polyline.points)  >=  3):
										return TRUE
	return FALSE

####################
 # FUNCTION using_items #
####################
def using_items(item,checked_items,):
	'''
	:param item
	:type item:founded_item_select
	:param checked_items
	:type checked_items:(null)
	'''
	result_items = []
	new_check_items = checked_items  +  item
	next_items = None
	if (SIZEOF(next_items)  >  0):
		for i in range(1,HIINDEX(next_items),1):
			if ( not (next_items[i]  ==  new_check_items)):
				result_items = (result_items  +  next_items[i])  +  using_items(next_items[i],new_check_items)
	return result_items

####################
 # FUNCTION gbsf_check_point #
####################
def gbsf_check_point(pnt,):
	'''
	:param pnt
	:type pnt:point
	'''
	if ('CONFIG_CONTROL_DESIGN.CARTESIAN_POINT'  ==  TYPEOF(pnt)):
		return TRUE
	else:
		if ('CONFIG_CONTROL_DESIGN.POINT_ON_CURVE'  ==  TYPEOF(pnt)):
			return gbsf_check_curve(pnt.point_on_curve.basis_curve)
		else:
			if ('CONFIG_CONTROL_DESIGN.POINT_ON_SURFACE'  ==  TYPEOF(pnt)):
				return gbsf_check_surface(pnt.point_on_surface.basis_surface)
			else:
				if ('CONFIG_CONTROL_DESIGN.DEGENERATE_PCURVE'  ==  TYPEOF(pnt)):
					return gbsf_check_curve(pnt.degenerate_pcurve.reference_to_curve.representation.items[1])  and  gbsf_check_surface(pnt.degenerate_pcurve.basis_surface)
	return FALSE

####################
 # FUNCTION topology_reversed #
####################
def topology_reversed(an_item,):
	'''
	:param an_item
	:type an_item:reversible_topology
	'''
	if ('CONFIG_CONTROL_DESIGN.EDGE'  ==  TYPEOF(an_item)):
		return edge_reversed(an_item)
	if ('CONFIG_CONTROL_DESIGN.PATH'  ==  TYPEOF(an_item)):
		return path_reversed(an_item)
	if ('CONFIG_CONTROL_DESIGN.FACE_BOUND'  ==  TYPEOF(an_item)):
		return face_bound_reversed(an_item)
	if ('CONFIG_CONTROL_DESIGN.FACE'  ==  TYPEOF(an_item)):
		return face_reversed(an_item)
	if ('CONFIG_CONTROL_DESIGN.SHELL'  ==  TYPEOF(an_item)):
		return shell_reversed(an_item)
	if ('SET'  ==  TYPEOF(an_item)):
		return set_of_topology_reversed(an_item)
	if ('LIST'  ==  TYPEOF(an_item)):
		return list_of_topology_reversed(an_item)
	return  None 

####################
 # RULE approval_requires_approval_person_organization #
####################
approval_requires_approval_person_organization = Rule()

####################
 # RULE dependent_instantiable_date #
####################
dependent_instantiable_date = Rule()

####################
 # RULE product_definition_requires_approval #
####################
product_definition_requires_approval = Rule()

####################
 # RULE product_definition_requires_person_organization #
####################
product_definition_requires_person_organization = Rule()

####################
 # RULE geometric_representation_item_3d #
####################
geometric_representation_item_3d = Rule()

####################
 # RULE restrict_approval_status #
####################
restrict_approval_status = Rule()

####################
 # RULE certification_requires_date_time #
####################
certification_requires_date_time = Rule()

####################
 # RULE dependent_instantiable_security_classification_level #
####################
dependent_instantiable_security_classification_level = Rule()

####################
 # RULE security_classification_requires_person_organization #
####################
security_classification_requires_person_organization = Rule()

####################
 # RULE start_request_requires_date_time #
####################
start_request_requires_date_time = Rule()

####################
 # RULE as_required_quantity #
####################
as_required_quantity = Rule()

####################
 # RULE dependent_instantiable_parametric_representation_context #
####################
dependent_instantiable_parametric_representation_context = Rule()

####################
 # RULE acu_requires_security_classification #
####################
acu_requires_security_classification = Rule()

####################
 # RULE security_classification_requires_date_time #
####################
security_classification_requires_date_time = Rule()

####################
 # RULE versioned_action_request_requires_solution #
####################
versioned_action_request_requires_solution = Rule()

####################
 # RULE configuration_item_requires_approval #
####################
configuration_item_requires_approval = Rule()

####################
 # RULE approval_date_time_constraints #
####################
approval_date_time_constraints = Rule()

####################
 # RULE dependent_instantiable_certification_type #
####################
dependent_instantiable_certification_type = Rule()

####################
 # RULE configuration_item_requires_person_organization #
####################
configuration_item_requires_person_organization = Rule()

####################
 # RULE restrict_action_request_status #
####################
restrict_action_request_status = Rule()

####################
 # RULE product_concept_requires_configuration_item #
####################
product_concept_requires_configuration_item = Rule()

####################
 # RULE restrict_security_classification_level #
####################
restrict_security_classification_level = Rule()

####################
 # RULE change_requires_date_time #
####################
change_requires_date_time = Rule()

####################
 # RULE compatible_dimension #
####################
compatible_dimension = Rule()

####################
 # RULE restrict_date_time_role #
####################
restrict_date_time_role = Rule()

####################
 # RULE versioned_action_request_requires_status #
####################
versioned_action_request_requires_status = Rule()

####################
 # RULE approval_requires_approval_date_time #
####################
approval_requires_approval_date_time = Rule()

####################
 # RULE restrict_document_type #
####################
restrict_document_type = Rule()

####################
 # RULE start_work_requires_date_time #
####################
start_work_requires_date_time = Rule()

####################
 # RULE no_shape_for_make_from #
####################
no_shape_for_make_from = Rule()

####################
 # RULE dependent_instantiable_named_unit #
####################
dependent_instantiable_named_unit = Rule()

####################
 # RULE contract_requires_approval #
####################
contract_requires_approval = Rule()

####################
 # RULE product_version_requires_security_classification #
####################
product_version_requires_security_classification = Rule()

####################
 # RULE subtype_mandatory_representation_context #
####################
subtype_mandatory_representation_context = Rule()

####################
 # RULE subtype_mandatory_product_definition_usage #
####################
subtype_mandatory_product_definition_usage = Rule()

####################
 # RULE subtype_mandatory_action #
####################
subtype_mandatory_action = Rule()

####################
 # RULE effectivity_requires_approval #
####################
effectivity_requires_approval = Rule()

####################
 # RULE product_requires_person_organization #
####################
product_requires_person_organization = Rule()

####################
 # RULE product_version_requires_approval #
####################
product_version_requires_approval = Rule()

####################
 # RULE change_request_requires_date_time #
####################
change_request_requires_date_time = Rule()

####################
 # RULE start_request_requires_person_organization #
####################
start_request_requires_person_organization = Rule()

####################
 # RULE certification_requires_approval #
####################
certification_requires_approval = Rule()

####################
 # RULE product_version_requires_person_organization #
####################
product_version_requires_person_organization = Rule()

####################
 # RULE contract_requires_person_organization #
####################
contract_requires_person_organization = Rule()

####################
 # RULE no_shape_for_supplied_part #
####################
no_shape_for_supplied_part = Rule()

####################
 # RULE product_requires_product_category #
####################
product_requires_product_category = Rule()

####################
 # RULE security_classification_optional_date_time #
####################
security_classification_optional_date_time = Rule()

####################
 # RULE restrict_product_category_value #
####################
restrict_product_category_value = Rule()

####################
 # RULE coordinated_assembly_and_shape #
####################
coordinated_assembly_and_shape = Rule()

####################
 # RULE dependent_instantiable_date_time_role #
####################
dependent_instantiable_date_time_role = Rule()

####################
 # RULE application_context_requires_ap_definition #
####################
application_context_requires_ap_definition = Rule()

####################
 # RULE approval_person_organization_constraints #
####################
approval_person_organization_constraints = Rule()

####################
 # RULE dependent_instantiable_shape_representation #
####################
dependent_instantiable_shape_representation = Rule()

####################
 # RULE global_unit_assignment #
####################
global_unit_assignment = Rule()

####################
 # RULE restrict_contract_type #
####################
restrict_contract_type = Rule()

####################
 # RULE dependent_instantiable_contract_type #
####################
dependent_instantiable_contract_type = Rule()

####################
 # RULE dependent_instantiable_approval_status #
####################
dependent_instantiable_approval_status = Rule()

####################
 # RULE change_requires_approval #
####################
change_requires_approval = Rule()

####################
 # RULE approvals_are_assigned #
####################
approvals_are_assigned = Rule()

####################
 # RULE product_requires_version #
####################
product_requires_version = Rule()

####################
 # RULE subtype_mandatory_effectivity #
####################
subtype_mandatory_effectivity = Rule()

####################
 # RULE start_request_requires_approval #
####################
start_request_requires_approval = Rule()

####################
 # RULE subtype_mandatory_product_context #
####################
subtype_mandatory_product_context = Rule()

####################
 # RULE security_classification_requires_approval #
####################
security_classification_requires_approval = Rule()

####################
 # RULE document_to_product_definition #
####################
document_to_product_definition = Rule()

####################
 # RULE product_definition_requires_date_time #
####################
product_definition_requires_date_time = Rule()

####################
 # RULE unique_version_change_order_rule #
####################
unique_version_change_order_rule = Rule()

####################
 # RULE dependent_instantiable_action_directive #
####################
dependent_instantiable_action_directive = Rule()

####################
 # RULE subtype_mandatory_representation #
####################
subtype_mandatory_representation = Rule()

####################
 # RULE change_request_requires_approval #
####################
change_request_requires_approval = Rule()

####################
 # RULE dependent_instantiable_person_and_organization_role #
####################
dependent_instantiable_person_and_organization_role = Rule()

####################
 # RULE dependent_instantiable_document_type #
####################
dependent_instantiable_document_type = Rule()

####################
 # RULE restrict_certification_type #
####################
restrict_certification_type = Rule()

####################
 # RULE subtype_mandatory_product_definition_formation #
####################
subtype_mandatory_product_definition_formation = Rule()

####################
 # RULE change_request_requires_person_organization #
####################
change_request_requires_person_organization = Rule()

####################
 # RULE design_context_for_property #
####################
design_context_for_property = Rule()

####################
 # RULE start_work_requires_approval #
####################
start_work_requires_approval = Rule()

####################
 # RULE dependent_instantiable_representation_item #
####################
dependent_instantiable_representation_item = Rule()

####################
 # RULE restrict_person_organization_role #
####################
restrict_person_organization_role = Rule()

####################
 # RULE subtype_mandatory_shape_representation #
####################
subtype_mandatory_shape_representation = Rule()
